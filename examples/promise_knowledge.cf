#  Copyright 2017 Northern.tech AS

#  This file is part of Cfengine 3 - written and maintained by Cfengine AS.

#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; version 3.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

# To the extent this program is licensed as part of the Enterprise
# versions of Cfengine, the applicable Commercial Open Source License
# (COSL) may apply to this file if you as a licensee so wish it. See
# included file COSL.txt.

bundle knowledge CfengineSiteConfiguration
{

  topics:
    references::
      "bundle reference";
      "used in promise";
      "has current exemplars";
      "is a promise of type";
      "occurs in bundle";
      "bundle contains promiser";
      "makes promise of type";
      "promises have been made by";
      "makes promises";
      "is a promise made by";
    system_reports::
      "audit report";
      "performance report";
      "all_locks report";
      "active_locks report";
      "hashes report";
      "classes report";
      "lastseen report";
      "monitor now report";
      "monitor history report";
      "monitor summary report";
      "compliance report";
      "setuid report";
      "file_changes report";
      "installed software report";
      "software patches report";
    system_policy::
      "bundles";
      "bodies";
      "contexts";
      "promisees";
      "promisers";
      "promises" comment => "occurrences of promise topics or suggestions";
      "promise types";
      "body constraints";
      "comments"
      association => a("see instances of","comment","is one of a number of");
      "functions" comment => "In built functions that may be used to set variables or classes"; "values"  comment => "Formal rvalues in constraint assignments and their legal ranges";
    values::

      "system signals"   comment =>"Should match the generic pattern hup,int,trap,kill,pipe,cont,abrt,stop,quit,term,child,usr1,usr2,bus,segv, i.e. a unix signal name";
      "boolean"   comment =>"Should match the generic pattern true,false,yes,no,on,off, i.e. a positive or a negative";
      "link type"   comment =>"Should match the generic pattern symlink,hardlink,relative,absolute,none, i.e. a support link type";
      "a time range"   comment =>"Should match the generic pattern 0,2147483647, i.e. a value from zero to a maximum system time -- but you should use time functions to convert this";
      "a positive integer"   comment =>"Should match the generic pattern 0,2147483647, i.e. a number between zero and the maximum value";
      "integer"   comment =>"Should match the generic pattern -2147483648,2147483647, i.e. a number between the minus and positive maximum values";
      "real number"   comment =>"Should match the generic pattern -9.99999E100,9.99999E100, i.e. a number between the minus and positive maximum values";
      "a single character"   comment =>"Should match the generic pattern ^.$, i.e. one symbol";
      "posix file mode or permission"   comment =>"Should match the generic pattern [0-7augorwxst,+-]+, i.e. something that you would give as an argument to chmod";
      "a cfengine class expression"   comment =>"Should match the generic pattern [a-zA-Z0-9_!&|.()]+, i.e. an alphanumeric string with option underscores and logical operators";
      "a cfengine identifier"   comment =>"Should match the generic pattern [a-zA-Z0-9_$.]+, i.e. an alphanumeric string with option underscores";
      "a user/group id"   comment =>"Should match the generic pattern [a-zA-Z0-9_$.-]+, i.e. an alphanumeric string with option underscores and hyphens";
      "a file path"   comment =>"Should match the generic pattern [cC]:\\.*|/.*, i.e. a system file path suitable for the target system";
      "a syslog level"   comment =>"Should match the generic pattern LOG_USER,LOG_DAEMON,LOG_LOCAL0,LOG_LOCAL1,LOG_LOCAL2,LOG_LOCAL3,LOG_LOCAL4,LOG_LOCAL5,LOG_LOCAL6,LOG_LOCAL7, i.e. a syslog constant";
      "An arbitrary string"   comment =>"Should match the generic pattern , i.e. unspecified characters";
      "An arbitrary string"   comment =>"Should match the generic pattern .*, i.e. unspecified characters";
      "boolean"   association => a("is a special case of","int","is the generic type for");
      "a time range"   association => a("is a special case of","int","is the generic type for");
      "a positive integer"   association => a("is a special case of","int","is the generic type for");
      "integer"   association => a("is a special case of","int","is the generic type for");
      "real number"   association => a("is a special case of","real","is the generic type for");
      "a cfengine class expression"   association => a("is a special case of","class","is the generic type for");
      "a cfengine identifier"   association => a("is a special case of","string","is the generic type for");
      "a user/group id"   association => a("is a special case of","string","is the generic type for");
      "a file path"   association => a("is a special case of","string","is the generic type for");
      "a syslog level"   association => a("is a special case of","string","is the generic type for");
      "An arbitrary string"   association => a("is a special case of","string","is the generic type for");
      "An arbitrary string"   association => a("is a special case of","string","is the generic type for");
    bundles::
      "sys" comment => "cfengine's internal bundle of system specific values";
    promise_types::
      "vars";
    body_constraints::
      "string"
      comment => "A scalar string",
      association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
    body_constraints::
      "string" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "A scalar string";
    promise_types::
      "vars";
    body_constraints::
      "int"
      comment => "A scalar integer",
      association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
    body_constraints::
      "int" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "A scalar integer";
    promise_types::
      "vars";
    body_constraints::
      "real"
      comment => "A scalar real number",
      association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
    body_constraints::
      "real" association => a("is a body constraint of type","real","has possible body constraints"),
      comment => "A scalar real number";
    promise_types::
      "vars";
    body_constraints::
      "slist"
      comment => "A list of scalar strings",
      association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
    body_constraints::
      "slist" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of scalar strings";
      "slist" association => a("is a list of type","slist","is used in");
    promise_types::
      "vars";
    body_constraints::
      "ilist"
      comment => "A list of integers",
      association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
    body_constraints::
      "ilist" association => a("is a body constraint of type","ilist","has possible body constraints"),
      comment => "A list of integers";
      "ilist" association => a("is a list of type","ilist","is used in");
    promise_types::
      "vars";
    body_constraints::
      "rlist"
      comment => "A list of real numbers",
      association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
    body_constraints::
      "rlist" association => a("is a body constraint of type","rlist","has possible body constraints"),
      comment => "A list of real numbers";
      "rlist" association => a("is a list of type","rlist","is used in");
    promise_types::
      "vars";
    body_constraints::
      "policy"
      comment => "The policy for (dis)allowing redefinition of variables",
      association => a("is a possible body constraint for","promise_types::vars","can have body constraints");
    body_constraints::
      "policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The policy for (dis)allowing redefinition of variables";
    promise_types::
      "classes";
    body_constraints::
      "or"
      comment => "Combine class sources with inclusive OR",
      association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
    body_constraints::
      "or" association => a("is a body constraint of type","clist","has possible body constraints"),
      comment => "Combine class sources with inclusive OR";
    promise_types::
      "classes";
    body_constraints::
      "and"
      comment => "Combine class sources with AND",
      association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
    body_constraints::
      "and" association => a("is a body constraint of type","clist","has possible body constraints"),
      comment => "Combine class sources with AND";
    promise_types::
      "classes";
    body_constraints::
      "xor"
      comment => "Combine class sources with XOR",
      association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
    body_constraints::
      "xor" association => a("is a body constraint of type","clist","has possible body constraints"),
      comment => "Combine class sources with XOR";
    promise_types::
      "classes";
    body_constraints::
      "dist"
      comment => "Generate a probabilistic class distribution (strategy in cfengine 2)",
      association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
    body_constraints::
      "dist" association => a("is a body constraint of type","rlist","has possible body constraints"),
      comment => "Generate a probabilistic class distribution (strategy in cfengine 2)";
      "dist" association => a("is a list of type","rlist","is used in");
    promise_types::
      "classes";
    body_constraints::
      "expression"
      comment => "Evaluate string expression of classes in normal form",
      association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
    body_constraints::
      "expression" association => a("is a body constraint of type","class","has possible body constraints"),
      comment => "Evaluate string expression of classes in normal form";
    promise_types::
      "classes";
    body_constraints::
      "not"
      comment => "Evaluate the negation of string expression in normal form",
      association => a("is a possible body constraint for","promise_types::classes","can have body constraints");
    body_constraints::
      "not" association => a("is a body constraint of type","class","has possible body constraints"),
      comment => "Evaluate the negation of string expression in normal form";
    promise_types::
      "reports";
    body_constraints::
      "lastseen"
      comment => "Integer time threshold in hours since current peers were last seen, report absence",
      association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
    body_constraints::
      "lastseen" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Integer time threshold in hours since current peers were last seen, report absence";
    promise_types::
      "reports";
    body_constraints::
      "intermittency"
      comment => "Real number threshold [0,1] of intermittency about current peers, report above",
      association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
    body_constraints::
      "intermittency" association => a("is a body constraint of type","real","has possible body constraints"),
      comment => "Real number threshold [0,1] of intermittency about current peers, report above";
    promise_types::
      "reports";
    body_constraints::
      "showstate"
      comment => "List of services about which status reports should be reported to standard output",
      association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
    body_constraints::
      "showstate" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of services about which status reports should be reported to standard output";
      "showstate" association => a("is a list of type","slist","is used in");
    promise_types::
      "reports";
    body_constraints::
      "printfile"
      comment => "Quote part of a file to standard output",
      association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
      "number_of_lines"
      comment => "Integer maximum number of lines to print from selected file",
      association => a("is a possible sub-body constraint for","printfile","may have sub-body constraints");
    body_constraints::
      "number_of_lines" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Integer maximum number of lines to print from selected file";
      "file_to_print"
      comment => "Path name to the file that is to be sent to standard output",
      association => a("is a possible sub-body constraint for","printfile","may have sub-body constraints");
    body_constraints::
      "file_to_print" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Path name to the file that is to be sent to standard output";
    promise_types::
      "reports";
    body_constraints::
      "friend_pattern"
      comment => "Regular expression to keep selected hosts from the friends report list",
      association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
    body_constraints::
      "friend_pattern" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression to keep selected hosts from the friends report list";
    promise_types::
      "reports";
    body_constraints::
      "report_to_file"
      comment => "The path and filename to which output should be appended",
      association => a("is a possible body constraint for","promise_types::reports","can have body constraints");
    body_constraints::
      "report_to_file" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The path and filename to which output should be appended";
    promise_types::
      "*";
    body_constraints::
      "action"
      comment => "Output behaviour",
      association => a("is a possible body constraint for","promise_types::*","can have body constraints");
      "action_policy"
      comment => "Whether to repair or report about non-kept promises",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "action_policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Whether to repair or report about non-kept promises";
      "ifelapsed"
      comment => "Number of minutes before next allowed assessment of promise",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "ifelapsed" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Number of minutes before next allowed assessment of promise";
      "expireafter"
      comment => "Number of minutes before a repair action is interrupted and retried",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "expireafter" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Number of minutes before a repair action is interrupted and retried";
      "log_string"
      comment => "A message to be written to the log when a promise verification leads to a repair",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "log_string" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "A message to be written to the log when a promise verification leads to a repair";
      "log_level"
      comment => "The reporting level sent to syslog",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "log_level" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The reporting level sent to syslog";
      "log_kept"
      comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "log_kept" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog";
      "log_repaired"
      comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "log_repaired" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog";
      "log_failed"
      comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "log_failed" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "This should be filename of a file to which log_string will be saved, if undefined it goes to syslog";
      "audit"
      comment => "true/false switch for detailed audit records of this promise",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "audit" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false switch for detailed audit records of this promise";
      "background"
      comment => "true/false switch for parallelizing the promise repair",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "background" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false switch for parallelizing the promise repair";
      "report_level"
      comment => "The reporting level for standard output",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "report_level" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The reporting level for standard output";
      "measurement_class"
      comment => "If set performance will be measured and recorded under this identifier",
      association => a("is a possible sub-body constraint for","action","may have sub-body constraints");
    body_constraints::
      "measurement_class" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "If set performance will be measured and recorded under this identifier";
    promise_types::
      "*";
    body_constraints::
      "classes"
      comment => "Signalling behaviour",
      association => a("is a possible body constraint for","promise_types::*","can have body constraints");
      "promise_repaired"
      comment => "A list of classes to be defined",
      association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
    body_constraints::
      "promise_repaired" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of classes to be defined";
      "promise_repaired" association => a("is a list of type","slist","is used in");
      "repair_failed"
      comment => "A list of classes to be defined",
      association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
    body_constraints::
      "repair_failed" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of classes to be defined";
      "repair_failed" association => a("is a list of type","slist","is used in");
      "repair_denied"
      comment => "A list of classes to be defined",
      association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
    body_constraints::
      "repair_denied" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of classes to be defined";
      "repair_denied" association => a("is a list of type","slist","is used in");
      "repair_timeout"
      comment => "A list of classes to be defined",
      association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
    body_constraints::
      "repair_timeout" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of classes to be defined";
      "repair_timeout" association => a("is a list of type","slist","is used in");
      "promise_kept"
      comment => "A list of classes to be defined",
      association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
    body_constraints::
      "promise_kept" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of classes to be defined";
      "promise_kept" association => a("is a list of type","slist","is used in");
      "persist_time"
      comment => "A number of minutes the specified classes should remain active",
      association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
    body_constraints::
      "persist_time" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "A number of minutes the specified classes should remain active";
      "timer_policy"
      comment => "Whether a persistent class restarts its counter when rediscovered",
      association => a("is a possible sub-body constraint for","classes","may have sub-body constraints");
    body_constraints::
      "timer_policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Whether a persistent class restarts its counter when rediscovered";
    promise_types::
      "*";
    body_constraints::
      "ifvarclass"
      comment => "Extended classes ANDed with context",
      association => a("is a possible body constraint for","promise_types::*","can have body constraints");
    body_constraints::
      "ifvarclass" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Extended classes ANDed with context";
    promise_types::
      "*";
    body_constraints::
      "handle"
      comment => "A unique id-tag string for referring to this as a promisee elsewhere",
      association => a("is a possible body constraint for","promise_types::*","can have body constraints");
    body_constraints::
      "handle" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "A unique id-tag string for referring to this as a promisee elsewhere";
    promise_types::
      "*";
    body_constraints::
      "depends_on"
      comment => "A list of promise handles that this promise builds on or depends on somehow (for knowledge management)",
      association => a("is a possible body constraint for","promise_types::*","can have body constraints");
    body_constraints::
      "depends_on" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of promise handles that this promise builds on or depends on somehow (for knowledge management)";
      "depends_on" association => a("is a list of type","slist","is used in");
    promise_types::
      "*";
    body_constraints::
      "comment"
      comment => "A comment about this promise's real intention that follows through the program",
      association => a("is a possible body constraint for","promise_types::*","can have body constraints");
    body_constraints::
      "comment" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "A comment about this promise's real intention that follows through the program";
    promise_types::
      "*";
    body_constraints::
      "select_region"
      comment => "Limit edits to a demarked region of the file",
      association => a("is a possible body constraint for","promise_types::*","can have body constraints");
      "select_start"
      comment => "Regular expression matching start of edit region",
      association => a("is a possible sub-body constraint for","select_region","may have sub-body constraints");
    body_constraints::
      "select_start" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression matching start of edit region";
      "select_end"
      comment => "Regular expression matches end of edit region from start",
      association => a("is a possible sub-body constraint for","select_region","may have sub-body constraints");
    body_constraints::
      "select_end" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression matches end of edit region from start";
    promise_types::
      "commands";
    body_constraints::
      "args"
      comment => "Alternative string of arguments for the command (concatenated with promiser string)",
      association => a("is a possible body constraint for","promise_types::commands","can have body constraints");
    body_constraints::
      "args" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Alternative string of arguments for the command (concatenated with promiser string)";
    promise_types::
      "commands";
    body_constraints::
      "contain"
      comment => "Containment options for the execution process",
      association => a("is a possible body constraint for","promise_types::commands","can have body constraints");
      "useshell"
      comment => "noshell/useshell/powershell embed the command in the given shell environment (noshell)",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "useshell" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "noshell/useshell/powershell embed the command in the given shell environment (noshell)";
      "umask"
      comment => "The umask value for the child process",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "umask" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The umask value for the child process";
      "exec_owner"
      comment => "The user name or id under which to run the process",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "exec_owner" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The user name or id under which to run the process";
      "exec_group"
      comment => "The group name or id under which to run the process",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "exec_group" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The group name or id under which to run the process";
      "exec_timeout"
      comment => "Timeout in seconds for command completion",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "exec_timeout" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Timeout in seconds for command completion";
      "chdir"
      comment => "Directory for setting current/base directory for the process",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "chdir" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Directory for setting current/base directory for the process";
      "chroot"
      comment => "Directory of root sandbox for process",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "chroot" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Directory of root sandbox for process";
      "preview"
      comment => "true/false preview command when running in dry-run mode (with -n)",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "preview" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false preview command when running in dry-run mode (with -n)";
      "no_output"
      comment => "true/false discard all output from the command",
      association => a("is a possible sub-body constraint for","contain","may have sub-body constraints");
    body_constraints::
      "no_output" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false discard all output from the command";
    promise_types::
      "commands";
    body_constraints::
      "module"
      comment => "true/false whether to expect the cfengine module protocol",
      association => a("is a possible body constraint for","promise_types::commands","can have body constraints");
    body_constraints::
      "module" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to expect the cfengine module protocol";
    promise_types::
      "databases";
    body_constraints::
      "database_server"
      comment => "Credentials for connecting to a local/remote database server",
      association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
      "db_server_owner"
      comment => "User name for database connection",
      association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
    body_constraints::
      "db_server_owner" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "User name for database connection";
      "db_server_password"
      comment => "Clear text password for database connection",
      association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
    body_constraints::
      "db_server_password" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Clear text password for database connection";
      "db_server_host"
      comment => "Hostname or address for connection to database, blank means localhost",
      association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
    body_constraints::
      "db_server_host" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Hostname or address for connection to database, blank means localhost";
      "db_server_type"
      comment => "The dialect of the database server",
      association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
    body_constraints::
      "db_server_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The dialect of the database server";
      "db_server_connection_db"
      comment => "The name of an existing database to connect to in order to create/manage other databases",
      association => a("is a possible sub-body constraint for","database_server","may have sub-body constraints");
    body_constraints::
      "db_server_connection_db" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The name of an existing database to connect to in order to create/manage other databases";
    promise_types::
      "databases";
    body_constraints::
      "database_type"
      comment => "The type of database that is to be manipulated",
      association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
    body_constraints::
      "database_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The type of database that is to be manipulated";
    promise_types::
      "databases";
    body_constraints::
      "database_operation"
      comment => "The nature of the promise - to be or not to be",
      association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
    body_constraints::
      "database_operation" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The nature of the promise - to be or not to be";
    promise_types::
      "databases";
    body_constraints::
      "database_columns"
      comment => "A list of column definitions to be promised by SQL databases",
      association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
    body_constraints::
      "database_columns" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of column definitions to be promised by SQL databases";
      "database_columns" association => a("is a list of type","slist","is used in");
    promise_types::
      "databases";
    body_constraints::
      "database_rows"
      comment => "An ordered list of row values to be promised by SQL databases",
      association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
    body_constraints::
      "database_rows" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "An ordered list of row values to be promised by SQL databases";
      "database_rows" association => a("is a list of type","slist","is used in");
    promise_types::
      "databases";
    body_constraints::
      "registry_exclude"
      comment => "A list of regular expressions to ignore in key/value verification",
      association => a("is a possible body constraint for","promise_types::databases","can have body constraints");
    body_constraints::
      "registry_exclude" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of regular expressions to ignore in key/value verification";
      "registry_exclude" association => a("is a list of type","slist","is used in");
    promise_types::
      "files";
    body_constraints::
      "file_select"
      comment => "Choose which files select in a search",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "leaf_name"
      comment => "List of regexes that match an acceptable name",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "leaf_name" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of regexes that match an acceptable name";
      "leaf_name" association => a("is a list of type","slist","is used in");
      "path_name"
      comment => "List of pathnames to match acceptable target",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "path_name" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of pathnames to match acceptable target";
      "path_name" association => a("is a list of type","slist","is used in");
      "search_mode"
      comment => "A list of mode masks for acceptable file permissions",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "search_mode" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of mode masks for acceptable file permissions";
      "search_mode" association => a("is a list of type","slist","is used in");
      "search_size"
      comment => "Integer range of file sizes",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "search_size" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Integer range of file sizes";
      "search_owners"
      comment => "List of acceptable user names or ids for the file, or regexes to match",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "search_owners" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of acceptable user names or ids for the file, or regexes to match";
      "search_owners" association => a("is a list of type","slist","is used in");
      "search_groups"
      comment => "List of acceptable group names or ids for the file, or regexes to match",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "search_groups" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of acceptable group names or ids for the file, or regexes to match";
      "search_groups" association => a("is a list of type","slist","is used in");
      "search_bsdflags"
      comment => "String of flags for bsd file system flags expected set",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "search_bsdflags" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "String of flags for bsd file system flags expected set";
      "ctime"
      comment => "Range of change times (ctime) for acceptable files",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "ctime" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of change times (ctime) for acceptable files";
      "mtime"
      comment => "Range of modification times (mtime) for acceptable files",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "mtime" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of modification times (mtime) for acceptable files";
      "atime"
      comment => "Range of access times (atime) for acceptable files",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "atime" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of access times (atime) for acceptable files";
      "exec_regex"
      comment => "Matches file if this regular expression matches any full line returned by the command",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "exec_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Matches file if this regular expression matches any full line returned by the command";
      "exec_program"
      comment => "Execute this command on each file and match if the exit status is zero",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "exec_program" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Execute this command on each file and match if the exit status is zero";
      "file_types"
      comment => "List of acceptable file types from menu choices",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "file_types" association => a("is a body constraint of type","(option list)","has possible body constraints"),
      comment => "List of acceptable file types from menu choices";
      "issymlinkto"
      comment => "List of regular expressions to match file objects",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "issymlinkto" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of regular expressions to match file objects";
      "issymlinkto" association => a("is a list of type","slist","is used in");
      "file_result"
      comment => "Logical expression combining classes defined by file search criteria",
      association => a("is a possible sub-body constraint for","file_select","may have sub-body constraints");
    body_constraints::
      "file_result" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Logical expression combining classes defined by file search criteria";
    promise_types::
      "files";
    body_constraints::
      "copy_from"
      comment => "Criteria for copying file from a source",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "source"
      comment => "Reference source file from which to copy",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "source" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Reference source file from which to copy";
      "servers"
      comment => "List of servers in order of preference from which to copy",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "servers" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of servers in order of preference from which to copy";
      "servers" association => a("is a list of type","slist","is used in");
      "portnumber"
      comment => "Port number to connect to on server host",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "portnumber" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Port number to connect to on server host";
      "copy_backup"
      comment => "Menu option policy for file backup/version control",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "copy_backup" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option policy for file backup/version control";
      "stealth"
      comment => "true/false whether to preserve time stamps on copied file",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "stealth" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to preserve time stamps on copied file";
      "preserve"
      comment => "true/false whether to preserve file permissions on copied file",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "preserve" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to preserve file permissions on copied file";
      "linkcopy_patterns"
      comment => "List of patterns matching symbolic links that should be replaced with copies",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "linkcopy_patterns" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of patterns matching symbolic links that should be replaced with copies";
      "linkcopy_patterns" association => a("is a list of type","slist","is used in");
      "copylink_patterns"
      comment => "List of patterns matching files that should be linked instead of copied",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "copylink_patterns" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of patterns matching files that should be linked instead of copied";
      "copylink_patterns" association => a("is a list of type","slist","is used in");
      "compare"
      comment => "Menu option policy for comparing source and image file attributes",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "compare" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option policy for comparing source and image file attributes";
      "link_type"
      comment => "Menu option for type of links to use when copying",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "link_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option for type of links to use when copying";
      "type_check"
      comment => "true/false compare file types before copying and require match",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "type_check" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false compare file types before copying and require match";
      "force_update"
      comment => "true/false force copy update always",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "force_update" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false force copy update always";
      "force_ipv4"
      comment => "true/false force use of ipv4 on ipv6 enabled network",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "force_ipv4" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false force use of ipv4 on ipv6 enabled network";
      "copy_size"
      comment => "Integer range of file sizes that may be copied",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "copy_size" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Integer range of file sizes that may be copied";
      "trustkey"
      comment => "true/false trust public keys from remote server if previously unknown",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "trustkey" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false trust public keys from remote server if previously unknown";
      "encrypt"
      comment => "true/false use encrypted data stream to connect to remote host",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "encrypt" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false use encrypted data stream to connect to remote host";
      "verify"
      comment => "true/false verify transferred file by hashing after copy (resource penalty)",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "verify" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false verify transferred file by hashing after copy (resource penalty)";
      "purge"
      comment => "true/false purge files on client that do not match files on server when depth_search",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "purge" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false purge files on client that do not match files on server when depth_search";
      "check_root"
      comment => "true/false check permissions on the root directory when depth_search",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "check_root" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false check permissions on the root directory when depth_search";
      "findertype"
      comment => "Menu option for default finder type on MacOSX",
      association => a("is a possible sub-body constraint for","copy_from","may have sub-body constraints");
    body_constraints::
      "findertype" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option for default finder type on MacOSX";
    promise_types::
      "files";
    body_constraints::
      "link_from"
      comment => "Criteria for linking file from a source",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "source"
      comment => "The source file to which the link should point",
      association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
    body_constraints::
      "source" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The source file to which the link should point";
      "link_type"
      comment => "The type of link used to alias the file",
      association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
    body_constraints::
      "link_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The type of link used to alias the file";
      "copy_patterns"
      comment => "A set of patterns that should be copied ansd synchronized instead of linked",
      association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
    body_constraints::
      "copy_patterns" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A set of patterns that should be copied ansd synchronized instead of linked";
      "copy_patterns" association => a("is a list of type","slist","is used in");
      "when_no_source"
      comment => "Behaviour when the source file to link to does not exist",
      association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
    body_constraints::
      "when_no_source" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Behaviour when the source file to link to does not exist";
      "link_children"
      comment => "true/false whether to link all directory's children to source originals",
      association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
    body_constraints::
      "link_children" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to link all directory's children to source originals";
      "when_linking_children"
      comment => "Policy for overriding existing files when linking directories of children",
      association => a("is a possible sub-body constraint for","link_from","may have sub-body constraints");
    body_constraints::
      "when_linking_children" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Policy for overriding existing files when linking directories of children";
    promise_types::
      "files";
    body_constraints::
      "perms"
      comment => "Criteria for setting permissions on a file",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "mode"
      comment => "File permissions (like posix chmod)",
      association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
    body_constraints::
      "mode" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "File permissions (like posix chmod)";
      "owners"
      comment => "List of acceptable owners or user ids, first is change target",
      association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
    body_constraints::
      "owners" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of acceptable owners or user ids, first is change target";
      "owners" association => a("is a list of type","slist","is used in");
      "groups"
      comment => "List of acceptable groups of group ids, first is change target",
      association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
    body_constraints::
      "groups" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of acceptable groups of group ids, first is change target";
      "groups" association => a("is a list of type","slist","is used in");
      "rxdirs"
      comment => "true/false add execute flag for directories if read flag is set",
      association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
    body_constraints::
      "rxdirs" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false add execute flag for directories if read flag is set";
      "bsdflags"
      comment => "List of menu options for bsd file system flags to set",
      association => a("is a possible sub-body constraint for","perms","may have sub-body constraints");
    body_constraints::
      "bsdflags" association => a("is a body constraint of type","(option list)","has possible body constraints"),
      comment => "List of menu options for bsd file system flags to set";
    promise_types::
      "files";
    body_constraints::
      "changes"
      comment => "Criteria for change management",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "hash"
      comment => "Hash files for change detection",
      association => a("is a possible sub-body constraint for","changes","may have sub-body constraints");
    body_constraints::
      "hash" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Hash files for change detection";
      "report_changes"
      comment => "Specify criteria for change warnings",
      association => a("is a possible sub-body constraint for","changes","may have sub-body constraints");
    body_constraints::
      "report_changes" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Specify criteria for change warnings";
      "update_hashes"
      comment => "Update hash values immediately after change warning",
      association => a("is a possible sub-body constraint for","changes","may have sub-body constraints");
    body_constraints::
      "update_hashes" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Update hash values immediately after change warning";
    promise_types::
      "files";
    body_constraints::
      "delete"
      comment => "Criteria for deleting files",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "dirlinks"
      comment => "Menu option policy for dealing with symbolic links to directories during deletion",
      association => a("is a possible sub-body constraint for","delete","may have sub-body constraints");
    body_constraints::
      "dirlinks" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option policy for dealing with symbolic links to directories during deletion";
      "rmdirs"
      comment => "true/false whether to delete empty directories during recursive deletion",
      association => a("is a possible sub-body constraint for","delete","may have sub-body constraints");
    body_constraints::
      "rmdirs" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to delete empty directories during recursive deletion";
    promise_types::
      "files";
    body_constraints::
      "rename"
      comment => "Criteria for renaming files",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "newname"
      comment => "The desired name for the current file",
      association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
    body_constraints::
      "newname" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The desired name for the current file";
      "disable_suffix"
      comment => "The suffix to add to files when disabling (.cfdisabled)",
      association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
    body_constraints::
      "disable_suffix" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The suffix to add to files when disabling (.cfdisabled)";
      "disable"
      comment => "true/false automatically rename and remove permissions",
      association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
    body_constraints::
      "disable" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false automatically rename and remove permissions";
      "rotate"
      comment => "Maximum number of file rotations to keep",
      association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
    body_constraints::
      "rotate" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Maximum number of file rotations to keep";
      "disable_mode"
      comment => "The permissions to set when a file is disabled",
      association => a("is a possible sub-body constraint for","rename","may have sub-body constraints");
    body_constraints::
      "disable_mode" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The permissions to set when a file is disabled";
    promise_types::
      "files";
    body_constraints::
      "repository"
      comment => "Name of a repository for versioning",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "repository" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Name of a repository for versioning";
    promise_types::
      "files";
    body_constraints::
      "edit_line"
      comment => "Line editing model for file",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "edit_line" association => a("is a body constraint of type","(ext bundle)","has possible body constraints"),
      comment => "Line editing model for file";
    promise_types::
      "files";
    body_constraints::
      "edit_xml"
      comment => "XML editing model for file",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "edit_xml" association => a("is a body constraint of type","(ext bundle)","has possible body constraints"),
      comment => "XML editing model for file";
    promise_types::
      "files";
    body_constraints::
      "edit_defaults"
      comment => "Default promise details for file edits",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "edit_backup"
      comment => "Menu option for backup policy on edit changes",
      association => a("is a possible sub-body constraint for","edit_defaults","may have sub-body constraints");
    body_constraints::
      "edit_backup" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option for backup policy on edit changes";
      "max_file_size"
      comment => "Do not edit files bigger than this number of bytes",
      association => a("is a possible sub-body constraint for","edit_defaults","may have sub-body constraints");
    body_constraints::
      "max_file_size" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Do not edit files bigger than this number of bytes";
      "empty_file_before_editing"
      comment => "Baseline memory model of file to zero/empty before commencing promised edits",
      association => a("is a possible sub-body constraint for","edit_defaults","may have sub-body constraints");
    body_constraints::
      "empty_file_before_editing" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Baseline memory model of file to zero/empty before commencing promised edits";
    promise_types::
      "files";
    body_constraints::
      "depth_search"
      comment => "Criteria for file depth searches",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "include_dirs"
      comment => "List of regexes of directory names to include in depth search",
      association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
    body_constraints::
      "include_dirs" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of regexes of directory names to include in depth search";
      "include_dirs" association => a("is a list of type","slist","is used in");
      "exclude_dirs"
      comment => "List of regexes of directory names NOT to include in depth search",
      association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
    body_constraints::
      "exclude_dirs" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of regexes of directory names NOT to include in depth search";
      "exclude_dirs" association => a("is a list of type","slist","is used in");
      "include_basedir"
      comment => "true/false include the start/root dir of the search results",
      association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
    body_constraints::
      "include_basedir" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false include the start/root dir of the search results";
      "depth"
      comment => "Maximum depth level for search",
      association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
    body_constraints::
      "depth" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Maximum depth level for search";
      "xdev"
      comment => "true/false exclude directories that are on different devices",
      association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
    body_constraints::
      "xdev" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false exclude directories that are on different devices";
      "traverse_links"
      comment => "true/false traverse symbolic links to directories (false)",
      association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
    body_constraints::
      "traverse_links" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false traverse symbolic links to directories (false)";
      "rmdeadlinks"
      comment => "true/false remove links that point to nowhere",
      association => a("is a possible sub-body constraint for","depth_search","may have sub-body constraints");
    body_constraints::
      "rmdeadlinks" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false remove links that point to nowhere";
    promise_types::
      "files";
    body_constraints::
      "touch"
      comment => "true/false whether to touch time stamps on file",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "touch" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to touch time stamps on file";
    promise_types::
      "files";
    body_constraints::
      "create"
      comment => "true/false whether to create non-existing file",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "create" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to create non-existing file";
    promise_types::
      "files";
    body_constraints::
      "move_obstructions"
      comment => "true/false whether to move obstructions to file-object creation",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "move_obstructions" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether to move obstructions to file-object creation";
    promise_types::
      "files";
    body_constraints::
      "transformer"
      comment => "Shell command (with full path) used to transform current file",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "transformer" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Shell command (with full path) used to transform current file";
    promise_types::
      "files";
    body_constraints::
      "pathtype"
      comment => "Menu option for interpreting promiser file object",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
    body_constraints::
      "pathtype" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option for interpreting promiser file object";
    promise_types::
      "files";
    body_constraints::
      "acl"
      comment => "Criteria for access control lists on file",
      association => a("is a possible body constraint for","promise_types::files","can have body constraints");
      "acl_method"
      comment => "Editing method for access control list",
      association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
    body_constraints::
      "acl_method" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Editing method for access control list";
      "acl_type"
      comment => "Access control list type for the affected file system",
      association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
    body_constraints::
      "acl_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Access control list type for the affected file system";
      "acl_default"
      comment => "How to apply default (inheritable) access control list",
      association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
    body_constraints::
      "acl_default" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "How to apply default (inheritable) access control list";
      "aces"
      comment => "Native settings for access control entry",
      association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
    body_constraints::
      "aces" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Native settings for access control entry";
      "aces" association => a("is a list of type","slist","is used in");
      "default_aces"
      comment => "Native settings for access control entry",
      association => a("is a possible sub-body constraint for","acl","may have sub-body constraints");
    body_constraints::
      "default_aces" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Native settings for access control entry";
      "default_aces" association => a("is a list of type","slist","is used in");
    promise_types::
      "insert_lines";
    body_constraints::
      "location"
      comment => "Specify where in a file an insertion will be made",
      association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
      "select_line_matching"
      comment => "Regular expression for matching file line location",
      association => a("is a possible sub-body constraint for","location","may have sub-body constraints");
    body_constraints::
      "select_line_matching" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression for matching file line location";
      "before_after"
      comment => "Menu option, point cursor before of after matched line",
      association => a("is a possible sub-body constraint for","location","may have sub-body constraints");
    body_constraints::
      "before_after" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option, point cursor before of after matched line";
      "first_last"
      comment => "Menu option, choose first or last occurrence of match in file",
      association => a("is a possible sub-body constraint for","location","may have sub-body constraints");
    body_constraints::
      "first_last" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option, choose first or last occurrence of match in file";
    promise_types::
      "insert_lines";
    body_constraints::
      "insert_type"
      comment => "Type of object the promiser string refers to (default literal)",
      association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
    body_constraints::
      "insert_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Type of object the promiser string refers to (default literal)";
    promise_types::
      "insert_lines";
    body_constraints::
      "insert_select"
      comment => "Insert only if lines pass filter criteria",
      association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
      "insert_if_startwith_from_list"
      comment => "Insert line if it starts with a string in the list",
      association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
    body_constraints::
      "insert_if_startwith_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Insert line if it starts with a string in the list";
      "insert_if_startwith_from_list" association => a("is a list of type","slist","is used in");
      "insert_if_not_startwith_from_list"
      comment => "Insert line if it DOES NOT start with a string in the list",
      association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
    body_constraints::
      "insert_if_not_startwith_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Insert line if it DOES NOT start with a string in the list";
      "insert_if_not_startwith_from_list" association => a("is a list of type","slist","is used in");
      "insert_if_match_from_list"
      comment => "Insert line if it fully matches a regex in the list",
      association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
    body_constraints::
      "insert_if_match_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Insert line if it fully matches a regex in the list";
      "insert_if_match_from_list" association => a("is a list of type","slist","is used in");
      "insert_if_not_match_from_list"
      comment => "Insert line if it DOES NOT fully match a regex in the list",
      association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
    body_constraints::
      "insert_if_not_match_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Insert line if it DOES NOT fully match a regex in the list";
      "insert_if_not_match_from_list" association => a("is a list of type","slist","is used in");
      "insert_if_contains_from_list"
      comment => "Insert line if a regex in the list match a line fragment",
      association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
    body_constraints::
      "insert_if_contains_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Insert line if a regex in the list match a line fragment";
      "insert_if_contains_from_list" association => a("is a list of type","slist","is used in");
      "insert_if_not_contains_from_list"
      comment => "Insert line if a regex in the list DOES NOT match a line fragment",
      association => a("is a possible sub-body constraint for","insert_select","may have sub-body constraints");
    body_constraints::
      "insert_if_not_contains_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Insert line if a regex in the list DOES NOT match a line fragment";
      "insert_if_not_contains_from_list" association => a("is a list of type","slist","is used in");
    promise_types::
      "insert_lines";
    body_constraints::
      "expand_scalars"
      comment => "Expand any unexpanded variables",
      association => a("is a possible body constraint for","promise_types::insert_lines","can have body constraints");
    body_constraints::
      "expand_scalars" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Expand any unexpanded variables";
    promise_types::
      "field_edits";
    body_constraints::
      "edit_field"
      comment => "Edit line-based file as matrix of fields",
      association => a("is a possible body constraint for","promise_types::field_edits","can have body constraints");
      "field_separator"
      comment => "The regular expression used to separate fields in a line",
      association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
    body_constraints::
      "field_separator" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The regular expression used to separate fields in a line";
      "select_field"
      comment => "Integer index of the field required 1..n",
      association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
    body_constraints::
      "select_field" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Integer index of the field required 1..n";
      "value_separator"
      comment => "Character separator for subfields inside the selected field",
      association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
    body_constraints::
      "value_separator" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Character separator for subfields inside the selected field";
      "field_value"
      comment => "Set field value to a fixed value",
      association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
    body_constraints::
      "field_value" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Set field value to a fixed value";
      "field_operation"
      comment => "Menu option policy for editing subfields",
      association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
    body_constraints::
      "field_operation" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option policy for editing subfields";
      "extend_fields"
      comment => "true/false add new fields at end of line if necessary to complete edit",
      association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
    body_constraints::
      "extend_fields" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false add new fields at end of line if necessary to complete edit";
      "allow_blank_fields"
      comment => "true/false allow blank fields in a line (do not purge)",
      association => a("is a possible sub-body constraint for","edit_field","may have sub-body constraints");
    body_constraints::
      "allow_blank_fields" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false allow blank fields in a line (do not purge)";
    promise_types::
      "replace_patterns";
    body_constraints::
      "replace_with"
      comment => "Search-replace pattern",
      association => a("is a possible body constraint for","promise_types::replace_patterns","can have body constraints");
      "replace_value"
      comment => "Value used to replace regular expression matches in search",
      association => a("is a possible sub-body constraint for","replace_with","may have sub-body constraints");
    body_constraints::
      "replace_value" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Value used to replace regular expression matches in search";
      "occurrences"
      comment => "Menu option to replace all occurrences or just first (NB the latter is non-convergent)",
      association => a("is a possible sub-body constraint for","replace_with","may have sub-body constraints");
    body_constraints::
      "occurrences" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option to replace all occurrences or just first (NB the latter is non-convergent)";
    promise_types::
      "delete_lines";
    body_constraints::
      "not_matching"
      comment => "true/false negate match criterion",
      association => a("is a possible body constraint for","promise_types::delete_lines","can have body constraints");
    body_constraints::
      "not_matching" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false negate match criterion";
    promise_types::
      "delete_lines";
    body_constraints::
      "delete_select"
      comment => "Delete only if lines pass filter criteria",
      association => a("is a possible body constraint for","promise_types::delete_lines","can have body constraints");
      "delete_if_startwith_from_list"
      comment => "Delete line if it starts with a string in the list",
      association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
    body_constraints::
      "delete_if_startwith_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Delete line if it starts with a string in the list";
      "delete_if_startwith_from_list" association => a("is a list of type","slist","is used in");
      "delete_if_not_startwith_from_list"
      comment => "Delete line if it DOES NOT start with a string in the list",
      association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
    body_constraints::
      "delete_if_not_startwith_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Delete line if it DOES NOT start with a string in the list";
      "delete_if_not_startwith_from_list" association => a("is a list of type","slist","is used in");
      "delete_if_match_from_list"
      comment => "Delete line if it fully matches a regex in the list",
      association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
    body_constraints::
      "delete_if_match_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Delete line if it fully matches a regex in the list";
      "delete_if_match_from_list" association => a("is a list of type","slist","is used in");
      "delete_if_not_match_from_list"
      comment => "Delete line if it DOES NOT fully match a regex in the list",
      association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
    body_constraints::
      "delete_if_not_match_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Delete line if it DOES NOT fully match a regex in the list";
      "delete_if_not_match_from_list" association => a("is a list of type","slist","is used in");
      "delete_if_contains_from_list"
      comment => "Delete line if a regex in the list match a line fragment",
      association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
    body_constraints::
      "delete_if_contains_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Delete line if a regex in the list match a line fragment";
      "delete_if_contains_from_list" association => a("is a list of type","slist","is used in");
      "delete_if_not_contains_from_list"
      comment => "Delete line if a regex in the list DOES NOT match a line fragment",
      association => a("is a possible sub-body constraint for","delete_select","may have sub-body constraints");
    body_constraints::
      "delete_if_not_contains_from_list" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Delete line if a regex in the list DOES NOT match a line fragment";
      "delete_if_not_contains_from_list" association => a("is a list of type","slist","is used in");
    promise_types::
      "interfaces";
    body_constraints::
      "tcp_ip"
      comment => "Interface tcp/ip properties",
      association => a("is a possible body constraint for","promise_types::interfaces","can have body constraints");
      "ipv4_address"
      comment => "IPv4 address for the interface",
      association => a("is a possible sub-body constraint for","tcp_ip","may have sub-body constraints");
    body_constraints::
      "ipv4_address" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "IPv4 address for the interface";
      "ipv4_netmask"
      comment => "Netmask for the interface",
      association => a("is a possible sub-body constraint for","tcp_ip","may have sub-body constraints");
    body_constraints::
      "ipv4_netmask" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Netmask for the interface";
      "ipv6_address"
      comment => "IPv6 address for the interface",
      association => a("is a possible sub-body constraint for","tcp_ip","may have sub-body constraints");
    body_constraints::
      "ipv6_address" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "IPv6 address for the interface";
    promise_types::
      "methods";
    body_constraints::
      "usebundle"
      comment => "Specify the name of a bundle to run as a parameterized method",
      association => a("is a possible body constraint for","promise_types::methods","can have body constraints");
    body_constraints::
      "usebundle" association => a("is a body constraint of type","(ext bundle)","has possible body constraints"),
      comment => "Specify the name of a bundle to run as a parameterized method";
    promise_types::
      "packages";
    body_constraints::
      "package_policy"
      comment => "Criteria for package installation/upgrade on the current system",
      association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
    body_constraints::
      "package_policy" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Criteria for package installation/upgrade on the current system";
    promise_types::
      "packages";
    body_constraints::
      "package_method"
      comment => "Criteria for installation and verification",
      association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
      "package_changes"
      comment => "Menu option - whether to group packages into a single aggregate command",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_changes" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Menu option - whether to group packages into a single aggregate command";
      "package_file_repositories"
      comment => "A list of machine-local directories to search for packages",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_file_repositories" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "A list of machine-local directories to search for packages";
      "package_file_repositories" association => a("is a list of type","slist","is used in");
      "package_list_command"
      comment => "Command to obtain a list of installed packages",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_list_command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Command to obtain a list of installed packages";
      "package_list_version_regex"
      comment => "Regular expression with one backreference to extract package version string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_list_version_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract package version string";
      "package_list_name_regex"
      comment => "Regular expression with one backreference to extract package name string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_list_name_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract package name string";
      "package_list_arch_regex"
      comment => "Regular expression with one backreference to extract package architecture string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_list_arch_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract package architecture string";
      "package_patch_list_command"
      comment => "Command to obtain a list of available patches or updates",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_patch_list_command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Command to obtain a list of available patches or updates";
      "package_patch_version_regex"
      comment => "Regular expression with one backreference to extract update version string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_patch_version_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract update version string";
      "package_patch_name_regex"
      comment => "Regular expression with one backreference to extract update name string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_patch_name_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract update name string";
      "package_patch_arch_regex"
      comment => "Regular expression with one backreference to extract update architecture string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_patch_arch_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract update architecture string";
      "package_patch_installed_regex"
      comment => "Regular expression which matches packages that are already installed",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_patch_installed_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression which matches packages that are already installed";
      "package_version_regex"
      comment => "Regular expression with one backreference to extract package version string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_version_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract package version string";
      "package_name_regex"
      comment => "Regular expression with one backreference to extract package name string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_name_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract package name string";
      "package_arch_regex"
      comment => "Regular expression with one backreference to extract package architecture string",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_arch_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression with one backreference to extract package architecture string";
      "package_installed_regex"
      comment => "Regular expression which matches packages that are already installed",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_installed_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression which matches packages that are already installed";
      "package_add_command"
      comment => "Command to install a package to the system",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_add_command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Command to install a package to the system";
      "package_delete_command"
      comment => "Command to remove a package from the system",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_delete_command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Command to remove a package from the system";
      "package_update_command"
      comment => "Command to update to the latest version a currently installed package",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_update_command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Command to update to the latest version a currently installed package";
      "package_patch_command"
      comment => "Command to update to the latest patch release of an installed package",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_patch_command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Command to update to the latest patch release of an installed package";
      "package_verify_command"
      comment => "Command to verify the correctness of an installed package",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_verify_command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Command to verify the correctness of an installed package";
      "package_noverify_regex"
      comment => "Regular expression to match verification failure output",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_noverify_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression to match verification failure output";
      "package_noverify_returncode"
      comment => "Integer return code indicating package verification failure",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_noverify_returncode" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Integer return code indicating package verification failure";
      "package_name_convention"
      comment => "This is how the package manager expects the file to be referred to, e.g. $(name).$(arch)",
      association => a("is a possible sub-body constraint for","package_method","may have sub-body constraints");
    body_constraints::
      "package_name_convention" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "This is how the package manager expects the file to be referred to, e.g. $(name).$(arch)";
    promise_types::
      "packages";
    body_constraints::
      "package_version"
      comment => "Version reference point for determining promised version",
      association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
    body_constraints::
      "package_version" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Version reference point for determining promised version";
    promise_types::
      "packages";
    body_constraints::
      "package_architectures"
      comment => "Select the architecture for package selection",
      association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
    body_constraints::
      "package_architectures" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "Select the architecture for package selection";
      "package_architectures" association => a("is a list of type","slist","is used in");
    promise_types::
      "packages";
    body_constraints::
      "package_select"
      comment => "A criterion for first acceptable match relative to \"package_version\"",
      association => a("is a possible body constraint for","promise_types::packages","can have body constraints");
    body_constraints::
      "package_select" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "A criterion for first acceptable match relative to \"package_version\"";
    promise_types::
      "processes";
    body_constraints::
      "signals"
      comment => "A list of menu options representing signals to be sent to a process",
      association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
    body_constraints::
      "signals" association => a("is a body constraint of type","(option list)","has possible body constraints"),
      comment => "A list of menu options representing signals to be sent to a process";
    promise_types::
      "processes";
    body_constraints::
      "process_stop"
      comment => "A command used to stop a running process",
      association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
    body_constraints::
      "process_stop" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "A command used to stop a running process";
    promise_types::
      "processes";
    body_constraints::
      "process_count"
      comment => "Criteria for constraining the number of processes matching other criteria",
      association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
      "match_range"
      comment => "Integer range for acceptable number of matches for this process",
      association => a("is a possible sub-body constraint for","process_count","may have sub-body constraints");
    body_constraints::
      "match_range" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Integer range for acceptable number of matches for this process";
      "in_range_define"
      comment => "List of classes to define if the matches are in range",
      association => a("is a possible sub-body constraint for","process_count","may have sub-body constraints");
    body_constraints::
      "in_range_define" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of classes to define if the matches are in range";
      "in_range_define" association => a("is a list of type","slist","is used in");
      "out_of_range_define"
      comment => "List of classes to define if the matches are out of range",
      association => a("is a possible sub-body constraint for","process_count","may have sub-body constraints");
    body_constraints::
      "out_of_range_define" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of classes to define if the matches are out of range";
      "out_of_range_define" association => a("is a list of type","slist","is used in");
    promise_types::
      "processes";
    body_constraints::
      "process_select"
      comment => "Criteria for matching processes in the system process table",
      association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
      "process_owner"
      comment => "List of regexes matching the user of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "process_owner" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of regexes matching the user of a process";
      "process_owner" association => a("is a list of type","slist","is used in");
      "pid"
      comment => "Range of integers matching the process id of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "pid" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the process id of a process";
      "ppid"
      comment => "Range of integers matching the parent process id of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "ppid" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the parent process id of a process";
      "pgid"
      comment => "Range of integers matching the parent group id of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "pgid" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the parent group id of a process";
      "rsize"
      comment => "Range of integers matching the resident memory size of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "rsize" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the resident memory size of a process";
      "vsize"
      comment => "Range of integers matching the virtual memory size of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "vsize" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the virtual memory size of a process";
      "status"
      comment => "Regular expression matching the status field of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "status" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression matching the status field of a process";
      "ttime_range"
      comment => "Range of integers matching the total elapsed time of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "ttime_range" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the total elapsed time of a process";
      "stime_range"
      comment => "Range of integers matching the start time of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "stime_range" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the start time of a process";
      "command"
      comment => "Regular expression matching the command/cmd field of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "command" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression matching the command/cmd field of a process";
      "tty"
      comment => "Regular expression matching the tty field of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "tty" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression matching the tty field of a process";
      "priority"
      comment => "Range of integers matching the priority field (PRI/NI) of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "priority" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the priority field (PRI/NI) of a process";
      "threads"
      comment => "Range of integers matching the threads (NLWP) field of a process",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "threads" association => a("is a body constraint of type","irange [int,int]","has possible body constraints"),
      comment => "Range of integers matching the threads (NLWP) field of a process";
      "process_result"
      comment => "Boolean class expression returning the logical combination of classes set by a process selection test",
      association => a("is a possible sub-body constraint for","process_select","may have sub-body constraints");
    body_constraints::
      "process_result" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Boolean class expression returning the logical combination of classes set by a process selection test";
    promise_types::
      "processes";
    body_constraints::
      "restart_class"
      comment => "A class to be set if the process is not running, so that a command: rule can be referred to restart the process",
      association => a("is a possible body constraint for","promise_types::processes","can have body constraints");
    body_constraints::
      "restart_class" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "A class to be set if the process is not running, so that a command: rule can be referred to restart the process";
    promise_types::
      "storage";
    body_constraints::
      "mount"
      comment => "Criteria for mounting foreign file systems",
      association => a("is a possible body constraint for","promise_types::storage","can have body constraints");
      "mount_type"
      comment => "Protocol type of remote file system",
      association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
    body_constraints::
      "mount_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Protocol type of remote file system";
      "mount_source"
      comment => "Path of remote file system to mount",
      association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
    body_constraints::
      "mount_source" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Path of remote file system to mount";
      "mount_server"
      comment => "Hostname or IP or remote file system server",
      association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
    body_constraints::
      "mount_server" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Hostname or IP or remote file system server";
      "mount_options"
      comment => "List of option strings to add to the file system table (\"fstab\")",
      association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
    body_constraints::
      "mount_options" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of option strings to add to the file system table (\"fstab\")";
      "mount_options" association => a("is a list of type","slist","is used in");
      "edit_fstab"
      comment => "true/false add or remove entries to the file system table (\"fstab\")",
      association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
    body_constraints::
      "edit_fstab" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false add or remove entries to the file system table (\"fstab\")";
      "unmount"
      comment => "true/false unmount a previously mounted filesystem",
      association => a("is a possible sub-body constraint for","mount","may have sub-body constraints");
    body_constraints::
      "unmount" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false unmount a previously mounted filesystem";
    promise_types::
      "storage";
    body_constraints::
      "volume"
      comment => "Criteria for monitoring/probing mounted volumes",
      association => a("is a possible body constraint for","promise_types::storage","can have body constraints");
      "check_foreign"
      comment => "true/false verify storage that is mounted from a foreign system on this host",
      association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
    body_constraints::
      "check_foreign" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false verify storage that is mounted from a foreign system on this host";
      "freespace"
      comment => "Absolute or percentage minimum disk space that should be available before warning",
      association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
    body_constraints::
      "freespace" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Absolute or percentage minimum disk space that should be available before warning";
      "sensible_size"
      comment => "Minimum size in bytes that should be used on a sensible-looking storage device",
      association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
    body_constraints::
      "sensible_size" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Minimum size in bytes that should be used on a sensible-looking storage device";
      "sensible_count"
      comment => "Minimum number of files that should be defined on a sensible-looking storage device",
      association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
    body_constraints::
      "sensible_count" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Minimum number of files that should be defined on a sensible-looking storage device";
      "scan_arrivals"
      comment => "true/false generate pseudo-periodic disk change arrival distribution",
      association => a("is a possible sub-body constraint for","volume","may have sub-body constraints");
    body_constraints::
      "scan_arrivals" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false generate pseudo-periodic disk change arrival distribution";
    promise_types::
      "access";
    body_constraints::
      "admit"
      comment => "List of host names or IP addresses to grant access to file objects",
      association => a("is a possible body constraint for","promise_types::access","can have body constraints");
    body_constraints::
      "admit" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of host names or IP addresses to grant access to file objects";
      "admit" association => a("is a list of type","slist","is used in");
    promise_types::
      "access";
    body_constraints::
      "deny"
      comment => "List of host names or IP addresses to deny access to file objects",
      association => a("is a possible body constraint for","promise_types::access","can have body constraints");
    body_constraints::
      "deny" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of host names or IP addresses to deny access to file objects";
      "deny" association => a("is a list of type","slist","is used in");
    promise_types::
      "access";
    body_constraints::
      "maproot"
      comment => "List of host names or IP addresses to grant full read-privilege on the server",
      association => a("is a possible body constraint for","promise_types::access","can have body constraints");
    body_constraints::
      "maproot" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of host names or IP addresses to grant full read-privilege on the server";
      "maproot" association => a("is a list of type","slist","is used in");
    promise_types::
      "access";
    body_constraints::
      "ifencrypted"
      comment => "true/false whether the current file access promise is conditional on the connection from the client being encrypted",
      association => a("is a possible body constraint for","promise_types::access","can have body constraints");
    body_constraints::
      "ifencrypted" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "true/false whether the current file access promise is conditional on the connection from the client being encrypted";
    promise_types::
      "access";
    body_constraints::
      "resource_type"
      comment => "The type of object being granted access. The default is access to files.",
      association => a("is a possible body constraint for","promise_types::access","can have body constraints");
    body_constraints::
      "resource_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The type of object being granted access. The default is access to files.";
    promise_types::
      "roles";
    body_constraints::
      "authorize"
      comment => "List of public-key user names that are allowed to activate the promised class during remote agent activation",
      association => a("is a possible body constraint for","promise_types::roles","can have body constraints");
    body_constraints::
      "authorize" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of public-key user names that are allowed to activate the promised class during remote agent activation";
      "authorize" association => a("is a list of type","slist","is used in");
    promise_types::
      "topics";
    body_constraints::
      "association"
      comment => "Declare associated topics",
      association => a("is a possible body constraint for","promise_types::topics","can have body constraints");
      "forward_relationship"
      comment => "Name of forward association between promiser topic and associates",
      association => a("is a possible sub-body constraint for","association","may have sub-body constraints");
    body_constraints::
      "forward_relationship" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Name of forward association between promiser topic and associates";
      "backward_relationship"
      comment => "Name of backward/inverse association from associates to promiser topic",
      association => a("is a possible sub-body constraint for","association","may have sub-body constraints");
    body_constraints::
      "backward_relationship" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Name of backward/inverse association from associates to promiser topic";
      "associates"
      comment => "List of associated topics by this forward relationship",
      association => a("is a possible sub-body constraint for","association","may have sub-body constraints");
    body_constraints::
      "associates" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of associated topics by this forward relationship";
      "associates" association => a("is a list of type","slist","is used in");
    promise_types::
      "topics";
    body_constraints::
      "comment"
      comment => "Retained comment about this promise's real intention",
      association => a("is a possible body constraint for","promise_types::topics","can have body constraints");
    body_constraints::
      "comment" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Retained comment about this promise's real intention";
    promise_types::
      "occurrences";
    body_constraints::
      "represents"
      comment => "List of subtopics that explains the type(s) of information represented by the occurrence",
      association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
    body_constraints::
      "represents" association => a("is a body constraint of type","slist","has possible body constraints"),
      comment => "List of subtopics that explains the type(s) of information represented by the occurrence";
      "represents" association => a("is a list of type","slist","is used in");
    promise_types::
      "occurrences";
    body_constraints::
      "representation"
      comment => "How to interpret the promiser string e.g. actual data or reference to data",
      association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
    body_constraints::
      "representation" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "How to interpret the promiser string e.g. actual data or reference to data";
    promise_types::
      "occurrences";
    body_constraints::
      "web_root"
      comment => "Base URL of the occurrence when rendered as a web-URL (replaces path_root)",
      association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
    body_constraints::
      "web_root" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Base URL of the occurrence when rendered as a web-URL (replaces path_root)";
    promise_types::
      "occurrences";
    body_constraints::
      "path_root"
      comment => "Base path of the occurrence when locating file (replaced by web_root)",
      association => a("is a possible body constraint for","promise_types::occurrences","can have body constraints");
    body_constraints::
      "path_root" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Base path of the occurrence when locating file (replaced by web_root)";
    promise_types::
      "measurements";
    body_constraints::
      "stream_type"
      comment => "The datatype being collected.",
      association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
    body_constraints::
      "stream_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The datatype being collected.";
    promise_types::
      "measurements";
    body_constraints::
      "data_type"
      comment => "The datatype being collected.",
      association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
    body_constraints::
      "data_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "The datatype being collected.";
    promise_types::
      "measurements";
    body_constraints::
      "history_type"
      comment => "Whether the data can be seen as a time-series or just an isolated value",
      association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
    body_constraints::
      "history_type" association => a("is a body constraint of type","(menu option)","has possible body constraints"),
      comment => "Whether the data can be seen as a time-series or just an isolated value";
    promise_types::
      "measurements";
    body_constraints::
      "units"
      comment => "The engineering dimensions of this value or a note about its intent used in plots",
      association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
    body_constraints::
      "units" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "The engineering dimensions of this value or a note about its intent used in plots";
    promise_types::
      "measurements";
    body_constraints::
      "match_value"
      comment => "Criteria for extracting the measurement from a datastream",
      association => a("is a possible body constraint for","promise_types::measurements","can have body constraints");
      "select_line_matching"
      comment => "Regular expression for matching line location",
      association => a("is a possible sub-body constraint for","match_value","may have sub-body constraints");
    body_constraints::
      "select_line_matching" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression for matching line location";
      "select_line_number"
      comment => "Read from the n-th line of the output (fixed format)",
      association => a("is a possible sub-body constraint for","match_value","may have sub-body constraints");
    body_constraints::
      "select_line_number" association => a("is a body constraint of type","int","has possible body constraints"),
      comment => "Read from the n-th line of the output (fixed format)";
      "extraction_regex"
      comment => "Regular expression that should contain a single backreference for extracting a value",
      association => a("is a possible sub-body constraint for","match_value","may have sub-body constraints");
    body_constraints::
      "extraction_regex" association => a("is a body constraint of type","string","has possible body constraints"),
      comment => "Regular expression that should contain a single backreference for extracting a value";
      "action";
      "classes";
      "ifvarclass";
      "handle";
      "depends_on";
      "comment";
      "select_region";
    functions::

      "accessedbefore"     comment => "True if arg1 was accessed before arg2 (atime)",
      association => a("returns data-type","class","is returned by function");
      "accumulated"     comment => "Convert an accumulated amount of time into a system representation",
      association => a("returns data-type","int","is returned by function");
      "ago"     comment => "Convert a time relative to now to an integer system representation",
      association => a("returns data-type","int","is returned by function");
      "canonify"     comment => "Convert an abitrary string into a legal class name",
      association => a("returns data-type","string","is returned by function");
      "changedbefore"     comment => "True if arg1 was changed before arg2 (ctime)",
      association => a("returns data-type","class","is returned by function");
      "classify"     comment => "True if the canonicalization of the argument is a currently defined class",
      association => a("returns data-type","class","is returned by function");
      "classmatch"     comment => "True if the regular expression matches any currently defined class",
      association => a("returns data-type","class","is returned by function");
      "execresult"     comment => "Execute named command and assign output to variable",
      association => a("returns data-type","string","is returned by function");
      "fileexists"     comment => "True if the named file can be accessed",
      association => a("returns data-type","class","is returned by function");
      "filesexist"     comment => "True if the named list of files can ALL be accessed",
      association => a("returns data-type","class","is returned by function");
      "getindices"     comment => "Get a list of keys to the array whose id is the argument and assign to variable",
      association => a("returns data-type","slist","is returned by function");
      "getgid"     comment => "Return the integer group id of the named group on this host",
      association => a("returns data-type","int","is returned by function");
      "getuid"     comment => "Return the integer user id of the named user on this host",
      association => a("returns data-type","int","is returned by function");
      "groupexists"     comment => "True if group or numerical id exists on this host",
      association => a("returns data-type","class","is returned by function");
      "hash"     comment => "Return the hash of arg1, type arg2 and assign to a variable",
      association => a("returns data-type","string","is returned by function");
      "hashmatch"     comment => "Compute the hash of arg1, of type arg2 and test if it matches the value in arg 3",
      association => a("returns data-type","class","is returned by function");
      "hostrange"     comment => "True if the current host lies in the range of enumerated hostnames specified",
      association => a("returns data-type","class","is returned by function");
      "hostinnetgroup"     comment => "True if the current host is in the named netgroup",
      association => a("returns data-type","class","is returned by function");
      "iprange"     comment => "True if the current host lies in the range of IP addresses specified",
      association => a("returns data-type","class","is returned by function");
      "irange"     comment => "Define a range of integer values for cfengine internal use",
      association => a("returns data-type","irange [int,int]","is returned by function");
      "isdir"     comment => "True if the named object is a directory",
      association => a("returns data-type","class","is returned by function");
      "isgreaterthan"     comment => "True if arg1 is numerically greater than arg2, else compare strings like strcmp",
      association => a("returns data-type","class","is returned by function");
      "islessthan"     comment => "True if arg1 is numerically less than arg2, else compare strings like NOT strcmp",
      association => a("returns data-type","class","is returned by function");
      "islink"     comment => "True if the named object is a symbolic link",
      association => a("returns data-type","class","is returned by function");
      "isnewerthan"     comment => "True if arg1 is newer (modified later) than arg2 (mtime)",
      association => a("returns data-type","class","is returned by function");
      "isplain"     comment => "True if the named object is a plain/regular file",
      association => a("returns data-type","class","is returned by function");
      "isvariable"     comment => "True if the named variable is defined",
      association => a("returns data-type","class","is returned by function");
      "lastnode"     comment => "Extract the last of a separated string, e.g. filename from a path",
      association => a("returns data-type","string","is returned by function");
      "ldaparray"     comment => "Extract all values from an ldap record",
      association => a("returns data-type","class","is returned by function");
      "ldaplist"     comment => "Extract all named values from multiple ldap records",
      association => a("returns data-type","slist","is returned by function");
      "ldapvalue"     comment => "Extract the first matching named value from ldap",
      association => a("returns data-type","string","is returned by function");
      "now"     comment => "Convert the current time into system representation",
      association => a("returns data-type","int","is returned by function");
      "on"     comment => "Convert an exact date/time to an integer system representation",
      association => a("returns data-type","int","is returned by function");
      "peers"     comment => "Get a list of peers (not including ourself) from the partition to which we belong",
      association => a("returns data-type","slist","is returned by function");
      "peerleader"     comment => "Get the assigned peer-leader of the partition to which we belong",
      association => a("returns data-type","string","is returned by function");
      "peerleaders"     comment => "Get a list of peer leaders from the named partitioning",
      association => a("returns data-type","slist","is returned by function");
      "randomint"     comment => "Generate a random integer between the given limits",
      association => a("returns data-type","int","is returned by function");
      "readfile"     comment => "Read max number of bytes from named file and assign to variable",
      association => a("returns data-type","string","is returned by function");
      "readintarray"     comment => "Read an array of integers from a file and assign the dimension to a variable",
      association => a("returns data-type","int","is returned by function");
      "readintlist"     comment => "Read and assign a list variable from a file of separated ints",
      association => a("returns data-type","ilist","is returned by function");
      "readrealarray"     comment => "Read an array of real numbers from a file and assign the dimension to a variable",
      association => a("returns data-type","int","is returned by function");
      "readreallist"     comment => "Read and assign a list variable from a file of separated real numbers",
      association => a("returns data-type","rlist","is returned by function");
      "readstringarray"     comment => "Read an array of strings from a file and assign the dimension to a variable",
      association => a("returns data-type","int","is returned by function");
      "readstringlist"     comment => "Read and assign a list variable from a file of separated strings",
      association => a("returns data-type","slist","is returned by function");
      "readtcp"     comment => "Connect to tcp port, send string and assign result to variable",
      association => a("returns data-type","string","is returned by function");
      "regarray"     comment => "True if arg1 matches any item in the associative array with id=arg2",
      association => a("returns data-type","class","is returned by function");
      "regcmp"     comment => "True if arg2 is a regular expression matching arg1",
      association => a("returns data-type","class","is returned by function");
      "registryvalue"     comment => "Returns a value for an MS-Win registry key,value pair",
      association => a("returns data-type","string","is returned by function");
      "regline"     comment => "True if arg2 is a regular expression matching a line in file arg1",
      association => a("returns data-type","class","is returned by function");
      "reglist"     comment => "True if arg2 matches any item in the list with id=arg1",
      association => a("returns data-type","class","is returned by function");
      "regldap"     comment => "True if arg6 is a regular expression matching a value item in an ldap search",
      association => a("returns data-type","class","is returned by function");
      "remotescalar"     comment => "Read a scalar value from a remote cfengine server",
      association => a("returns data-type","string","is returned by function");
      "returnszero"     comment => "True if named shell command has exit status zero",
      association => a("returns data-type","class","is returned by function");
      "rrange"     comment => "Define a range of real numbers for cfengine internal use",
      association => a("returns data-type","rrange [real,real]","is returned by function");
      "selectservers"     comment => "Select tcp servers which respond correctly to a query and return their number, set array of names",
      association => a("returns data-type","int","is returned by function");
      "splayclass"     comment => "True if the first argument's time-slot has arrived, according to a policy in arg2",
      association => a("returns data-type","class","is returned by function");
      "splitstring"     comment => "Convert a string in arg1 into a list of max arg3 strings by splitting on a regular expression in arg2",
      association => a("returns data-type","slist","is returned by function");
      "strcmp"     comment => "True if the two strings match exactly",
      association => a("returns data-type","class","is returned by function");
      "usemodule"     comment => "Execute cfengine module script and set class if successful",
      association => a("returns data-type","class","is returned by function");
      "userexists"     comment => "True if user name or numerical id exists on this host",
      association => a("returns data-type","class","is returned by function");

  topics:

    bundles::
      "update";
    contexts::
      "any";
    promisers::

      "master_location"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
      "master_location"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
      "master_location"
      association => a("makes promises","promise_unit_update_cf_13","is a promise made by");
    promise_types::
      "vars" association => a("is employed in bundle","update","employs promises of type");
    promises::

      "promise_unit_update_cf_13"
      comment => "(Uncommented promise of type <i>vars</i> made by: master_location..)";
      "promise_unit_update_cf_13" association => a("is activated by class context","any","activates promises");
      "promise_unit_update_cf_13" association => a("is a promise of type","vars","has current exemplars");

  occurrences:
    promise_unit_update_cf_13::
      "promises.cf.html#promise_unit_update_cf_13"
      comment => "A promise of type vars made by: master_location",
      represents => { "any", "vars" };

    any::
      "promises.cf.html#promise_unit_update_cf_13"
      represents => { "promise", "master_location", "vars" };

    update::
      "promises.cf.html#bundle_update"
      represents => { "bundle reference" };

    string::
      "promises.cf.html#promise_unit_update_cf_13"
      represents => { "used in promise", "promise_unit_update_cf_13" };


  topics:

    bundles::
      "update";
    contexts::
      "any";
    promisers::

      "pservers"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
      "pservers"
      association => a("makes promise of type","promise_types::vars","promises have been made by");
      "pservers"
      association => a("makes promises","promise_unit_update_cf_15","is a promise made by");
    promise_types::
      "vars" association => a("is employed in bundle","update","employs promises of type");
    promises::

      "promise_unit_update_cf_15"
      comment => "IP address to locate your policy host.";
      "promise_unit_update_cf_15" association => a("is activated by class context","any","activates promises");
      "promise_unit_update_cf_15" association => a("is a promise of type","vars","has current exemplars");

  occurrences:
    promise_unit_update_cf_15::
      "promises.cf.html#promise_unit_update_cf_15"
      comment => "IP address to locate your policy host.",
      represents => { "any", "vars" };

    any::
      "promises.cf.html#promise_unit_update_cf_15"
      represents => { "promise", "pservers", "vars" };

    update::
      "promises.cf.html#bundle_update"
      represents => { "bundle reference" };

    int::
      "promises.cf.html#promise_unit_update_cf_15"
      represents => { "used in promise", "promise_unit_update_cf_15" };

    comment::
      "promises.cf.html#promise_unit_update_cf_15"
      represents => { "used in promise", "promise_unit_update_cf_15" };

      "IP address to locate your policy host."
      representation => "literal",

      represents => { "promise_unit_update_cf_15" };
    promise_unit_update_cf_15::
      "IP address to locate your policy host."
      representation => "literal",

      represents => { "comment" };

  topics:

    bundles::
      "update";
    contexts::
      "!have_ppkeys";
    promisers::

      "/var/cfengine/bin/cf-key"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
      "/var/cfengine/bin/cf-key"
      association => a("makes promise of type","promise_types::commands","promises have been made by");
      "/var/cfengine/bin/cf-key"
      association => a("makes promises","promise_unit_update_cf_31","is a promise made by");
    promise_types::
      "commands" association => a("is employed in bundle","update","employs promises of type");
    promises::

      "promise_unit_update_cf_31"
      comment => "(Uncommented promise of type <i>commands</i> made by: /var/cfengine/bin/cf-key..)";
      "promise_unit_update_cf_31" association => a("is activated by class context","!have_ppkeys","activates promises");
      "promise_unit_update_cf_31" association => a("is a promise of type","commands","has current exemplars");

  occurrences:
    promise_unit_update_cf_31::
      "promises.cf.html#promise_unit_update_cf_31"
      comment => "A promise of type commands made by: /var/cfengine/bin/cf-key",
      represents => { "!have_ppkeys", "commands" };

    _have_ppkeys::
      "promises.cf.html#promise_unit_update_cf_31"
      represents => { "promise", "/var/cfengine/bin/cf-key", "commands" };

    update::
      "promises.cf.html#bundle_update"
      represents => { "bundle reference" };


  topics:

    bundles::
      "update";
    contexts::
      "xx";
    promisers::

      "/var/cfengine/inputs"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
      "/var/cfengine/inputs"
      association => a("makes promise of type","promise_types::files","promises have been made by");
      "/var/cfengine/inputs"
      association => a("makes promises","update_policy","is a promise made by");
    promise_types::
      "files" association => a("is employed in bundle","update","employs promises of type");
    promises::

      "update_policy"
      comment => "(Uncommented promise of type <i>files</i> made by: /var/cfengine/inputs..)";
      "update_policy" association => a("is activated by class context","xx","activates promises");
      "update_policy" association => a("is a promise of type","files","has current exemplars");

  occurrences:
    update_policy::
      "promises.cf.html#update_policy"
      comment => "A promise of type files made by: /var/cfengine/inputs",
      represents => { "xx", "files" };

    xx::
      "promises.cf.html#update_policy"
      represents => { "promise", "/var/cfengine/inputs", "files" };

    update::
      "promises.cf.html#bundle_update"
      represents => { "bundle reference" };

    handle::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    perms::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    mode::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    copy_from::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    source::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    compare::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    trustkey::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    servers::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    depth_search::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    depth::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    action::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };

    ifelapsed::
      "promises.cf.html#update_policy"
      represents => { "used in promise", "update_policy" };


  topics:

    bundles::
      "update";
    contexts::
      "xx";
    promisers::

      "/var/cfengine/bin"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
      "/var/cfengine/bin"
      association => a("makes promise of type","promise_types::files","promises have been made by");
      "/var/cfengine/bin"
      association => a("makes promises","promise_unit_update_cf_47","is a promise made by");
    promise_types::
      "files" association => a("is employed in bundle","update","employs promises of type");
    promises::

      "promise_unit_update_cf_47"
      comment => "(Uncommented promise of type <i>files</i> made by: /var/cfengine/bin..)";
      "promise_unit_update_cf_47" association => a("is activated by class context","xx","activates promises");
      "promise_unit_update_cf_47" association => a("is a promise of type","files","has current exemplars");

  occurrences:
    promise_unit_update_cf_47::
      "promises.cf.html#promise_unit_update_cf_47"
      comment => "A promise of type files made by: /var/cfengine/bin",
      represents => { "xx", "files" };

    xx::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "promise", "/var/cfengine/bin", "files" };

    update::
      "promises.cf.html#bundle_update"
      represents => { "bundle reference" };

    perms::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    mode::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    copy_from::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    source::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    compare::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    trustkey::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    servers::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    depth_search::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    depth::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    action::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };

    ifelapsed::
      "promises.cf.html#promise_unit_update_cf_47"
      represents => { "used in promise", "promise_unit_update_cf_47" };


  topics:

    bundles::
      "update";
    contexts::
      "any|bootstrap_mode.policy_host";
    promisers::

      "I am the policy host - i.e. with ipv4 address $(policy_server[0])"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
      "I am the policy host - i.e. with ipv4 address $(policy_server[0])"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
      "I am the policy host - i.e. with ipv4 address $(policy_server[0])"
      association => a("makes promises","promise_unit_update_cf_56","is a promise made by");
    promise_types::
      "reports" association => a("is employed in bundle","update","employs promises of type");
    promises::

      "promise_unit_update_cf_56"
      comment => "(Uncommented promise of type <i>reports</i> made by: I am the policy host - i...)";
      "promise_unit_update_cf_56" association => a("is activated by class context","any|bootstrap_mode.policy_host","activates promises");
      "promise_unit_update_cf_56" association => a("is a promise of type","reports","has current exemplars");

  occurrences:
    promise_unit_update_cf_56::
      "promises.cf.html#promise_unit_update_cf_56"
      comment => "A promise of type reports made by: I am the policy host - i.e. with ipv4 address $(policy_server[0])",
      represents => { "any|bootstrap_mode.policy_host", "reports" };

    any_bootstrap_mode_policy_host::
      "promises.cf.html#promise_unit_update_cf_56"
      represents => { "promise", "I am the policy host - i.e. with ipv4 address $(policy_server[0])", "reports" };

    update::
      "promises.cf.html#bundle_update"
      represents => { "bundle reference" };


  topics:

    bundles::
      "update";
    contexts::
      "nofile";
    promisers::

      "found file"
      association => a("occurs in bundle","bundles::update","bundle contains promiser");
      "found file"
      association => a("makes promise of type","promise_types::reports","promises have been made by");
      "found file"
      association => a("makes promises","promise_unit_update_cf_60","is a promise made by");
    promise_types::
      "reports" association => a("is employed in bundle","update","employs promises of type");
    promises::

      "promise_unit_update_cf_60"
      comment => "(Uncommented promise of type <i>reports</i> made by: found file..)";
      "promise_unit_update_cf_60" association => a("is activated by class context","nofile","activates promises");
      "promise_unit_update_cf_60" association => a("is a promise of type","reports","has current exemplars");

  occurrences:
    promise_unit_update_cf_60::
      "promises.cf.html#promise_unit_update_cf_60"
      comment => "A promise of type reports made by: found file",
      represents => { "nofile", "reports" };

    nofile::
      "promises.cf.html#promise_unit_update_cf_60"
      represents => { "promise", "found file", "reports" };

    update::
      "promises.cf.html#bundle_update"
      represents => { "bundle reference" };

}
