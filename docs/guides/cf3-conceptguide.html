<html lang="en">
<head>
<title>CFEngine 3 Concept Guide</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="CFEngine 3 Concept Guide">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {
	font-family: Verdana, DejaVu, Vera, Geneva, sans-serif;
	padding: 10px;
}
.node
{
	text-align: right;
	padding: 2px;
	font-size: smaller;
}
.node hr {
	border: 0;
	width: 100%;
	color: #CCC;
	background-color: #CCC;
	height: 5px;
}
.section {
	padding-right: 0px;
	padding-bottom: 0px;
	padding-left: 0px;
}
h1 {
	font-weight: bold;
	color: #666;
}
h2 {
	font-weight: bold;
	color: #666;
}
h3 {
	margin-top: 3px;
	margin-right: 0px;
	margin-bottom: 10px;
	margin-left: 0px;
}

.menu
{
}

.contents
{
	background-color: #CCC;
	padding-top: 2px;
	padding-right: 2px;
	padding-bottom: 2px;
	padding-left: 10px;
}

.index-cp
{  
background: #fff url(index-cp.png) right repeat-y;
}

.index-vr
{  
background: #fff url(index-vr.png) right repeat-y;
}

.index-mb
{  
background: #eee url(index-faq.png) right repeat-y;
}

table.border
{
	border-color: #666;
	border-width: 0px;
}

FONT.liten {font-size: 70%; }
 
.tynn {
        font-family: Arial, Helvetica, sans-serif;
        font-size: smaller;
        font-style: normal;
        font-weight: lighter;
        margin-bottom: 0em;
     font-size: 11pt;
        }
.verbatim {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.example {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	width: 100%;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.smallexample {
	font-family: "Lucida Console", Monaco, monospace;
	color: #000;
	width: 100%;
	padding-top: 30px;
	padding-right: 30px;
	padding-bottom: 3px;
	padding-left: 30px;
	background-color: #FEFFCA;
	border-left-width: medium;
	border-left-style: outset;
	border-left-color: #FDFFD5;
	margin-top: 0px;
	margin-right: 0px;
	margin-bottom: 20px;
	margin-left: 0px;
}
.cartouche {
	background-color: #CCC;
	border-top-style: none;
	border-right-style: none;
	border-bottom-style: none;
	border-left-style: none;
	padding: 5px;
	font-style: italic;
}

A:link { color: #2c2e70 }
A:visited { color: black }
A:active { color: #600041 }--></style>
</head>
<body>
<h1 class="settitle">CFEngine 3 Concept Guide</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction-_002d-System-automation">Introduction - System automation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">CFEngine-GetStarted</h2>

   <p><a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>

<!-- ********************************************************************** -->
<!-- CHAPTER -->
<!-- ********************************************************************** -->
   <p><i>This document is an abreviated version of the CFEngine tutorial (http://cfengine.com/manuals/cf3-tutorial.html).</i>

<!-- ********************************************************************** -->
<ul class="menu">
<li><a accesskey="1" href="#Introduction-_002d-System-automation">Introduction - System automation</a>
<li><a accesskey="2" href="#The-components-of-CFEngine">The components of CFEngine</a>
<li><a accesskey="3" href="#Bodies-and-bundles">Bodies and bundles</a>
<li><a accesskey="4" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>
<li><a accesskey="5" href="#Knowledge-Management">Knowledge Management</a>
</ul>

<div class="node">
<a name="Introduction---System-automation"></a>
<a name="Introduction-_002d-System-automation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-components-of-CFEngine">The components of CFEngine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction - System automation</h2>

<ul class="menu">
<li><a accesskey="1" href="#Managing-diverse-and-challenging-environments-seamlessly-and-invisibly">Managing diverse and challenging environments seamlessly and invisibly</a>
<li><a accesskey="2" href="#Managing-expectations-_002d-a-theory-of-promises">Managing expectations - a theory of promises</a>
<li><a accesskey="3" href="#Why-automation_003f">Why automation?</a>
<li><a accesskey="4" href="#How-do-you-view-CFEngine">How do you view CFEngine</a>
</ul>

<div class="node">
<a name="Managing-diverse-and-challenging-environments-seamlessly-and-invisibly"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Managing-expectations-_002d-a-theory-of-promises">Managing expectations - a theory of promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-_002d-System-automation">Introduction - System automation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-_002d-System-automation">Introduction - System automation</a>

</div>

<h3 class="section">1.1 Managing diverse and challenging environments seamlessly and invisibly</h3>

<p>CFEngine was designed to enable scalable configuration management, for
the
whole system life-cycle, in any kind of environment. 
Almost every other system for configuration assumes that there will be
a reliable network in place and that changes will be pushed out
top-down from an authoritative node. Those systems are useless in
environments like

     <ul>
<li>Mobile systems with partial or unreliable connectivity (e.g. a
submarine). 
<li>Systems where bandwidths are very low (e.g. a satellite or space
probe). 
<li>Systems where computing power is very low (e.g. ad hoc sensors
or kitchen appliances). 
</ul>

   <p>CFEngine does not need reliable infrastructure. It works
opportunistically in almost any environment, using few resources. It
has few software dependencies.  So, not only does it work in all of the
traditional fixed-plan scenarios, but it is capable of working in
totally ad hoc deployment: an temporary incident room, a submarine
drifting on and off line, a satellite or a robot explorer.

   <p>One could argue `well I don't need that kind of system, because my
network is reliable'. However, your network is not as reliable as you
think, and mobility is an increasingly important topic. Even with a
very strong redundant network, the services that support the network
can be paralyzed by any of a number of failed dependencies or
mishaps. It is crucial in a modern pervasive environment that systems
remain available, fault tolerant and as far as possible independent of
external requirements. This is how to build scalable and reliable
services.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
CFEngine works in all the places you think it should, and all the new
places you haven't even thought of yet. How do we know? Because it
is based on almost 20 years of careful research and experience. 
</td></tr></table>

<!--  -->
<div class="node">
<a name="Managing-expectations---a-theory-of-promises"></a>
<a name="Managing-expectations-_002d-a-theory-of-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-automation_003f">Why automation?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Managing-diverse-and-challenging-environments-seamlessly-and-invisibly">Managing diverse and challenging environments seamlessly and invisibly</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-_002d-System-automation">Introduction - System automation</a>

</div>

<h3 class="section">1.2 Managing expectations - a theory of promises</h3>

<p>One of the hardest things in management is to make everyone aware of
their roles and tasks, and to be able to rely on others to do the same. 
<i>Trust</i> is an economic time-saver. If you can't trust you have to
verify,
and that is expensive.

   <p>To improve trust we make promises. A promise is the documentation of an
intention to act or behave in some manner. This is what we need to
learn to
trust systems, no matter whether they are machines or humans.

   <p>One CFEngine user once said to me, that the thing that had helped him
the most in deploying CFEngine was its design based around voluntary
cooperation. &ldquo;Our main problems were not technical but political &ndash;
getting everyone to agree in all of our departments around the
world&rdquo;.  This was because, for all the technology, it is people who
make the decisions and people need to feel that the system is
empowering rather than disempowering them.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>

   <p>CFEngine works on a simple notion of promises. Everything in
CFEngine can be thought of as a promise to be kept by different
resources in the system.

   <p>Combining promises with patterns to describe where and when
promises should apply is what CFEngine is all about.

   </td></tr></table>

<!--  -->
<div class="node">
<a name="Why-automation%3f"></a>
<a name="Why-automation_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-you-view-CFEngine">How do you view CFEngine</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Managing-expectations-_002d-a-theory-of-promises">Managing expectations - a theory of promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-_002d-System-automation">Introduction - System automation</a>

</div>

<h3 class="section">1.3 Why automation?</h3>

<p>Humans are good at making decisions and awful at reliable
implementation.  Machines are pitiful at making decisions and very
good at reliable implementation. It makes sense to let each side do
the job that they are good at.

   <p>The main problem in managing systems is a loss of self-discipline. 
Discipline
does not imply that order have to be barked from a central command. It
only requires that every part of the system knows its job and carries
is out seamlessly and flawlessly.

   <p>Skilled workers tend to think that it is enough to be smart. In fact
this is wrong: smart people tend to be problem solvers and will
happily solve the same problem many times, wasting time and
effort. Moreover, human intervention is often based on panic and lack
of understanding so every time someone logs onto a system by hand,
they jeopardize everyone's understanding of the system.  Only the
self-discipline of stable procedures leads to predictability.

   <p>Ad hoc changes are bad because:
     <ul>
<li>Others have no idea what happened. 
<li>There is no record of changes or intentions. 
<li>A scar is left from the change. 
</ul>

   <p>People often rile against automation saying that it dehumanizes their
work.  In fact the opposite is true: forcing humans to do the work of
machines, in repetitive and reliable ways is what dehumanizes people. 
The only way to make progress with a bad habit is to recognize it and
be willing to abandon the habit.

<!--  -->
<div class="node">
<a name="How-do-you-view-CFEngine"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-automation_003f">Why automation?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-_002d-System-automation">Introduction - System automation</a>

</div>

<h3 class="section">1.4 How do <i>you</i> view CFEngine?</h3>

<p>CFEngine is a framework. It is not so complex, but it is certainly
extensive. 
Often when trying to describe CFEngine, it seems that there is too
much to
tell and it is hard to convey in a simple way what the software can do. 
The picture below shows a few ways in which you can think of CFEngine.

<div align="center"><img src="boxes.png" alt="CFEngine application areas"></div>

   <p>For many users, CFEngine is simply a configuration tool &ndash;
i.e. software for deploying and patching systems according to a
policy. Policy is described using promises &ndash; indeed, every statement
in CFEngine 3 is a promise to be kept at some time or location.  More
than this, however, CFEngine is not like most automation tools that
`roll out' an image of some software once and hope for the best. Every
promise that you make in CFEngine is continuously verified and
maintained. It is not a one-off operation, but an encapsulated process
that repairs itself should anything deviate from the policy.

   <p>That clearly places CFEngine in the realm of automation, which often
begs the question: so it's just another scripting language? Certainly
CFEngine contains a powerful scripting language, but it is not like
any other. CFEngine is not a low level language like Perl, Python or
Ruby; it is a language of promises, in which you express very high
level intentions about the system and the inner details figure out the
algorithms needed to implement the result.

   <p>Above all, CFEngine is aimed to promote human understanding of complex
processes. Its promises are easily documentable using comments that
the system remembers and reminds us about in error reporting. It hides
irrelevant and transitory details of implementation so that the
<i>intentions</i> behind the promises are highlighted for all to see. 
This means that the knowledge of your organization can be encoded into
the CFEngine language.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<i>WHY DOES KNOWLEDGE MATTER? 1. Technical descriptions are hard to remember. You might understand
your configuration decisions when you are writing them, but a few
months later when something goes wrong, you will probably have forgotten
what you were thinking. That costs you time and effort to diagnose. 
2. Organizations are fragile to the loss
of those individuals who code policy. If they leave, often there is
no one left who can understand or fix the system. Only with proper
documentation is it possible to immunize against loss.</i>
</td></tr></table>

<!-- ***************************************************** -->
<!-- * CHAPTER -->
<!-- ***************************************************** -->
<div class="node">
<a name="The-components-of-CFEngine"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bodies-and-bundles">Bodies and bundles</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-_002d-System-automation">Introduction - System automation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 The components of CFEngine</h2>

<p>CFEngine comprises a number of components. In this chapter we'll
consider how to
build them and what they are for.

<ul class="menu">
<li><a accesskey="1" href="#The-players">The players</a>
<li><a accesskey="2" href="#About-the-CFEngine-architecture">About the CFEngine architecture</a>
<li><a accesskey="3" href="#The-policy-decision-flow">The policy decision flow</a>
</ul>

<div class="node">
<a name="The-players"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#About-the-CFEngine-architecture">About the CFEngine architecture</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-components-of-CFEngine">The components of CFEngine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-components-of-CFEngine">The components of CFEngine</a>

</div>

<h3 class="section">2.1 The players</h3>

<p>A CFEngine system is something like an orchestra. 
It is composed of any number of computers (players), each of which has
its
own copy of the music and knows what to play. It might or might not have
a conductor to help coordinate the individual parts &ndash; that's up to you.

   <p>CFEngine's software agents run on each individual computer but can
communicate if they need to, as depicted the figure below. This means
you don't have to arrange risky login credentials to run your network
&ndash; and if something goes wrong with the communications network,
CFEngine is where it needs to be to repair or protect the system
during the outage.

   <div class="block-image"><img src="components.png" alt="CFEngine components"></div>

   <p>If the network is not working, CFEngine just skips these parts and
continues
with what it can do. It is fault tolerant and opportunistic.

     <dl>
<dt><em>cf-promises</em><dd>The promise verifier and compiler. This is used to pre-check a set of
configuration promises before attempting to execute.

     <br><dt><em>cf-agent</em><dd>
This is the instigator of change. The agent is the part of CFEngine
that manipulates
system resources.

     <br><dt><em>cf-serverd</em><dd>
The server is able to share files and receive requests to execute
existing policy on an individual machine. It is not possible to send
(push) new information to CFEngine from outside.

     <br><dt><em>cf-execd</em><dd>
This is a scheduling daemon (which can either supplement or replace
<code>cron</code>). It also works as a wrapper, executing and collecting the
output of <code>cf-agent</code> and E-mailing it if necessary to a system
account.

     <br><dt><em>cf-runagent</em><dd>
This is a helper program that can talk to <code>cf-serverd</code> and
request that it execute <code>cf-agent</code> with its existing policy. It
can thus be used to simulate a push of changes to CFEngine hosts, if
their policy includes that they check for updates.

     <br><dt><em>cf-report</em><dd>
This generates summary and other reports in a variety of formats for
export or integration with other systems.

     <br><dt><em>cf-know</em><dd>
This agent can generate an ISO standard Topic Map from a number of
promises about system knowledge. It is used for rendering documentation
as a `semantic web'.

   </dl>

<!--  -->
<div class="node">
<a name="About-the-CFEngine-architecture"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-policy-decision-flow">The policy decision flow</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-players">The players</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-components-of-CFEngine">The components of CFEngine</a>

</div>

<h3 class="section">2.2 About the CFEngine architecture</h3>

<p>This section explains how CFEngine will operate autonomously in a
network, under your guidance.  If your site is large (thousands of
servers) you should spend some time discussing with CFEngine experts
how to tune this description to your environment as <em>scale</em>
requires you to have more infrastructure, and a potentially more
complicated configuration. The essence of any CFEngine deployment
is the same.

   <p>There are four commonly cited phases in managing systems, summarized
as follows:

     <ul>
<li>Build
<li>Deploy
<li>Manage
<li>Audit
</ul>

   <p>These separate phases originate with a model of system management
based on transactional changes.  CFEngine's conception of management
is somewhat different, as transaction processing is not a good model for
system management, but we can use this template to see how
CFEngine works differently.

     <dl>
<dt><em>Build</em><dd>A system is based on a number of decisions and resources that need to
be `built' before they can be implemented. Building the trusted
foundations of a system is the key to guiding its development.  You
don't need to decide every detail, just enough to build trust and
predictability into your system.

     <p>In CFEngine, what you build is a template of proposed promises for the
machines in an organization such that, if the machines all make and
keep these promises, the system will function seamlessly as
planned. This is how it works in a human organization, and this is how
is works for computers too.

     <br><dt><em>Deploy</em><dd>Deploying really means implementing the policy that was already
decided.  In transaction systems, one tries to push out changes one by
one, hence `deploying' the decision. In CFEngine you simply publish
your policy (in CFEngine parlance these are `promise proposals') and
the machines see the new proposals and can adjust accordingly. Each
machine runs an agent that is capable of implementing policies and
maintaining them over time without further assistance.

     <br><dt><em>Manage</em><dd>Once a decision is made, unplanned events will occur. Such
incidents traditionally set off alarms and humans rush to make new
transactions
to repair them. In CFEngine, the autonomous agent manages the system,
and you only have to deal with rare events that cannot be dealt with
automatically.

     <br><dt><em>Audit</em><dd>In traditional configuration systems, the outcome is far from clear
after a one-shot transaction, so one audits the system
to determine to discover what actually happened. In CFEngine, changes
are not just initiated once, but locally audited and maintained. 
Decision outcomes are assured by design in CFEngine and maintained
automatically, so the main worry is managing conflicting
intentions. Users can sit back and examine regular reports of
compliance generated by the agents, without having to arrange
for new `roll out' transactions.

   </dl>

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<em>ROLL-OUT and ROLL-BACK?  You should not think of CFEngine as a
roll-out system, i.e. one that attempts to force out absolute changes
and perhaps reverse them in case of error. Roll-out and roll-back are
theoretically flawed concepts that only sometimes work in practice. 
With CFEngine, you publish a sequences of policy revisions, always
moving forward (because like it or not, time only goes in one
direction).  All of the desired-state changes are managed locally by
each individual computer, and continuously repaired to ensure on-going
compliance with policy. </em>
</td></tr></table>

<!--  -->
<div class="node">
<a name="The-policy-decision-flow"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#About-the-CFEngine-architecture">About the CFEngine architecture</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-components-of-CFEngine">The components of CFEngine</a>

</div>

<h3 class="section">2.3 The policy decision flow</h3>

<p>CFEngine does not make absolute choices for you, like other
tools. Almost everything about its behaviour is matter of policy and
can be changed.  However, a structure for use, like the following, is
recommended (see the following figure).

   <p>In order to keep operations as simple as possible, CFEngine maintains
a private working directory on each machine referred to in
documentation as WORKDIR and in policy by the variable
<code>$(sys.workdir)</code>. By default, this is located at
<samp><span class="file">/var/cfengine</span></samp> or <samp><span class="file">C:\var\CFEngine</span></samp>. It contains everything
CFEngine needs to run.

   <p>The figure below shows how decisions flow through the parts of a system.

   <div class="block-image"><img src="arch.png" alt="The CFEngine architecture"></div>

     <ul>
<li>It makes sense to have a single point of coordination.  Decisions are
therefore usually made in a single location (the Policy Definition
Point).  The history of decisions and changes can be tracked by a
version control system of your choice (e.g. Subversion, CVS, etc.).

     <li>Decisions are made by editing CFEngine's policy file
<samp><span class="file">promises.cf</span></samp> (or one of its included sub-files). This process is
carried out off-line.

     <li>Once decisions have been formalized and coded, this new policy is
copied <em>manually</em> (a human decision) to a <em>decision
distribution point</em>, which by default is located in the directory
<samp><span class="file">/var/cfengine/masterfiles</span></samp> on all policy distribution servers.

     <p>In this introduction, we shall assume that there is only one central
policy distribution server, a specially-appointed server which is
referred to simple as the <code>policy server</code>.

     <li>Every client machine contacts the policy server and downloads these
updates. The policy server can be replicated if the number of clients
is very large, but we shall assume here that there is only one policy
server. 
</ul>

   <p>Once a client machine has a copy of the policy, it extracts only those
promise proposals that are relevant to it, and implements any changes
without human assistance.  This is how CFEngine manages change.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>

   <p><em>WHY DO THIS? CFEngine tries to minimize dependencies by decoupling
processes. By following this pull-based architecture, CFEngine will
tolerate network outages and will recover from deployment errors
easily. By placing the burden of responsibility for decision at the
top, and for implementation at the bottom, we avoid needless fragility
and keep two independent quality assurance processes apart.</em>

   </td></tr></table>

<!-- ***************************************************** -->
<!-- * CHAPTER -->
<!-- ***************************************************** -->
<div class="node">
<a name="Bodies-and-bundles"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-components-of-CFEngine">The components of CFEngine</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Bodies and bundles</h2>

<p>To emphasize the fact that CFEngine is not an imperative programming
language, and to keep closely to the nomenclature of Promise Theory,
CFEngine uses two concepts throughout: bundles and bodies.

<ul class="menu">
<li><a accesskey="1" href="#Bodies">Bodies</a>
<li><a accesskey="2" href="#Bundles">Bundles</a>
<li><a accesskey="3" href="#A-simple-syntax-pattern">A simple syntax pattern</a>
</ul>

<div class="node">
<a name="Bodies"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bundles">Bundles</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bodies-and-bundles">Bodies and bundles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bodies-and-bundles">Bodies and bundles</a>

</div>

<h3 class="section">3.1 Bodies</h3>

<p>Promises are the fundamental statements in CFEngine. Promises are the policy atoms. 
If there is no promise, nothing happens.

   <p>However, promises can become quite complicated and readability becomes
an issue, so it is useful to have a way of breaking them down into independent
components. The structure of a promise is this:

     <dl>
<dt><i>Promiser</i><dd>This is the object that formally makes the promise. It is always the <i>affected object</i>,
since objects can only make promises about their own state or behaviour in CFEngine.

     <br><dt><i>Promisee (optional)</i><dd>This is a possible stakeholder, someone who is interested in the outcome of the
promise. It is used as documentation, and it is used for reasoning in the commercial
CFEngine product.

     <br><dt><i>Promise body</i><dd>Everything else about a promise is defined in the body of the promise. 
We use this word in the sense of `body of a contract' or the `body of a document'
(like <code>&lt;body&gt;</code>) tags in HTML, for example.

     <p>A promise body is a list of declarations of the following form:

     <pre class="verbatim">     CFEngine_attribute_type => user_defined_value or template
</pre>

   </dl>

<ul class="menu">
<li><a accesskey="1" href="#Body-parts">Body parts</a>
<li><a accesskey="2" href="#Control-bodies">Control bodies</a>
</ul>

<div class="node">
<a name="Body-parts"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Control-bodies">Control bodies</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bodies">Bodies</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bodies">Bodies</a>

</div>

<h4 class="subsection">3.1.1 Body parts</h4>

<p>The CFEngine reserved word <code>body</code> is used to define
<i>parameterized templates</i> for bodies to hide the details of complex
promise specifications. For complex body lists, you must fill in a
body declaration as an `attachment' to the promise, e.g.

<pre class="verbatim">files:

  "/tmp/promiser"        # Promiser

    perms => myexample;  # The body is just one line, 
                         # but needs an attachment

</pre>
The attachment is declared like this, with a `type' that matches the left
hand side of the declaration in the promise:
<pre class="verbatim">body perms myexample
{
mode => "644";
owners => { "mark", "sarah", "angel" };
groups => { "users", "sysadmins", "mythical_beasts" };
}
</pre>
The structure is this:

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="smallexample">     
       <var>promiser</var>
     
         <b>LVALUE</b> =&gt; <var>RVALUE</var>
     
     ..
     
     body <b>LVALUE</b> <var>RVALUE</var>
     {
     <b>LVALUE</b> =&gt; <var>RVALUE</var>;
     <b>LVALUE</b> =&gt; <var>RVALUE</var>;
     }
</pre>
   </td></tr></table>

   <pre class="sp">

</pre>

Another way of looking at it is this:

   <pre class="sp">

</pre>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="smallexample">     
       <var>promiser</var>
     
         <b>CFEngine_word</b> =&gt; <var>user_defined_value</var>
     
     ..
     
      body <b>CFEngine_word</b> <var>user_defined_value</var>
      {
      <b>CFEngine_word</b> =&gt; <var>user_defined_value</var>;
      <b>CFEngine_word</b> =&gt; <var>user_defined_value</var>;
      ...
      }
     
</pre>
   </td></tr></table>

   <pre class="sp">

</pre>

Body attachments are required items. You cannot choose to put the
attachments in-line. This is a lesson that was learned from CFEngine
2. Readability is quickly lost if too many details are placed in-line.

<div align="center"><img src="body_bundle.png" alt="body_bundle.png"></div>

<div class="node">
<a name="Control-bodies"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Body-parts">Body parts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bodies">Bodies</a>

</div>

<h4 class="subsection">3.1.2 Control bodies</h4>

<p>Some promises in CFEngine are implicit. They are hard-coded into the program. 
For example, the fact that CFEngine looks for a number of files to read and
will execute them in a sequence is hard coded. You cannot change this. 
However, you can change the behaviour of such promises by setting control
parameters. These are formally parts of the `promise body' for these hard-coded
promises, so we use the body structure to set them. Each agent has a special
body whose name is <code>control</code>; e.g.

<pre class="verbatim">body agent control
{
bundlesequence => { "test" };
}
</pre>

<div class="node">
<a name="Bundles"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#A-simple-syntax-pattern">A simple syntax pattern</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bodies">Bodies</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bodies-and-bundles">Bodies and bundles</a>

</div>

<h3 class="section">3.2 Bundles</h3>

<p>A bundle is a simple concept. A bundle is merely a collection of promises
in a `sub-routine-like' container. The purpose of bundles is to allow
you greater flexibility to break down the contents of your policies and
give them names. Bundles also allow you to re-use promise code by
parameterizing it.

   <p>Like bodies, bundles also have `types'. Bundles belong to the agent that
is used to keep the promises in the bundle. So <code>cf-agent</code> has bundles
declared as

<pre class="verbatim">bundle agent my_name
{
}
</pre>

<p class="noindent">The <code>cf-serverd</code> program has bundles declared as:
<pre class="verbatim">bundle server my_name
{
}
</pre>
and so on.

<ul class="menu">
<li><a accesskey="1" href="#Bundle-scope">Bundle scope</a>
</ul>

<div class="node">
<a name="Bundle-scope"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bundles">Bundles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bundles">Bundles</a>

</div>

<h4 class="subsection">3.2.1 Bundle scope</h4>

<p>Variables and classes defined inside bundles are not directly visible outside. 
All variables in CFEngine are globally accessible, however if you refer to a variable
by &lsquo;<samp><span class="samp">$(unqualified)</span></samp>&rsquo;, then it is assumed to belong to the current bundle. To
access any other (scalar) variable, you must qualify the name using the name of
the bundle in which it is defined:
&lsquo;<samp><span class="samp">$(bundle_name.qualified)</span></samp>&rsquo;.

   <p>Some promise types, like <code>var</code>, <code>classes</code> may be made
by any agent. These are called <code>common</code> promises. Bundles of type <code>common</code>
are special. They may contain common promises. 
Classes defined in common bundles have global scope.

<div class="node">
<a name="A-simple-syntax-pattern"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bundles">Bundles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Bodies-and-bundles">Bodies and bundles</a>

</div>

<h3 class="section">3.3 A simple syntax pattern</h3>

<p>The syntax of CFEngine follows a simple pattern in all cases. Once you have learned this pattern,
it will make sense anywhere in the program. The figure below illustrates
this pattern. Some words are reserved by CFEngine, and are used as types or categories
for talking about promises. Other words (in blue) are to be defined by you. 
Look at the examples and try to identify these patterns yourself.

   <div class="block-image"><img src="cfengineword.png" alt="cfengineword.png"></div>

<!-- ***************************************************** -->
<!-- * CHAPTER -->
<!-- ***************************************************** -->
<div class="node">
<a name="A-simple-crash-course-in-concepts"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Knowledge-Management">Knowledge Management</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bodies-and-bundles">Bodies and bundles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 A simple crash course in concepts</h2>

<ul class="menu">
<li><a accesskey="1" href="#Rules-are-promises">Rules are promises</a>
<li><a accesskey="2" href="#Control-promises">Control promises</a>
<li><a accesskey="3" href="#Variables">Variables</a>
<li><a accesskey="4" href="#Decisions">Decisions</a>
<li><a accesskey="5" href="#Loops">Loops</a>
<li><a accesskey="6" href="#The-main-promise-types">The main promise types</a>
<li><a accesskey="7" href="#Test-a-promise_003f">Test a promise?</a>
</ul>

<div class="node">
<a name="Rules-are-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Control-promises">Control promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>

</div>

<h3 class="section">4.1 Rules are promises</h3>

<p>Everything in CFEngine 3 can be interpreted as a promise. Promises can
be made about all kinds of different subjects, from file attributes,
to the execution of commands, to access control decisions and
knowledge relationships.

   <p>This simple but powerful idea allows a very practical uniformity in
CFEngine syntax.  There is only one grammatical form for statements in
the language that you need to know and it looks generically like this:

<pre class="smallexample">     
     type:
     
     classes::
     
       "promiser" -&gt; { "promisee1", "promisee2", ... }
     
          attribute_1 =&gt; value_1,
          attribute_2 =&gt; value_2,
          ...
          attribute_n =&gt; value_n;
     
</pre>
   <p class="noindent">We speak of a promiser (the abstract object making the promise), the
promisee is the abstract object to whom the promise is made, and then
there is a list of associations that we call the `body' of the
promise, which together with the promiser-type tells us what it is all
about.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
The promiser is always the object
affected by the promise. 
</td></tr></table>

   <p>Not all of these elements are necessary every time. Some promises
contain a lot of implicit behaviour. In other cases we might want to
be much more explicit.  For example, the simplest reports promise
looks like this:

<pre class="smallexample">     
     reports:
     
     "hello world";
     
</pre>
   <p>And the simplest commands promise looks like this

<pre class="smallexample">     
     commands:
     
     "/bin/echo hello world";
     
</pre>
   <p class="noindent">This promise has default attributes for everything except the
`promiser', i.e. the
command string that promises to execute. 
A more complex promise contains many attributes:

<pre class="smallexample">     
     # Promise type
     files:
     
     # promisor                  -&gt; promisee (no curly braces needed if only one)
     "/home/mark/tmp/test_plain" -&gt; "system blue team",
     
      # attribute =&gt; value
          comment =&gt; "This comment follows the rule for knowledge  integration",
          perms   =&gt; owner("@(usernames)"),
          create  =&gt; "true";
     
</pre>
   <p>The list of promisees is not used by CFEngine except for
documentation, just
as the comment attribute (which can be added to any promise) has no
actual function
other than to provide more information to the user in error tracing
and auditing.

   <p>You see several kinds of object in this example. All literal strings
(e.g. <code>"true"</code>) in CFEngine 3 must be quoted. This provides
absolute consistency and makes type-checking easy and error-correction
powerful. All function-like objects (e.g. <code>users("..")</code>) are
either builtin
special functions or parameterized templates which contain the `meat'
of the right hand
side.

<ul class="menu">
<li><a accesskey="1" href="#Scalar-variable-expansion">Scalar variable expansion</a>
<li><a accesskey="2" href="#List-variables">List variables</a>
<li><a accesskey="3" href="#List-variable-substitution-and-expansion">List variable substitution and expansion</a>
</ul>

<!--  -->
<div class="node">
<a name="Control-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Variables">Variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Rules-are-promises">Rules are promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>

</div>

<h3 class="section">4.2 Control promises</h3>

<p>Certain promises that CFEngine components make are hard-wired into their
code. For example, the promise to email output to an appropriate
address, or the promise to wait until a certain time has elapsed before
checking a promise again (<code>ifelapsed</code>). Although these promises are
hard-wired, their behaviour can be changed. In CFEngine, behaviour is
always
constrained by the promise body. Thus hard-wired behaviour is altered by
changing the control body for each. You can find these alterable
parameters
in the reference manual.

   <p>The most important bundle is the <code>common</code> bundle, that is read by
all components of CFEngine. It contains the list of promise bundles
that should be read in and examined for promise suggestions.  From the
<samp><span class="file">promises.cf</span></samp> file:

<pre class="verbatim">
body common control
{
bundlesequence  => {
                 "update",
                 "garbage_collection",
                 "main",
                 "cfengine"
                 };

inputs          => {
                 "update.cf",
                 "site.cf",
                 "library.cf"
                 };
}

#######################################################

body agent control
{
# if default runtime is 5 mins we need this for long jobs
ifelapsed => "15";
}

#######################################################

body monitor control
{
forgetrate => "0.7";
histograms => "true";
}

#######################################################

body executor control

{
splaytime => "1";
mailto => "cfengine_mail@example.org";
smtpserver => "localhost";
mailmaxlines => "30";
}

#######################################################

body reporter control

{
reports => { "performance", "last_seen", "monitor_history" };
build_directory => "/tmp/nerves";
report_output => "html";
}

#######################################################

body runagent control
{
hosts => {
        "127.0.0.1"
        # , "myhost.example.com:5308", ...
       };

}

#######################################################

body server control

{
allowconnects         => { "127.0.0.1" , "::1" };
allowallconnects      => { "127.0.0.1" , "::1" };
trustkeysfrom         => { "127.0.0.1" , "::1" };

# Make updates and runs happen in one

cfruncommand          => "$(sys.workdir)/bin/cf-agent -f failsafe.cf &amp;&amp;
$(sys.workdir)/bin/cf-agent";
allowusers            => { "root" };
}

</pre>

<!--  -->
<div class="node">
<a name="Variables"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Decisions">Decisions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Control-promises">Control promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>

</div>

<h3 class="section">4.3 Variables</h3>

<p>Variables (or "variable definitions") are also promises &ndash; the promise to
represent their values.  We can write these in
any promise bundle. CFEngine recognizes two object types: scalars and
lists (lists contain 0 or more objects), as well as
three data-types (string, integer and real). Typing in CFEngine is
dynamic, as in
Perl and other scripting languages. Thus variables of any data-type
may be used as strings.

<ul class="menu">
<li><a accesskey="1" href="#Scalar-variable-expansion">Scalar variable expansion</a>
<li><a accesskey="2" href="#List-variables">List variables</a>
<li><a accesskey="3" href="#List-variable-substitution-and-expansion">List variable substitution and expansion</a>
</ul>

<div class="node">
<a name="Scalar-variable-expansion"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#List-variables">List variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables">Variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>

</div>

<h4 class="subsection">4.3.1 Scalar variables</h4>

<p>Scalar variables hold a single value. The are declared as follows:

<pre class="smallexample">     bundle <i>&lt;type&gt;</i> name
     {
     vars:
     
     "my_scalar" string =&gt; "String contents...";
         "my_int" int    =&gt; "1234";
        "my_real" real   =&gt; "567.89";
     
     }
     
</pre>
   <p>The &lsquo;<samp><i>&lt;type&gt;</i></samp>&rsquo; indicates that any kind of bundle applies here. 
Scalar variables are referenced by &lsquo;<samp><span class="samp">$(name)</span></samp>&rsquo; (or
&lsquo;<samp><span class="samp">${name}</span></samp>&rsquo;) and they represent
a single value at a time.

     <ul>
<li>Scalars that are written without a context, e.g. &lsquo;<samp><span class="samp">$(myvar)</span></samp>&rsquo;
are local to the current bundle.

     <li>Scalars are globally available everywhere provided one
uses the context to verify them e.g. &lsquo;<samp><span class="samp">$(context.myvar)</span></samp>&rsquo;
may be written to access the variable `myvar' in bundle `context'. 
</ul>

<!--  -->
<div class="node">
<a name="List-variables"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#List-variable-substitution-and-expansion">List variable substitution and expansion</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Scalar-variable-expansion">Scalar variable expansion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>

</div>

<h4 class="subsection">4.3.2 List variables</h4>

<p>List variables hold several values. The are declared as follows:

<pre class="smallexample">     bundle <i>&lt;type&gt;</i> name
     {
     vars:
     
        "my_slist" slist =&gt; { "list", "of", "strings" };
        "my_ilist" ilist =&gt; { "1234", "5678" };
        "my_rlist" rlist =&gt; { "567.89" };
     
     }
     
</pre>
   <p>An entire list is referred to with the at symbol &lsquo;<samp><span class="samp">@</span></samp>&rsquo;, but it does
not usually make sense to use this reference in a string. For instance
<pre class="smallexample">     
     reports:
     
       cfengine_3::
     
          "My list is @(my_slist)";
     
</pre>
   <p class="noindent">means nothing and cannot be expanded (it does not generate an
error, but instead inserts the text @(my_slist) into the string); but if
we use the scalar reference to a list variable, CFEngine will iterate over
the  values in
the list essentially making this into a list of promises.

<p class="noindent">To summarize:
     <ul>
<li>Scalar references to <i>local</i> list variables imply iteration,
e.g. 
suppose we have local list variable &lsquo;<samp><span class="samp">@(list)</span></samp>&rsquo;, then the
scalar &lsquo;<samp><span class="samp">$(list)</span></samp>&rsquo; implies an iteration over every value of the
list.

     <li>Lists can be passed in their entirety in any context
where a list is expected as &lsquo;<samp><span class="samp">@(list)</span></samp>&rsquo;., e.g.

     <pre class="verbatim">     
     vars:
     
     "longlist" slist => { @(shortlist), "plus", "plus" };
     
     "shortlist" slist => { "you", "me" };
     
</pre>

     <p>The declaration order does not matter &ndash; CFEngine will execute the promise
to assign the variable &lsquo;<samp><span class="samp">@(shortlist)</span></samp>&rsquo; before the promise to assign the
variable &lsquo;<samp><span class="samp">@(longlist)</span></samp>&rsquo;.

     <li>Only local lists can be expanded directly. Thus &lsquo;<samp><span class="samp">$(list)</span></samp>&rsquo;
can be expanded but not &lsquo;<samp><span class="samp">$(context.list)</span></samp>&rsquo;.  Global
list references have to be mapped into a local context if you want to
use them for iteration. See the reference manual for more information.

   </ul>

<!--  -->
<div class="node">
<a name="List-variable-substitution-and-expansion"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#List-variables">List variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>

</div>

<h4 class="subsection">4.3.3 Associative arrays</h4>

<p>Associative array variables also hold several values. The are declared
as follows:

<pre class="smallexample">     bundle <i>&lt;type&gt;</i> name
     {
     vars:
     
        "switches[mellow]" int =&gt; "1";
        "switches[relaxed]" int =&gt; "1";
        "off_keys" slist =&gt; { "red", "grouchy", "coarse", "febrile" };
        "switches[$(off_keys)]" int =&gt; "0";
     
     }
     
</pre>
   <p>See the reference manual for information on the &lsquo;<samp><span class="samp">getindices</span></samp>&rsquo; function
and other details of associative arrays.

<!--  -->
<div class="node">
<a name="Decisions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Loops">Loops</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables">Variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>

</div>

<h3 class="section">4.4 Decisions</h3>

<p>CFEngine decisions are made behind the scenes and the results of
certain true/false propositions are cached in Booleans referred to as
`classes'. There are no if-then-else statements in CFEngine; all
decisions are made with classes.

   <p>CFEngine runs on every computer individually and each time it wakes up
the underlying generic agent platform discovers and classifies
properties of the environment or context in which it runs.  This
information
is effectively cached and may be used to make decisions about
configuration.

   <p>Classes fall into hard (discovered) and soft (user-defined) types.  A
single hard class can be one of several things:

     <ul>
<li>The name of an operating system architecture e.g. 
<code>ultrix</code>, <code>sun4</code>, etc.

     <li>The unqualified name of a particular host. If your system
returns a fully
qualified domain name for your host, CFEngine truncates it at the
first dot. Note: <code>www.sales.company.com</code> and
<code>www.research.company.com</code> have the same unqualified name &ndash; <code>www</code>.

     <li>The name of a user-defined group of hosts.

     <li>A day of the week (in the form <code>Monday, Tuesday,
Wednesday, ..</code>).

     <li>An hour of the day, current time zone (in the form <code>Hr00,
Hr01 ... Hr23</code>).

     <li>An hour of the day GMT (in the form <code>GMT_Hr00, GMT_Hr01 ... 
GMT_Hr23</code>). 
This is consistent the world over, in case you need virtual
simultaneity of change
coordination.

     <li>Minutes in the hour (in the form <code>Min00, Min17 ... Min45</code>).

     <li>A five minute interval in the hour (in the form <code>Min00_05,
Min05_10 ... Min55_00</code>)

     <li>The quarter-hour (in the form <code>Q1, Q2, Q3, Q4</code>).

     <li>A day of the month (in the form <code>Day1, Day2, ... Day31</code>).

     <li>A month (in the form <code>January, February, ... December</code>).

     <li>A year (in the form <code>Yr1997, Yr2004</code>).

     <li>A shift in <code>Night,Morning,Afternoon,Evening</code>, which fall
into six hour blocks
starting at 00:00 hours.

     <li>A `lifecycle index', which is the year number modulo 3 (used in
long term resource memory).

     <li>An arbitrary user-defined string.

     <li>The IP address octets of any active interface (in the form
<code>ipv4_192_0_0_1<!-- /@w --></code>,
<code>ipv4_192_0_0<!-- /@w --></code>, <code>ipv4_192_0<!-- /@w --></code>, <code>ipv4_192<!-- /@w --></code>).

   </ul>

<!-- chew end Hard classes -->
   <p>To see all of the classes define on a particular host, run

<pre class="smallexample">     host# cf-promises -v
</pre>
   <p>as a privileged user. Note that some of the classes are set only
if a trusted link can be established with cfenvd, i.e. if both
are running with privilege, and the <samp><span class="file">/var/cfengine/state/env_data</span></samp>
file is secure. More information about classes can be found in
connection with
<code>allclasses</code>.

   <p>User-defined or soft classes are defined in bundles. Bundles of type
<code>common</code> yield classes that are global in scope, whereas in all
other bundle types classes are local.  Soft classes are evaluated when
the
bundle is evaluated. They can be based on test functions or simply from
other classes:

<pre class="verbatim">
bundle agent myclasses
{
classes:

"solinus" expression => "linux||solaris";

# List form useful for including functions

"alt_class" or => { "linux", "solaris", fileexists("/etc/fstab") };

"oth_class" and => { fileexists("/etc/shadow"), fileexists("/etc/ 
passwd") };

reports:

alt_class::

   # This will only report "Boo!" on linux, solaris, or any system
   # on which the file /etc/fstab exists
   "Boo!";
}

</pre>

<p class="noindent">Classes may be combined with the operators listed here in order
from highest to lowest precedence:

     <dl>
<dt>&lsquo;<samp><span class="samp">()</span></samp>&rsquo;<dd>The parenthesis group operator. 
<br><dt>&lsquo;<samp><span class="samp">!</span></samp>&rsquo;<dd>The NOT operator. 
<br><dt>&lsquo;<samp><span class="samp">.</span></samp>&rsquo;<dd>The AND operator. 
<br><dt>&lsquo;<samp><span class="samp">&amp;</span></samp>&rsquo;<dd>The AND operator (alternative). 
<br><dt>&lsquo;<samp><span class="samp">|</span></samp>&rsquo;<dd>The OR operator. 
<br><dt>&lsquo;<samp><span class="samp">||</span></samp>&rsquo;<dd>The OR operator (alternative). 
</dl>

<p class="noindent">So the following expression would be only true on Mondays or Wednesdays
from 2:00pm to 2:59pm on Windows XP systems:

<pre class="example">     
     (Monday|Wednesday).Hr14.WinXP::
     
</pre>
   <p class="noindent">Consider the following more advanced example.  Promises in bundles
of type &lsquo;<samp><span class="samp">common</span></samp>&rsquo; are global in scope &ndash; all other promises are local to
the scope of their bundle.

<pre class="verbatim">
body common control
{
bundlesequence => { "g","ls_1", "ls_2" };
}

#################################

bundle common g
{
classes:

# The promise "zero" is always satisfied , and is global in scope
"zero" expression => "any";

}

#################################

bundle agent ls_1
{
classes:

# The promise "one" is always satisfied , and is local in scope to ls_1
"one" expression => "any";
}

#################################

bundle agent ls_2
{
classes:

# The promise "two" is always satisfied , and is local in scope to ls_2
"two" expression => "any";

reports:

zero.!one.two::

  # This report @b{will} be generated
  "Success";
}

</pre>

   <p>Here we see that class &lsquo;<samp><span class="samp">zero</span></samp>&rsquo; is global while classes &lsquo;<samp><span class="samp">one</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">two</span></samp>&rsquo; are local. 
The report `Success' result is therefore true because only &lsquo;<samp><span class="samp">zero</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">two</span></samp>&rsquo; are in scope in the &lsquo;<samp><span class="samp">ls_2</span></samp>&rsquo; bundle (and the class
expression for bundle &lsquo;<samp><span class="samp">ls_2</span></samp>&rsquo; requires that both &lsquo;<samp><span class="samp">zero</span></samp>&rsquo; and
&lsquo;<samp><span class="samp">two</span></samp>&rsquo; be true and that &lsquo;<samp><span class="samp">one</span></samp>&rsquo; not be true).

<!--  -->
<div class="node">
<a name="Loops"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-main-promise-types">The main promise types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Decisions">Decisions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>

</div>

<h3 class="section">4.5 Loops</h3>

<p>If you are looking for loops in CFEngine then we need to reprogram you
a little, as you are thinking like a programmer!  CFEngine is not a
programming language that is meant to give you low level control, but
rather a set of declarations that embody processes. It's the difference
between the gears on a bicycle and the automated transmission in a
transporter.

   <p>Loops are executed implicitly in CFEngine, but there is no visible
mechanism for it &ndash; because that would steal attention from the
intention of the promises. The way to express them is through lists.

   <p>Loops are really a way to iterate a variable over a list. Try the
following.

<pre class="verbatim">
body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{
vars:

# This is a list

"component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

# This is an associative array

"array[cf-monitord]" string => "The monitor";
"array[cf-serverd]" string => "The server";
"array[cf-execd]" string => "The executor, not executionist";

reports:

cfengine_3::

"$(component) is $(array[$(component)])";

}

</pre>
The output looks something like this:
<pre class="smallexample">     
     /usr/local/sbin/cf-agent -f ./unit_loops.cf -K
     
     R: cf-monitord is The monitor
     R: cf-serverd is The server
     R: cf-execd is The executor, not executionist
     
</pre>
   <p>You see from this that, if we refer to a list variable using the
scalar reference
operator &lsquo;<samp><span class="samp">$()</span></samp>&rsquo;, CFEngine interprets this to mean &ldquo;please iterate
over all
values of the list&rdquo;. Thus, we have effectively a `foreach' loop, without the
attendant syntax.

<!--  -->
<div class="node">
<a name="The-main-promise-types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Test-a-promise_003f">Test a promise?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Loops">Loops</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>

</div>

<h3 class="section">4.6 The main promise types</h3>

<p class="noindent">The following promise types may be used in any bundle:
     <dl>
<dt><code>vars</code><dd>A promise to be a variable, representing a value. 
<br><dt><code>classes</code><dd>A promise to be a class representing a state of the system. 
<br><dt><code>reports</code><dd>A promise to report a message. 
</dl>

<p class="noindent">These additional promise types may be used only in agent bundles
     <dl>
<dt><code>commands</code><dd>A promise to execute a command. 
<br><dt><code>databases</code><dd>A promise to configure a database. 
<br><dt><code>files</code><dd>A promise to configure a file, including its existence, attributes and
contents. 
<br><dt><code>interfaces</code><dd>A promise to configure a network interface. 
<br><dt><code>methods</code><dd>A promise to take on a whole bundle of other promises. 
<br><dt><code>packages</code><dd>A promise to install a package. 
<br><dt><code>storage</code><dd>A promise to verify attached storage. 
</dl>

<p class="noindent">These promise types belong to other components:
     <dl>
<dt><code>access</code><dd>A promise to grant or deny access to file objects in <code>cf-serverd</code>. 
<br><dt><code>measurements</code><dd>A promise to measure or sample data from the system, for monitoring or
reporting in <code>cf-monitord</code> (CFEngine Nova and above). 
<br><dt><code>roles</code><dd>A promise to allow certain users to activate certain classes when
executing <code>cf-agent</code> remotely, in <code>cf-serverd</code>. 
<br><dt><code>topics</code><dd>A promise to associate knowledge with a name, and possibly other
topics, in <code>cf-know</code>. 
<br><dt><code>occurrences</code><dd>A promise to point or refer to a knowledge resource, in <code>cf-know</code>. 
</dl>

<!--  -->
<div class="node">
<a name="Test-a-promise%3f"></a>
<a name="Test-a-promise_003f"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-main-promise-types">The main promise types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>

</div>

<h3 class="section">4.7 Test a promise?</h3>

<p>If you are impatient to get hands-on experience, now might be a good time to take a break from Concepts and have a look at "First promises" (<a href="http://cfengine.com/manuals/cf3-tutorial.html#First-promises">http://cfengine.com/manuals/cf3-tutorial.html#First-promises</a>. Still, since knowledge management is an integral part of CFEngine, we strongly recommend to read the following section on this very issue sooner rather than later.

<!-- ***************************************************** -->
<!-- * CHAPTER -->
<!-- ***************************************************** -->
<div class="node">
<a name="Knowledge-Management"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#A-simple-crash-course-in-concepts">A simple crash course in concepts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Knowledge Management</h2>

<p>A unique aspect of CFEngine, that is fully developed in the commercial
editions of the software, its ability to enable integrated knowledge
management as part of an automation process, and to use its configuration
technology as a `semantic' documentation engine.

   <div class="block-image"><img src="topicmap.png" alt="topicmap.png"></div>

   <p>Knowledge management is the challenge of our times.  Organizations
frequently waste significant effort re-learning old lessons because they have
not been documented and entered into posterity.  Now you can alleviate
this problem with some simple rules of thumb and even build
sophisticated index-databases of documents.

<ul class="menu">
<li><a accesskey="1" href="#Promises-and-Knowledge">Promises and Knowledge</a>
<li><a accesskey="2" href="#The-basics-of-knowledge">The basics of knowledge</a>
<li><a accesskey="3" href="#Annotating-promises">Annotating promises</a>
<li><a accesskey="4" href="#A-promise-model-of-topic-maps">A promise model of topic maps</a>
<li><a accesskey="5" href="#What-topic-maps-offer">What topic maps offer</a>
<li><a accesskey="6" href="#The-nuts-and-bolts-of-topic-maps">The nuts and bolts of topic maps</a>
<li><a accesskey="7" href="#Example-of-topics-promises">Example of topics promises</a>
<li><a accesskey="8" href="#Modelling-configuration-promises-as-topic-maps">Modelling configuration promises as topic maps</a>
</ul>

<div class="node">
<a name="Promises-and-Knowledge"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-basics-of-knowledge">The basics of knowledge</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Knowledge-Management">Knowledge Management</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.1 Promises and Knowledge</h3>

<p>The learning curve for configuration management systems has been the
brunt of frequent criticism over the years. Users are expected to either
confront the informational complexity of systems at a detailed level, or
abandon the idea of fine control altogether.  This has led either to
information overload or over-simplification. The ability to cope with
information complexity is therefore fundamental to IT management

   <p>CFEngine introduced the <em>promise model</em> for configuration in
order to flatten out this learning curve. It can lead to
simplifications in use, because a lot of the thinking has been done
already and is encapsulated into the model. One of its special
properties is that it is both a model for system behaviour and a model
for knowledge representation (this is what declarative languages seek
to be, of course). More specifically, it incorporated a subset of the
ISO standard for `Topic Maps', an open technology for semantic
indexing of information resources.  By bringing together these two
technologies (which are highly compatible), we end up with a seamless
front-end for sewing together and browsing system information.

   <p>Knowledge management is a field of research in its own right, and it
covers a multitude of issues both human and technological. Most would
agree that knowledge is composed of facts and relationships and that
there is a need both for clear definitions and semantic context to
interpret knowledge properly; but how do we attach <em>meaning</em> to
raw information without ambiguity?

   <p>Knowledge has quite a lot in common with configuration: what after all
is
knowledge but a configuration of ideas in our minds, or on some
representation medium (paper, silicon etc). It is a coded pattern,
preferably one that we can agree on and share with others.  Both
knowledge and configuration management are about describing patterns. 
A simple knowledge model can be used to represent a policy or
configuration; conversely, a simple model of policy configuration can
manufacture a knowledge structure just as it might manufacture
a filesystem or a set of services.

<div class="node">
<a name="The-basics-of-knowledge"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Annotating-promises">Annotating promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Promises-and-Knowledge">Promises and Knowledge</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.2 The basics of knowledge</h3>

<p>Knowledge only truly begins when we write things down:

     <ul>
<li>The act of formulating something in writing brings a discipline
of thought than often lends clarity to an idea. 
<li>You never confront an idea fully until you try to put it into
language. 
<li>Any written record that is kept allows others to read it and
pass on the knowledge. 
</ul>

   <p>The trouble is that writing is something people don't like to do, and
few are very good at.  To an engineer, it can feel like a waste of
time, especially during a busy day, to break off from the doing to
write about the doing. Also, writing requires a spurt of creative
thinking and engineers are often more comfortable with manipulating
technical patterns and notations than writing fluent linguistic
formulations that seem overtly long-winded.

   <p>CFEngine tries to bridge this gap by making documentation simple and
part of the technical configuration. CFEngine's knowledge agent then
uses AI and network science algorithms to construct a readable
documentation from these technical annotations. It can do this because
a lot of thought has already gone into the meaning of the promise
model.

<div class="node">
<a name="Annotating-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#A-promise-model-of-topic-maps">A promise model of topic maps</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-basics-of-knowledge">The basics of knowledge</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.3 Annotating promises</h3>

<p>The beginning of knowledge is to annotate the technical specifications. 
Remember that the point of a promise is to convey an <i>intention</i>. 
When writing promises, get into the habit of giving every promise a
comment that explains its intention.  Also, expect to give special
promises
<i>handles</i>, or helpful labels that can be used to refer to them by in
other
promise statements. A handle could be something dumb like `xyz', but
you should
try to use more meaningful titles to help make references clear.

<pre class="verbatim">
files:

"/var/cfengine/inputs"

     handle => "update_policy",
    comment => "Update the CFEngine input files from the policy server",
      perms => system("600"),
  copy_from => rcp("$(master_location)","$(policy_server)"),
depth_search => recurse("inf"),
file_select => input_files,
     action => immediate;

</pre>
If a promise affects another promise in some way, you can
make the affected one
promise one of the promisees, like this:

<pre class="verbatim">
access:

"/master/CFEngine/inputs" -> { "update_policy", "other_promisee" },

handle  => "serve_updates",
  admit   => { "217.77.34.*" };

</pre>

<p class="noindent">Conversely, if a promise might depend on another in some
(even indirect) way, document this too.

<pre class="verbatim">
files:

"/var/cfengine/inputs"

      handle => "update_policy",
     comment => "Update the CFEngine input files from the policy  
server",
  depends_on => { "serve_updates" },
       perms => system("600"),
   copy_from => rcp("$(master_location)","$(policy_server)"),
depth_search => recurse("inf"),
file_select => input_files,
      action => immediate;

</pre>

<p class="noindent">This use of annotation is the first level of documentation
in CFEngine. 
The annotations are used internally by CFEngine to provide meaningful
error messages with context and to compute dependencies that reveal
the existence of process chains. These can be turned into a topic map
for browsing the policy relationships is a web browser, using
<code>cf-know</code>.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>
The CFEngine Knowledge Map is only available in commercial editions
of the software, where the necessary support to set up and maintain
this technology can be provided. 
</td></tr></table>

<div class="node">
<a name="A-promise-model-of-topic-maps"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-topic-maps-offer">What topic maps offer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Annotating-promises">Annotating promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.4 A promise model of topic maps</h3>

<p>CFEngine's model of promises can also be used to promise information
and its relevance in different contexts. The Knowledge agent <code>cf-know</code>
understands three kinds of promise.

     <dl>
<dt><code>topics:</code><dd>A topic is merely a string that can be associated with another string. It represents a `subject to be talked about'. 
Like other promise types, you can use contexts, which are formed from other topics expressions to limit the scope of
the current topic promise. 
<br><dt><code>things:</code><dd>Things are a simplified interface to topics, that were introduced to make it easier
for users to contribute knowledge about more concrete `things', or less abstract ideas. 
A challenge with knowledge management is the abstract and technical nature of the models
one must use to represent it. Things attempt to make that task easier. 
<br><dt><code>occurrences:</code><dd>An occurrence is a reference to a document or a piece of text that actually represents
knowledge content about the topic concerned. Occurrences are generally URLs or strings
explaining things or topics. 
</dl>

<div class="node">
<a name="What-topic-maps-offer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-nuts-and-bolts-of-topic-maps">The nuts and bolts of topic maps</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#A-promise-model-of-topic-maps">A promise model of topic maps</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.5 What topic maps offer</h3>

<p>CFEngine is capable of automating the documentation of a policy, using basic annotations provided above, as a
knowledge map. They require very little effort from the user. If you
are using the Community Edition of CFEngine, you can develop a topic
map, but we do not support the backend technology without a
commercial license. In either case, once you become familiar with the
use of Topic Maps, you will want to extend your knowledge manually to
incorporate things like:

     <ul>
<li>Local (high level) policy documents
<li>Related databases, such as CMDBs
</ul>

<p class="noindent">So let us spend a while showing how to encode knowledge in
topic maps
using <code>cf-know</code>.

   <p>The kind of result you can expect is shown in the pictures below.  The
example figures show typical pages generated by the knowledge agent
<code>cf-know</code>. The first of these shows how we use the technology to
power the web knowledge base in the commercial CFEngine product.

   <p>In this use, all of the data are based on documentation for
the CFEngine software, and most of the relationships are manually
entered.

   <p>For a second example, consider how CFEngine can generate such a
knowledge map analysis of its own configuration (self-analysis).  The
data in the images below describe the CFEngine configuration
promises. One such page is generated, for instance, for each policy
promise, and pages are generated for reports from different computers
etc. You can also create you own `topic pages' for any local
(enterprise) information that you have.

   <p>In this example, the promise has been given the promise-handle
<code>update_policy</code>, and the associations and the lower graph shows
how this promise relates to other promises through its documented
dependencies (these are documented from the promisees and
<code>depends_on</code> attributes of other promises.).

   <p>The example page shows two figures, one above the other. 
The upper figure shows the thirty nearest topics (of any kind) that
are related to this one. 
Here the relationships are unspecific. This diagram can reveal
pathways to related information
that are often unexpected, and illustrates relationships that broaden
one's understanding
of the place the current promise occupies within the whole.

   <p>Although the graphical illustrations are just renderings of
semantic associations shown more fully in text, they are useful for
visualizing
several levels of depth in the associative network. This can be
surprisingly useful for brainstorming and reasoning alike. In
particular, one can see the other promises that could be affected if
we were to make a change to the current promise.  Such impact analyses
can be crucial to planning change and release management of policy.

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>

   <p>A knowledge base is a slightly improved implementation of a Topic Map which is an ISO
standard technology. A topic map works like an index that can point to
many different kinds of external resources, and may contain simple
text and images internally. So you use it to bind together documents
of any kind. A CFEngine knowledge base is not a new document format, it
is an overlay map that joins ideas and resources together, and
displays relationships.

   </td></tr></table>

<div class="node">
<a name="The-nuts-and-bolts-of-topic-maps"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Example-of-topics-promises">Example of topics promises</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-topic-maps-offer">What topic maps offer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.6 The nuts and bolts of topic maps</h3>

<ul class="menu">
<li><a accesskey="1" href="#Topic-map-definitions">Topic map definitions</a>
</ul>

<div class="node">
<a name="Topic-map-definitions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-nuts-and-bolts-of-topic-maps">The nuts and bolts of topic maps</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-nuts-and-bolts-of-topic-maps">The nuts and bolts of topic maps</a>

</div>

<h4 class="subsection">5.6.1 Topic map definitions</h4>

<p>Topic maps are really electronic indices, but they form and work like
webs. 
A topic is the technical representation of a `subject', i.e. anything
you might want
to discuss, abstract or physical e.g.  an item of `abstract
knowledge', which probably has a number of concrete exemplars. It
might be a person, a machine, a quality, etc.

   <p>Topics can be classified into boxes called <em>topic-types</em> so that
related
things can be collated and unrelated things can be separated, e.g. 
types allow us to distinguish between <code>rmdir</code> the Unix utility
and <code>rmdir</code> the Unix system-call.

   <p>Each typed topic can further point to a number of references or
exemplars called <em>occurrences</em>. For instance, an occurrence of
the topic `computer' might include books, web documents, database
entries, physical manifestations, or any other information.  An
occurrence is a reference that exemplifies the abstract
topic. Occurrence references are like the page numbers in an
index.

   <p>A book index typically has `see also' references which point from one
topic to another. 
Topic Maps allow one to define any kind of <em>association</em> between
topics. Unlike an ordinary index, a topic map has a rich (potentially
infinite) variety of cross reference types. 
For instance,
<pre class="smallexample">     topic_1 ``is a kind of'' topic_2
     topic_1 ``is improved by'' topic 2
     topic_1 ``solves the problem of'' topic_2
</pre>
   <p class="noindent">The topic map model thus has three levels of containers:

     <dl>
<dt><em>Contexts</em><dd>The box into which we classify a topic to disambiguate different
topics with the same name (`in the context of')<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>.

     <br><dt><em>Topics/Things</em><dd>The representation of a subject (an index term).

     <br><dt><em>Occurrence Types</em><dd>A term that explains how an actual document occurrence relates
to the topic is claims to say something about. e.g. (tutorial, manual,
or
example, definition, photo-album etc).

     <br><dt><em>Occurrences</em><dd>Specific information resources: these are pointers to the actual
documents
that we want to read  (like page numbers in an index). 
</dl>

   <p>Contexts map conveniently into CFEngine classes. 
Topics map conveniently into promisers. 
Occurrences also map to promisers of a different type. 
These three label different levels of granularity of meaning. Contexts
represent a set of topics that might be relevant, which in turn encompass a set of
occurrences of resources that contain actual information about the topics in that context. The primacy of topics in this
stems from their ability to form networks by <em>association</em>.

   <p>The classic approach to information modelling is to build a
hierarchical decomposition of non-overlapping objects. Data are
manipulated into non-overlapping containers which often prove
to be overly restrictive. Topic maps allow us to avoid the kinds of
mistakes that have led to monstrosities like the Common Information
Model (CIM) with its <em>thousands</em> of strictly non-overlapping type
categories.

   <p>Each topic allows us to effectively `shine a light' onto the
occurrences of information that highlight the concepts pertinent to
the topic somehow.

<div class="node">
<a name="Example-of-topics-promises"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Modelling-configuration-promises-as-topic-maps">Modelling configuration promises as topic maps</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-nuts-and-bolts-of-topic-maps">The nuts and bolts of topic maps</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.7 Example of topics promises</h3>

<p>You can use <code>cf-know</code> to render a topic map either as text (for
command line
use) or as HTML (for web rendering). We begin with the text rendering
as it requires less
infrastructure. You will just need a database.

   <p>Try typing in the following knowledge promises:

<pre class="smallexample">     
     body common control
     {
     bundlesequence  =&gt; { "tm" };
     }
     
     ###################################################
     
     bundle knowledge tm
     {
     topics:
     
     
     "server" comment =&gt; "Common name for a computer in a desktop";
     "desktop" comment =&gt; "Common name for a computer for end users";
     
     programs:: # context of programs
     
     "httpd" comment =&gt; "A web service process";
     "named" comment =&gt; "A name service process";
     
     services::
     
     "WWW" comment =&gt; "World Wide Web service",
           association =&gt; a("is implemented by",
                            "programs::httpd",
                            "implements");
     
      # if we don't specificy a context, it is "any"
     
     "WWW" association =&gt; a("looks up addresses with",
                            "named",
                            "serves addresses to");
     
     occurrences:
     
     httpd::
        "http://www.apache.org"
          represents =&gt; { "website" };
     
     }
     
     ###################################################
     
     body association a(f,name,b)
     
     {
     forward_relationship =&gt; "$(f)";
     backward_relationship =&gt; "$(b)";
     associates =&gt; { $(name) };
     }
</pre>
   <p class="noindent">The simplified things interface is similar, but uses fixed relations:

<pre class="verbatim">bundle knowledge company_knowledge
{
things:
 regions::

   "EMEA"     comment => "Europe, The Middle-East and Africa";
   "APAC"     comment => "Asia and the Pacific countries";

 countries::
   "UK"            synonyms => { "Great Britain" },
              is_located_in => { "EMEA", "Europe" };

   "Netherlands"   synonyms => { "Holland" },
              is_located_in => { "EMEA", "Europe" };

   "Singapore"     is_located_in => { "APAC", "Asia" };

 locations::
   "London_1"    is_located_in => { "London", "UK" };
   "New_Jersey"  is_located_in => { "USA" };

 networks::

  "192.23.45.0/24"         comment => "Secure network, zone 0. Single octet for corporate offices",
                   is_connected_to => { "oslo-hub-123" };

</pre>

<ul class="menu">
<li><a accesskey="1" href="#Analysing-and-indexing-the-policy">Analysing and indexing the policy</a>
<li><a accesskey="2" href="#cf_002dknow">cf-know</a>
</ul>

<div class="node">
<a name="Analysing-and-indexing-the-policy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#cf_002dknow">cf-know</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-of-topics-promises">Example of topics promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-of-topics-promises">Example of topics promises</a>

</div>

<h4 class="subsection">5.7.1 Analysing and indexing the policy</h4>

<p>CFEngine can analyze the promises you have made, index and cross
reference them using the command:

<pre class="verbatim"># cf-promises -r
</pre>
Normally, the default policy in Nova or Constellation will perform this
command each time the policy is changed.

<div class="node">
<a name="cf-know"></a>
<a name="cf_002dknow"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Analysing-and-indexing-the-policy">Analysing and indexing the policy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Example-of-topics-promises">Example of topics promises</a>

</div>

<h4 class="subsection">5.7.2 <code>cf-know</code></h4>

<p>CFEngine's knowledge agent <code>cf-know</code> allows you to make promises
about knowledge and its inter-relationships. It is not specifically a
generic topic map language: rather it provides a powerful configuration
language for managing a knowledge base that can be compiled into a
topic map.

   <p>To build a topic map from a set of knowledge promises in <samp><span class="file">knowledge.cf</span></samp>, you would write:

<pre class="verbatim"># cf-know -b -f ./knowledge.cf
</pre>

   <p>The syntax of this file is hinted at below. 
The full ISO standard topic map model is too rich to be a useful tool
for system knowledge management. However, this is where powerful
configuration management can help to simplify the process: encoding a
topic map is a complex problem in configuration, which is exactly what
CFEngine is for. CFEngine's topic map promises have the following
form:

<pre class="smallexample">     
     bundle knowledge example
     {
     topics:
     
     topic_type_context::                          # canonical container
     
     "Topic name"                                # short topic name
     
           comment =&gt; "Use this for a longer description",
       association =&gt; a("forward assoc to","Other topic","backward assoc");
     
       "Other topic";
     
     occurrences:
     
     Topic_name::                                   # Topic
     
       "http://www.example.org/document.xyz"        # URI to instance
     
         represents =&gt; { "Definition", "Tutorial"}; # sub-types
     }
     
</pre>
   <p>The association body templates look like this:
<pre class="verbatim">
body association a(f,name,b)
{
forward_relationship => "$(f)";
backward_relationship => "$(b)";
associates => { $(name) };
}

</pre>

   <p><table class="cartouche" summary="cartouche" border="1"><tr><td>

   <p>Promise theory adds a clear structure to the topic map ontology, which
is highly beneficial as experience shows that weak conceptual models
lead to poor knowledge maps.

   </td></tr></table>

<div class="node">
<a name="Modelling-configuration-promises-as-topic-maps"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Example-of-topics-promises">Example of topics promises</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Knowledge-Management">Knowledge Management</a>

</div>

<h3 class="section">5.8 Modelling configuration promises as topic maps</h3>

<p>We can model topic maps as promises within CFEngine; the
question then remains as to how to use topic maps to model
configurations so that CFEngine users can navigate the documented
promises using a web browser and be able to see all of the
relationships between otherwise isolated and fragmentary rules. This
will form the basis of a semantic Configuration Management Database
(sCMDB) for the CFEngine software. The key to making these ends meet
is to see the configuration of the topic map as a number f promises
made in the abstract space of topics and the turning each promise into
a meta-promise that models the configuration as a topic with attendant
associations. Consider the following CFEngine promise.

<pre class="verbatim">
bundle agent update
{
files:

any::

``/var/cfengine/inputs'' -> { ``policy_team'', ''dependent'' },

          comment => ``Check policy updates from source'',
            perms => true,
             mode => 600,
        copy_from => true,
      copy_source => /policy/masterfiles,
          compare => digest,
     depth_search => true,
            depth => inf,
         ifelapsed => 1;

}
</pre>

   <p>This system configuration promise can be mapped by CFEngine into a
number of other promise proposals intended for the <code>cf-know</code>
agent. Suppressing some of the details, we have:

<pre class="verbatim">
type_files::

"/var/cfengine/inputs"
    association => a("promise made in bundle","update","bundle  
contains promise");
"/var/cfengine/inputs"
    association => a("specifies body type","perms","is specified in");
"/var/cfengine/inputs"
    association => a("specifies body type","mode","is specified in");
"/var/cfengine/inputs"
    association => a("specifies body type","copy_from","is specified  
in");

# etc ...

occurrences:

_var_CFEngine_inputs::

  "promise_output_common.html#promise__var_CFEngine_inputs_update_cf_13"
     represents => { "promise definition" };

</pre>
Note that in this mapping, the actual promise (viewed as a real world
entity) is an occurrence of the topic `promise'; at the same time each
promise could be discussed as a different topic allowing
meta-modelling of the entity-relation model in the real-world
data. Conversely the topics themselves become configuration items or
`promisers' in the promise model. The effect is to create a navigable
semantic web for traversing the policy; this documents the structure
and intention of the policy using a small ontology of standard
concepts and can be extended indefinitely by human domain experts.

<h2 class="chapter">6 More...</h2>

<p><table class="cartouche" summary="cartouche" border="1"><tr><td>

   <p>You will find extensive help, examples and documentation as part of
the commercial
CFEngine support. Visit the website <a href="http://www.cfengine.com">http://www.cfengine.com</a> for more
details.

</td></tr></table>

   <p><a name="Contents">
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">CFEngine-GetStarted</a>
<li><a name="toc_Introduction-_002d-System-automation" href="#Introduction-_002d-System-automation">1 Introduction - System automation</a>
<ul>
<li><a href="#Managing-diverse-and-challenging-environments-seamlessly-and-invisibly">1.1 Managing diverse and challenging environments seamlessly and invisibly</a>
<li><a href="#Managing-expectations-_002d-a-theory-of-promises">1.2 Managing expectations - a theory of promises</a>
<li><a href="#Why-automation_003f">1.3 Why automation?</a>
<li><a href="#How-do-you-view-CFEngine">1.4 How do <i>you</i> view CFEngine?</a>
</li></ul>
<li><a name="toc_The-components-of-CFEngine" href="#The-components-of-CFEngine">2 The components of CFEngine</a>
<ul>
<li><a href="#The-players">2.1 The players</a>
<li><a href="#About-the-CFEngine-architecture">2.2 About the CFEngine architecture</a>
<li><a href="#The-policy-decision-flow">2.3 The policy decision flow</a>
</li></ul>
<li><a name="toc_Bodies-and-bundles" href="#Bodies-and-bundles">3 Bodies and bundles</a>
<ul>
<li><a href="#Bodies">3.1 Bodies</a>
<ul>
<li><a href="#Body-parts">3.1.1 Body parts</a>
<li><a href="#Control-bodies">3.1.2 Control bodies</a>
</li></ul>
<li><a href="#Bundles">3.2 Bundles</a>
<ul>
<li><a href="#Bundle-scope">3.2.1 Bundle scope</a>
</li></ul>
<li><a href="#A-simple-syntax-pattern">3.3 A simple syntax pattern</a>
</li></ul>
<li><a name="toc_A-simple-crash-course-in-concepts" href="#A-simple-crash-course-in-concepts">4 A simple crash course in concepts</a>
<ul>
<li><a href="#Rules-are-promises">4.1 Rules are promises</a>
<li><a href="#Control-promises">4.2 Control promises</a>
<li><a href="#Variables">4.3 Variables</a>
<ul>
<li><a href="#Scalar-variable-expansion">4.3.1 Scalar variables</a>
<li><a href="#List-variables">4.3.2 List variables</a>
<li><a href="#List-variable-substitution-and-expansion">4.3.3 Associative arrays</a>
</li></ul>
<li><a href="#Decisions">4.4 Decisions</a>
<li><a href="#Loops">4.5 Loops</a>
<li><a href="#The-main-promise-types">4.6 The main promise types</a>
<li><a href="#Test-a-promise_003f">4.7 Test a promise?</a>
</li></ul>
<li><a name="toc_Knowledge-Management" href="#Knowledge-Management">5 Knowledge Management</a>
<ul>
<li><a href="#Promises-and-Knowledge">5.1 Promises and Knowledge</a>
<li><a href="#The-basics-of-knowledge">5.2 The basics of knowledge</a>
<li><a href="#Annotating-promises">5.3 Annotating promises</a>
<li><a href="#A-promise-model-of-topic-maps">5.4 A promise model of topic maps</a>
<li><a href="#What-topic-maps-offer">5.5 What topic maps offer</a>
<li><a href="#The-nuts-and-bolts-of-topic-maps">5.6 The nuts and bolts of topic maps</a>
<ul>
<li><a href="#Topic-map-definitions">5.6.1 Topic map definitions</a>
</li></ul>
<li><a href="#Example-of-topics-promises">5.7 Example of topics promises</a>
<ul>
<li><a href="#Analysing-and-indexing-the-policy">5.7.1 Analysing and indexing the policy</a>
<li><a href="#cf_002dknow">5.7.2 <code>cf-know</code></a>
</li></ul>
<li><a href="#Modelling-configuration-promises-as-topic-maps">5.8 Modelling configuration promises as topic maps</a>
</li></ul>
<li><a name="toc_Modelling-configuration-promises-as-topic-maps" href="#Modelling-configuration-promises-as-topic-maps">6 More...</a>
</li></ul>
</div>



   <p><script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>

   <div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Here, CFEngine differs from the topic map standard in allowing contexts
to be overlapping sets, rather than mutually exclusive `types'. 
CFEngine is guided by Promise Theory in this respect in order to enable
distribtued cooperation and the development of a free and emergent ontology.</p>

   <hr></div>

</body></html>

