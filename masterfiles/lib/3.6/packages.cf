############################################################################
#  Copyright (C) Cfengine AS
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License LGPL as published by the
#  Free Software Foundation; version 3.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  To the extent this program is licensed as part of the Enterprise
#  versions of Cfengine, the applicable Commerical Open Source License
#  (COSL) may apply to this file if you as a licensee so wish it. See
#  included file COSL.txt.
###########################################################################
#
# Cfengine Community Open Promise-Body Library
#
# This initiative started by Cfengine promotes a
# standardized set of names and promise specifications
# for template functionality within Cfengine 3.
#
# The aim is to promote an industry standard for
# naming of configuration patterns, leading to a
# de facto middleware of standardized syntax.
#
# Names should be intuitive and parameters should be
# minimal to assist readability and comprehensibility.

# Contributions to this file are voluntarily given to
# the cfengine community, and are moderated by Cfengine.
# No liability or warranty for misuse is implied.
#
# If you add to this file, please try to make the
# contributions "self-documenting". Comments made
# after the bundle/body statement are retained in
# the online docs
#

# For Cfengine Core: 3.5.1 to 3.5.x
# Packages bodies

###################################################
# If you find Cfengine useful, please consider    #
# purchasing a commercial version of the software.#
###################################################

##--------------------------------------------------------------
## Packages promises
##--------------------------------------------------------------

body package_method zypper

{
      package_changes => "bulk";

      package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/zypper list-updates";
      package_list_update_ifelapsed => "240";

      package_patch_list_command => "/usr/bin/zypper patches";
      package_installed_regex => "i.*";
      package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s]+).*";
      package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
      package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";

      package_patch_installed_regex => ".*Installed.*|.*Not Applicable.*";
      package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
      package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";

      package_name_convention => "$(name)";
      package_add_command => "/usr/bin/zypper --non-interactive install";
      package_delete_command => "/usr/bin/zypper --non-interactive remove --force-resolution";
      package_update_command => "/usr/bin/zypper --non-interactive update";
      package_patch_command => "/usr/bin/zypper --non-interactive patch$"; # $ means no args
      package_verify_command => "/usr/bin/zypper --non-interactive verify$";
}

##

bundle common debian_knowledge
{
  vars:
      "apt_prefix" string => "/usr/bin/env DEBIAN_FRONTEND=noninteractive LC_ALL=C PATH=/bin:/sbin/:/usr/bin:/usr/sbin";
      "call_dpkg" string => "$(apt_prefix) $(paths.path[dpkg])";
      "call_apt_get" string => "$(apt_prefix) $(paths.path[apt_get])";
      "call_aptitude" string => "$(apt_prefix) $(paths.path[aptitude])";
      "dpkg_options" string => "-o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef";
}

body package_method apt
{
      package_changes => "bulk";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";
      package_list_name_regex    => ".i\s+([^\s]+).*";
      package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
      package_name_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_ifelapsed => "240";

    have_aptitude::
      package_add_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_list_update_command => "/usr/bin/aptitude update";
      package_delete_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes -q remove";
      package_update_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_patch_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_verify_command =>  "/usr/bin/aptitude show";
      package_noverify_regex => "(State: not installed|E: Unable to locate package .*)";

      package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

    !have_aptitude::
      package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes -q remove";
      package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_verify_command => "$(debian_knowledge.call_dpkg) -s";
      package_noverify_returncode => "1";

      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

}

# Ignore aptitude because:
#  1) aptitude will remove "unneeded" packages unexpectly
#  2) aptitude return codes are useless
#  3) aptitude is a high level interface
#  4) aptitude provides little benefit
#  5) have_aptitude is a hard class and thus cannot be unset
body package_method apt_get
{
      package_changes => "bulk";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";
      package_list_name_regex    => ".i\s+([^\s]+).*";
      package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
      package_name_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_ifelapsed => "240";

      # Target a specific release, such as backports
      package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes -q remove";
      package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_verify_command => "$(debian_knowledge.call_dpkg) -s";
      package_noverify_returncode => "1";

      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

      # make correct version comparisons
      package_version_less_command => "$(debian_knowledge.call_dpkg) --compare-versions $(v1) lt $(v2)";
      package_version_equal_command => "$(debian_knowledge.call_dpkg) --compare-versions $(v1) eq $(v2)";

}

body package_method apt_get_release(release)
{
      package_changes => "bulk";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";
      package_list_name_regex    => ".i\s+([^\s]+).*";
      package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
      package_name_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_ifelapsed => "240";

      # Target a specific release, such as backports
      package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes --target-release $(release) install";
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes -q remove";
      package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes --target-release $(release) install";
      package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes --target-release $(release) install";
      package_verify_command => "$(debian_knowledge.call_dpkg) -s";
      package_noverify_returncode => "1";

      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

      # make correct version comparisons
      package_version_less_command => "$(debian_knowledge.call_dpkg) --compare-versions $(v1) lt $(v2)";
      package_version_equal_command => "$(debian_knowledge.call_dpkg) --compare-versions $(v1) eq $(v2)";

}

##

body package_method dpkg_version(repo)
{
      package_changes => "individual";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_list_update_ifelapsed => "240";

      package_list_name_regex    => ".i\s+([^\s]+).*";
      package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";

      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed

      package_file_repositories => { "$(repo)" };

    debian.x86_64::
      package_name_convention => "$(name)_$(version)_amd64.deb";

    debian.i686::
      package_name_convention => "$(name)_$(version)_i386.deb";

    have_aptitude::
      package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";
    !have_aptitude::
      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

    debian::
      package_add_command => "$(debian_knowledge.call_dpkg) --install";
      package_delete_command => "$(debian_knowledge.call_dpkg) --purge";
      package_update_command =>  "$(debian_knowledge.call_dpkg) --install";
      package_patch_command =>  "$(debian_knowledge.call_dpkg) --install";
}

##

body package_method rpm_version(repo)
{
      package_changes => "individual";

      package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/yum --quiet check-update";
      package_list_update_ifelapsed => "240";

      package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s|]+).*";
      package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s|]+).*";
      package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";

      package_installed_regex => "i.*";

      package_file_repositories => { "$(repo)" };

      package_name_convention => "$(name)-$(version).$(arch).rpm";

      package_add_command => "/bin/rpm -ivh ";
      package_update_command => "/bin/rpm -Uvh ";
      package_patch_command => "/bin/rpm -Uvh ";
      package_delete_command => "/bin/rpm -e --nodeps";
      package_verify_command => "/bin/rpm -V";
      package_noverify_regex => ".*[^\s].*";
}

##

body package_method windows_feature
{
      package_changes => "individual";

      package_name_convention   => "$(name)";
      package_delete_convention => "$(name)";

      package_installed_regex => ".*";
      package_list_name_regex => "(.*)";
      package_list_version_regex => "(.*)";  # FIXME: the listing does not give version, so takes name for version too now

      package_add_command    => "$(sys.winsysdir)\\WindowsPowerShell\\v1.0\\powershell.exe -Command \"Import-Module ServerManager; Add-WindowsFeature -Name\"";
      package_delete_command => "$(sys.winsysdir)\\WindowsPowerShell\\v1.0\\powershell.exe -Command \"Import-Module ServerManager; Remove-WindowsFeature -confirm:$false -Name\"";
      package_list_command   => "$(sys.winsysdir)\\WindowsPowerShell\\v1.0\\powershell.exe -Command \"Import-Module ServerManager; Get-WindowsFeature | where {$_.installed -eq $True} |foreach {$_.Name}\"";
}

##

body package_method msi_implicit(repo)
# Use whole file name as promiser, e.g. "7-Zip-4.50-x86_64.msi",
# the name, version and arch is then deduced from the promiser
{
      package_changes => "individual";
      package_file_repositories => { "$(repo)" };

      package_installed_regex => ".*";

      package_name_convention => "$(name)-$(version)-$(arch).msi";
      package_delete_convention => "$(firstrepo)$(name)-$(version)-$(arch).msi";

      package_name_regex => "^(\S+)-(\d+\.?)+";
      package_version_regex => "^\S+-((\d+\.?)+)";
      package_arch_regex => "^\S+-[\d\.]+-(.*).msi";

      package_add_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /i";
      package_update_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /i";
      package_delete_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /x";
}

##

body package_method msi_explicit(repo)
# use software name as promiser, e.g. "7-Zip", and explicitly
# specify any package_version and package_arch
{
      package_changes => "individual";
      package_file_repositories => { "$(repo)" };

      package_installed_regex => ".*";

      package_name_convention => "$(name)-$(version)-$(arch).msi";
      package_delete_convention => "$(firstrepo)$(name)-$(version)-$(arch).msi";

      package_add_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /i";
      package_update_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /i";
      package_delete_command => "\"$(sys.winsysdir)\msiexec.exe\" /qn /x";
}

##

# This package_method uses yum to install, update and list packages.
#
# It will use "rpm -e" to remove packages. Please note that if several packages
# with the same name but varying versions or architectures are installed,
# "rpm -e" will return an error and not delete any of them.
body package_method yum
{
      package_changes => "bulk";
      package_list_command => "/usr/bin/yum --quiet list installed";
      package_patch_list_command => "/usr/bin/yum --quiet check-update";

      # Remember to escape special characters like |

      package_list_name_regex    => "([^.]+).*";
      package_list_version_regex => "[^\s]\s+([^\s]+).*";
      package_list_arch_regex    => "[^.]+\.([^\s]+).*";

      package_installed_regex => ".*(installed|\s+@).*";
      package_name_convention => "$(name)-$(version).$(arch)";

      # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
      package_delete_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/yum --quiet check-update";
      package_list_update_ifelapsed => "240";

      package_patch_installed_regex => "^\s.*";
      package_patch_name_regex    => "([^.]+).*";
      package_patch_version_regex => "[^\s]\s+([^\s]+).*";
      package_patch_arch_regex    => "[^.]+\.([^\s]+).*";

      package_add_command => "/usr/bin/yum -y install";
      package_update_command => "/usr/bin/yum -y update";
      package_patch_command => "/usr/bin/yum -y update";
      package_delete_command => "/bin/rpm -e --nodeps";
      package_verify_command => "/bin/rpm -V";
}

##

body package_method yum_rpm

# Contributed by Trond Hasle Amundsen
# More efficient package method for RPM-based systems - uses rpm
# instead of yum to list installed packages
#
# It will use "rpm -e" to remove packages. Please note that if several packages
# with the same name but varying versions or architectures are installed,
# "rpm -e" will return an error and not delete any of them.

{
      package_changes => "bulk";
      package_list_command => "/bin/rpm -qa --qf '%{name}.%{arch} %{version}-%{release}\n'";
      package_patch_list_command => "/usr/bin/yum --quiet check-update";

      package_list_name_regex    => "([^.]+).*";
      package_list_version_regex => "[^\s]\s+([^\s]+).*";
      package_list_arch_regex    => "[^.]+\.([^\s]+).*";

      package_installed_regex => ".*";
      package_name_convention => "$(name)-$(version).$(arch)";

      # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
      package_delete_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/yum --quiet check-update";
      package_list_update_ifelapsed => "240";

      package_patch_installed_regex => "^\s.*";
      package_patch_name_regex    => "([^.]+).*";
      package_patch_version_regex => "[^\s]\s+([^\s]+).*";
      package_patch_arch_regex    => "[^.]+\.([^\s]+).*";

      package_add_command    => "/usr/bin/yum -y install";
      package_update_command => "/usr/bin/yum -y update";
      package_patch_command  => "/usr/bin/yum -y update";
      package_delete_command => "/bin/rpm -e --nodeps";
      package_verify_command => "/bin/rpm -V";
}

##

body package_method yum_rpm_enable_repo(repoid)

# based on yum_rpm with addition to enable a repository for the install
# Sometimes repositories are configured but disabled by default. For example
# this pacakge_method could be used when installing a package that exists in
# the EPEL, which normally you do not want to install packages from.
{
      package_changes => "bulk";
      package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
      package_patch_list_command => "/usr/bin/yum --quiet check-update";

      package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
      package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
      package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";

      package_installed_regex => ".*";
      package_name_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/yum --quiet check-update";
      package_list_update_ifelapsed => "240";

      package_patch_installed_regex => "^\s.*";
      package_patch_name_regex    => "([^.]+).*";
      package_patch_version_regex => "[^\s]\s+([^\s]+).*";
      package_patch_arch_regex    => "[^.]+\.([^\s]+).*";

      package_add_command    => "/usr/bin/yum --enablerepo=$(repoid) -y install";
      package_update_command => "/usr/bin/yum --enablerepo=$(repoid) -y update";
      package_patch_command => "/usr/bin/yum -y update";
      package_delete_command => "/bin/rpm -e --nodeps --allmatches";
      package_verify_command => "/bin/rpm -V";
}

##

body package_method yum_group

# Makes use of the "groups of packages" feature of Yum possible. (yum groupinstall, groupremove)
#
# Groups must be specified by their groupids, available through yum grouplist -v (between parentheses)
# $ yum grouplist -v|grep Networking|head -n 1
#   Networking Tools (network-tools)       <--- network-tools is the groupid
#
# Policies examples:
#
# -Install "web-server" group:
# ----------------------------
#
# packages:
#   "web-server"
#     package_policy   =>  "add",
#     package_method   =>  yum_group;
#
# -Remove "debugging" and "php" groups:
# -------------------------------------
#
# vars:
#   "groups"  slist  => { "debugging", "php" };
#
# packages:
#   "$(groups)"
#      package_policy   =>   "delete",
#      package_method   =>   yum_group;
#

{ 
      package_add_command             =>  "/usr/bin/yum groupinstall -y";
      package_changes                 =>  "bulk";
      package_delete_command          =>  "/usr/bin/yum groupremove -y";
      package_delete_convention       =>  "$(name)";
      package_installed_regex         =>  "^i.*";

      # Generate a dpkg -l like listing, "i" means installed, "a" available, and a dummy version 1
      package_list_command            =>
      "/usr/bin/yum grouplist -v|awk '$0 ~ /^Done$/ {next} {sub(/.*\(/, \"\");sub(/\).*/, \"\")} /Available/ {h=\"a\";next} /Installed/ {h=\"i\";next} h==\"i\" || h==\"a\" {print h\" \"$0\" 1\"}'";

      package_list_name_regex         =>  "a|i ([^\s]+) 1";
      package_list_update_command     =>  "/usr/bin/yum --quiet check-update";
      package_list_update_ifelapsed   =>  "240";
      package_list_version_regex      =>  "(1)";
      package_name_convention         =>  "$(name)";
      package_name_regex              =>  "(.*)";
      package_noverify_returncode     =>  "0";
      package_update_command          =>  "/usr/bin/yum groupupdate";

      # grep -x to only get full line matching
      package_verify_command          => "/usr/bin/yum grouplist -v|awk '$0 ~ /^Done$/ {next} {sub(/.*\(/, \"\");sub(/\).*/, \"\")} /Available/ {h=\"a\";next} /Installed/ {h=\"i\";next} h==\"i\"|grep -qx";
}

##

body package_method rpm_filebased(path)

# Contributed by Aleksey Tsalolikhin. Written on 29-Feb-2012.
# Based on yum_rpm body in COPBL by Trond Hasle Amundsen.
# Purpose: install packages from local filesystem-based package repository.
# Note: Specify the path to the local package repository in the argument.

# Example of how to use it:
#
# ```cf3
# packages:
# "epel-release"
# package_policy => "add",
# package_version => "5-4",
# package_architectures => { "noarch" },
# package_method => rpm_filebased("/repo/RPMs");
# ```

{
      package_file_repositories => { "$(path)" };
      # the above is an addition to Trond's yum_rpm body

      package_add_command => "/bin/rpm -ihv ";
      # The above is a change from Trond's yum_rpm body, this makes the commands rpm only.
      # The reason I changed the install command from yum to rpm is yum will be default
      # refuse to install the epel-release RPM as it does not have the EPEL GPG key,
      # but rpm goes ahead and installs the epel-release RPM and the EPEL GPG key.

      package_name_convention => "$(name)-$(version).$(arch).rpm";
      # The above is a change from Tron's yum_rpm body. When package_file_repositories is in play,
      # package_name_convention has to match the file name, not the package name, per the
      # CFEngine 3 Reference Manual

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/yum --quiet check-update";
      package_list_update_ifelapsed => "240";

      # The rest is unchanged from Trond's yum_rpm body
      package_changes => "bulk";
      package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";

      package_list_name_regex => "^(\S+?)\s\S+?\s\S+$";
      package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
      package_list_arch_regex => "^\S+?\s\S+?\s(\S+)$";

      package_installed_regex => ".*";


      package_delete_command => "/bin/rpm -e --allmatches";
      package_verify_command => "/bin/rpm -V";
}

##

# OpenSolaris based systems (Solaris 11, Illumos, etc) use the much better
# Image Package System.
#
# A note about Solaris 11.1 versioning format:
#
# $ pkg list -v --no-refresh zsh
# FMRI                                                                         IFO
# pkg://solaris/shell/zsh@4.3.17,5.11-0.175.1.0.0.24.0:20120904T174236Z        i--
# name--------- |<----->| |/________________________\|
# version---------------- |\                        /|
#
# Notice that the publisher and timestamp aren't used. And that the package
# version then must have the commas replaced by underscores.
#
# Thus,
#     4.3.17,5.11-0.175.1.0.0.24.0
# Becomes:
#     4.3.17_5.11-0.175.1.0.0.24.0
#
# Therefore, a properly formatted package promise looks like this:
#    "shell/zsh"
#      package_policy  => "addupdate",
#      package_method  => ips,
#      package_select  => ">=",
#      package_version => "4.3.17_5.11-0.175.1.0.0.24.0";

body package_method ips
{
      package_changes => "bulk";
      package_list_command => "/usr/bin/pkg list -v --no-refresh";
      package_list_name_regex    => "pkg://.+?(?<=/)([^\s]+)@.*$";
      package_list_version_regex => "[^\s]+@([^\s]+):.*";
      package_installed_regex => ".*(i..)"; # all reported are installed

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/pkg refresh --full";
      package_list_update_ifelapsed => "240";

      package_add_command => "/usr/bin/pkg install --accept ";
      package_delete_command => "/usr/bin/pkg uninstall";
      package_update_command =>  "/usr/bin/pkg install --accept";
      package_patch_command =>  "/usr/bin/pkg install --accept";
      package_verify_command =>  "/usr/bin/pkg list -a -v --no-refresh";
      package_noverify_regex => "(.*---|pkg list: no packages matching .* installed)";
}

##

# SmartOS (solaris 10 fork by Joyent) uses pkgin

body package_method smartos
{
      package_changes => "bulk";
      package_list_command => "/opt/local/bin/pkgin list";
      package_list_name_regex    => "(.*)\-[0-9]+.*";
      package_list_version_regex => ".*\-([0-9][^\s]+).*";

      package_installed_regex => ".*"; # all reported are installed

      package_list_update_command => "/opt/local/bin/pkgin -y update";
      package_list_update_ifelapsed => "240";

      package_add_command => "/opt/local/bin/pkgin -y install";

      package_delete_command => "/opt/local/bin/pkgin -y remove";
      package_update_command =>  "/opt/local/bin/pkgin upgrade";
}

# OpenCSW (Solaris software packages)

body package_method opencsw
{
      package_changes => "bulk";
      package_list_command => "/opt/csw/bin/pkgutil -c";
      package_list_name_regex    => "CSW(.*?)\s.*";
      package_list_version_regex => ".*?\s+(.*),.*";

      package_installed_regex => ".*"; # all reported are installed

      package_list_update_command => "/opt/csw/bin/pkgutil -U";
      package_list_update_ifelapsed => "240";

      package_add_command => "/opt/csw/bin/pkgutil -yi";

      package_delete_command => "/opt/csw/bin/pkgutil -yr";
      package_update_command =>  "/opt/csw/bin/pkgutil -yu";
}

# The older solaris package system is poorly designed, with too many different
# names to track. See the example in tests/units/unit_package_solaris.cf
# to see how to use this

body package_method solaris (pkgname, spoolfile, adminfile)
{
      package_changes => "individual";
      package_list_command => "/usr/bin/pkginfo -l";
      package_multiline_start    =>  "\s*PKGINST:\s+[^\s]+.*";
      package_list_name_regex    => "\s*PKGINST:\s+([^\s]+).*";
      package_list_version_regex => "\s*VERSION:\s+([^\s]+).*";
      package_list_arch_regex    => "\s*ARCH:\s+([^\s]+)";
      package_installed_regex => "\s*STATUS:\s*(completely|partially)\s+installed.*";
      package_name_convention => "$(name)";
      package_add_command => "/usr/sbin/pkgadd -n -a /tmp/$(adminfile) -d /tmp/$(spoolfile)";
      package_delete_command => "/usr/sbin/pkgrm -n -a /tmp/$(adminfile)";
}

##

#
# The following bundle is part of a package setup for solaris, see unit examples
#

bundle edit_line create_solaris_admin_file
{
  insert_lines:

      "mail=
instance=unique
partial=nocheck
runlevel=nocheck
idepend=nocheck
rdepend=nocheck
space=nocheck
setuid=nocheck
conflict=nocheck
action=nocheck
networktimeout=60
networkretries=3
authentication=quit
keystore=/var/sadm/security
proxy=
basedir=default"
      comment => "Insert contents of Solaris admin file (automatically install packages)";
}

##

body package_method freebsd
{
      package_changes => "individual";

      # Could use rpm for this
      package_list_command => "/usr/sbin/pkg_info";

      # Remember to escape special characters like |

      package_list_name_regex    => "([^\s]+)-.*";
      package_list_version_regex => "[^\s]+-([^\s]+).*";

      package_name_regex    => "([^\s]+)-.*";
      package_version_regex => "[^\s]+-([^\s]+).*";

      package_installed_regex => ".*";

      package_name_convention => "$(name)-$(version)";


      package_add_command => "/usr/sbin/pkg_add -r";
      package_delete_command => "/usr/sbin/pkg_delete";
}

body package_method freebsd_portmaster
{
      package_changes => "individual";

      package_list_command => "/usr/sbin/pkg_info";

      package_list_name_regex    => "([^\s]+)-.*";
      package_list_version_regex => "[^\s]+-([^\s]+).*";

      package_installed_regex => ".*";

      package_name_convention => "$(name)";
      package_delete_convention => "$(name)-$(version)";

      package_file_repositories => {
				     "/usr/ports/accessibility/",
				     "/usr/port/arabic/",
				     "/usr/ports/archivers/",
				     "/usr/ports/astro/",
				     "/usr/ports/audio/",
				     "/usr/ports/benchmarks/",
				     "/usr/ports/biology/",
				     "/usr/ports/cad/",
				     "/usr/ports/chinese/",
				     "/usr/ports/comms/",
				     "/usr/ports/converters/",
				     "/usr/ports/databases/",
				     "/usr/ports/deskutils/",
				     "/usr/ports/devel/",
				     "/usr/ports/dns/",
				     "/usr/ports/editors/",
				     "/usr/ports/emulators/",
				     "/usr/ports/finance/",
				     "/usr/ports/french/",
				     "/usr/ports/ftp/",
				     "/usr/ports/games/",
				     "/usr/ports/german/",
				     "/usr/ports/graphics/",
				     "/usr/ports/hebrew/",
				     "/usr/ports/hungarian/",
				     "/usr/ports/irc/",
				     "/usr/ports/japanese/",
				     "/usr/ports/java/",
				     "/usr/ports/korean/",
				     "/usr/ports/lang/",
				     "/usr/ports/mail/",
				     "/usr/ports/math/",
				     "/usr/ports/mbone/",
				     "/usr/ports/misc/",
				     "/usr/ports/multimedia/",
				     "/usr/ports/net/",
				     "/usr/ports/net-im/",
				     "/usr/ports/net-mgmt/",
				     "/usr/ports/net-p2p/",
				     "/usr/ports/news/",
				     "/usr/ports/packages/",
				     "/usr/ports/palm/",
				     "/usr/ports/polish/",
				     "/usr/ports/ports-mgmt/",
				     "/usr/ports/portuguese/",
				     "/usr/ports/print/",
				     "/usr/ports/russian/",
				     "/usr/ports/science/",
				     "/usr/ports/security/",
				     "/usr/ports/shells/",
				     "/usr/ports/sysutils/",
				     "/usr/ports/textproc/",
				     "/usr/ports/ukrainian/",
				     "/usr/ports/vietnamese/",
				     "/usr/ports/www/",
				     "/usr/ports/x11/",
				     "/usr/ports/x11-clocks/",
				     "/usr/ports/x11-drivers/",
				     "/usr/ports/x11-fm/",
				     "/usr/ports/x11-fonts/",
				     "/usr/ports/x11-servers/",
				     "/usr/ports/x11-themes/",
				     "/usr/ports/x11-toolkits/",
				     "/usr/ports/x11-wm/",
      };

      package_add_command => "/usr/local/sbin/portmaster -D -G --no-confirm";
      package_update_command => "/usr/local/sbin/portmaster -D -G --no-confirm";
      package_delete_command => "/usr/local/sbin/portmaster --no-confirm -e";
}

##

body package_method alpinelinux
{
      package_changes => "bulk";
      package_list_command => "/sbin/apk info -v";
      package_list_name_regex    => "([^\s]+)-.*";
      package_list_version_regex => "[^\s]+-([^\s]+).*";
      package_name_regex    => ".*";
      package_installed_regex => ".*";
      package_name_convention => "$(name)";
      package_add_command => "/sbin/apk add";
      package_delete_command => "/sbin/apk del";
}

##

body package_method emerge
{
      package_changes => "individual";
      package_list_command => "/bin/sh -c '/bin/ls -d /var/db/pkg/*/* | cut -c 13-'";
      package_list_name_regex => ".*/([^\s]+)-\d.*";
      package_list_version_regex => ".*/[^\s]+-(\d.*)";
      package_installed_regex => ".*";                          # all reported are installed
      package_name_convention => "$(name)";
      package_list_update_command => "/bin/true";               # I prefer manual syncing
      #package_list_update_command => "/usr/bin/emerge --sync"; # if you like automatic
      package_list_update_ifelapsed => "240";                   # should happen every 4 hours

      package_add_command => "/usr/bin/emerge -q --quiet-build";
      package_delete_command => "/usr/bin/emerge --depclean";
      package_update_command => "/usr/bin/emerge --update";
      package_patch_command => "/usr/bin/emerge --update";
      package_verify_command => "/usr/bin/emerge -s";
      package_noverify_regex => ".*(Not Installed|Applications found : 0).*";
}

##

body package_method pacman

{
      package_changes => "bulk";

      package_list_command => "/usr/bin/pacman -Q";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_ifelapsed => "240";

      package_list_name_regex    => "(.*)\s+.*";
      package_list_version_regex => ".*\s+(.*)";
      package_installed_regex => ".*";

      package_name_convention => "$(name)";
      package_add_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
      package_delete_command => "/usr/bin/pacman -Rs --noconfirm";
      package_update_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
}

##

# Single bundle for all the similar managers simplifies promises

body package_method generic
{
    SuSE::
      package_changes => "bulk";
      package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";
      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "/usr/bin/zypper list-updates";
      package_list_update_ifelapsed => "0";
      package_patch_list_command => "/usr/bin/zypper patches";
      package_installed_regex => "i.*";
      package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s]+).*";
      package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
      package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
      package_patch_installed_regex => ".*Installed.*|.*Not Applicable.*";
      package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
      package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
      package_name_convention => "$(name)";
      package_add_command => "/usr/bin/zypper --non-interactive install";
      package_delete_command => "/usr/bin/zypper --non-interactive remove --force-resolution";
      package_update_command => "/usr/bin/zypper --non-interactive update";
      package_patch_command => "/usr/bin/zypper --non-interactive patch$"; # $ means no args
      package_verify_command => "/usr/bin/zypper --non-interactive verify$";

    redhat::
      package_changes => "bulk";
      package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
      package_patch_list_command => "/usr/bin/yum --quiet check-update";
      package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
      package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
      package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
      package_installed_regex => ".*";
      package_name_convention => "$(name)";
      package_list_update_command => "/usr/bin/yum --quiet check-update";
      package_list_update_ifelapsed => "0";     # sometimes, caching is pretty disturbing
      package_patch_installed_regex => "^\s.*";
      package_patch_name_regex    => "([^.]+).*";
      package_patch_version_regex => "[^\s]\s+([^\s]+).*";
      package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
      package_add_command    => "/usr/bin/yum -y install";
      package_update_command => "/usr/bin/yum -y update";
      package_patch_command => "/usr/bin/yum -y update";
      package_delete_command => "/bin/rpm -e --nodeps --allmatches";
      package_verify_command => "/bin/rpm -V";

      # package_changes => "bulk";
      # package_list_command => "/usr/bin/yum list installed";
      # package_patch_list_command => "/usr/bin/yum check-update";
      # package_list_name_regex    => "([^.]+).*";
      # package_list_version_regex => "[^\s]\s+([^\s]+).*";
      # package_list_arch_regex    => "[^.]+\.([^\s]+).*";
      # package_installed_regex => ".*(installed|\s+@).*";
      # package_name_convention => "$(name).$(arch)";
      # package_list_update_ifelapsed => "240";
      # package_patch_installed_regex => "^\s.*";
      # package_patch_name_regex    => "([^.]+).*";
      # package_patch_version_regex => "[^\s]\s+([^\s]+).*";
      # package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
      # package_add_command => "/usr/bin/yum -y install";
      # package_delete_command => "/bin/rpm -e --nodeps";
      # package_verify_command => "/bin/rpm -V";

    debian::
      package_changes => "bulk";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";
      package_list_name_regex    => ".i\s+([^\s]+).*";
      package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
      package_name_convention => "$(name)";
      package_list_update_ifelapsed => "240";		# 4 hours

    debian.have_aptitude::
      package_add_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_list_update_command => "/usr/bin/aptitude update";
      package_delete_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes remove";
      package_update_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_patch_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_verify_command =>  "/usr/bin/aptitude show";
      package_noverify_regex => "(State: not installed|E: Unable to locate package .*)";

      package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

    debian.!have_aptitude::
      package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes remove";
      package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_verify_command => "$(debian_knowledge.call_dpkg) -s";
      package_noverify_returncode => "1";

      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
      package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

    freebsd::
      package_changes => "individual";
      package_list_command => "/usr/sbin/pkg_info";
      package_list_name_regex    => "([^\s]+)-.*";
      package_list_version_regex => "[^\s]+-([^\s]+).*";
      package_name_regex    => "([^\s]+)-.*";
      package_version_regex => "[^\s]+-([^\s]+).*";
      package_installed_regex => ".*";
      package_name_convention => "$(name)-$(version)";
      package_add_command => "/usr/sbin/pkg_add -r";
      package_delete_command => "/usr/sbin/pkg_delete";

    alpinelinux::
      package_changes => "bulk";
      package_list_command => "/sbin/apk info -v";
      package_list_name_regex    => "([^\s]+)-.*";
      package_list_version_regex => "[^\s]+-([^\s]+).*";
      package_name_regex    => ".*";
      package_installed_regex => ".*";
      package_name_convention => "$(name)";
      package_add_command => "/sbin/apk add";
      package_delete_command => "/sbin/apk del";

    gentoo::
      package_changes => "individual";
      package_list_command => "/bin/sh -c '/bin/ls -d /var/db/pkg/*/* | cut -c 13-'";
      package_list_name_regex => ".*/([^\s]+)-\d.*";
      package_list_version_regex => ".*/[^\s]+-(\d.*)";
      package_installed_regex => ".*";                          # all reported are installed
      package_name_convention => "$(name)";
      package_list_update_command => "/bin/true";               # I prefer manual syncing
      #package_list_update_command => "/usr/bin/emerge --sync"; # if you like automatic
      package_list_update_ifelapsed => "240";                   # should happen every 4 hours

      package_add_command => "/usr/bin/emerge -q --quiet-build";
      package_delete_command => "/usr/bin/emerge --depclean";
      package_update_command => "/usr/bin/emerge --update";
      package_patch_command => "/usr/bin/emerge --update";
      package_verify_command => "/usr/bin/emerge -s";
      package_noverify_regex => ".*(Not Installed|Applications found : 0).*";

    archlinux::
      package_changes => "bulk";
      package_list_command => "/usr/bin/pacman -Q";
      package_list_name_regex    => "(.*)\s+.*";
      package_list_version_regex => ".*\s+(.*)";
      package_installed_regex => ".*";
      package_name_convention => "$(name)";
      package_list_update_ifelapsed => "240";
      package_add_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
      package_delete_command => "/usr/bin/pacman -Rs --noconfirm";
      package_update_command => "/usr/bin/pacman -S --noconfirm --noprogressbar --needed";
}

##
