#######################################################
#
# Test that mustache DTRT when encountering string when expects list. Also
# check that after mustache template is applied you have a different inode
# (indicating you wrote to a different file and moved into place) 
#
#######################################################

body common control
{
      inputs => { "../../default.cf.sub" };
      bundlesequence  => { default("$(this.promise_filename)") };
      version => "1.0";

}

#######################################################

bundle agent init
{
  vars:
    init_testfile_ok::
      "testfile_inode" string => filestat($(G.testfile), "ino");

  files:
      "$(G.testfile)"
        create => "true",
        edit_defaults => test_empty, 
        classes => test_classes_generic("init_testfile"),
        edit_line => init_insert_lines("# Some pre-existing content");

}

bundle edit_line init_insert_lines(lines)
{
  insert_lines:

      "$(lines)"
      comment => "Append lines if they don't exist";
}

#######################################################

bundle agent test
{
  vars:
      "template" string => "$(this.promise_filename).mustache";
      # This generates an error rendering, but the render continues anyway
      "template_data" string => '{"mykeys": "string but template expects list of strings"}';
      
      # This works, and produces no error
      #"template_data" string => '{"mykeys": ["string but template expects list of strings"]}';

    test_testfile_ok::
      "testfile_inode" string => filestat($(G.testfile), "ino");

  files:
      "$(G.testfile)"
        create => "true",
        edit_defaults => test_empty,
        classes => test_classes_generic("test_testfile"),
        edit_template => "$(template)",
        template_method => "mustache",
        template_data => parsejson($(template_data));

  reports:
    DEBUG::
      "Rendering template file $(template) to $(G.testfile)";
}

body edit_defaults test_empty
{
      empty_file_before_editing => "true";
      edit_backup => "false";
}

body classes test_classes_generic(x)
{
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_not_repaired", "$(x)_reached" };
}


#######################################################

bundle agent check
{
  vars:
      "expected" string => "#DO NOT EDIT - MANAGED FILE
string but template expects list of strings$(const.n)";

      "actual" string => readfile("$(G.testfile)", 4096);

      "testfile_inode" string => filestat($(G.testfile), "ino");

  classes:
      "ok_different_inode" not => strcmp("$(testfile_inode)", "$(init.testfile_inode)");

      "ok_content" expression => regcmp("$(expected)", "$(actual)");

      "ok" and => { ok_different_inode, ok_content };

  reports:
    DEBUG::
      "OK: Expected  '$(expected)' == '$(actual)'"
      ifvarclass => "ok_content";

      "OK: Expected different inode for $(G.testfile) in init and check after template rendering. init:$(init.testfile_inode) != check:$(testfile_inode)"
      ifvarclass => "ok_different_inode";

      "FAIL: Expected '$(expected)' <> '$(actual)'"
      ifvarclass => "!ok_content";

      "FAIL: Expected different inode for $(G.testfile) in init and check after template rendering. init:$(init.testfile_inode) == check:$(testfile_inode)"
      ifvarclass => "!ok_different_inode";

    ok::
      "$(this.promise_filename) Pass";
    !ok::
      "$(this.promise_filename) FAIL";
}
### PROJECT_ID: core
### CATEGORY_ID: 27
