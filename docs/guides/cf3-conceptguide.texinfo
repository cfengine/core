\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{CFEngineFrontPage}

@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename cf3-conceptguide.info
@settitle CFEngine 3 Concept Guide
@setchapternewpage odd
@c %** end of header

@titlepage
@title CFEngine 3 Concept Guide
@subtitle A CFEngine AS workbook
@author CFEngine AS

@c @smallbook


@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2011 CFEngine AS

@end titlepage


@c *************************** File begins here ************************


@ifinfo
@dircategory CFEngine Training
@direntry
* CFEngine Modularization:
                      CFEngine is a language based tool specifically
                      designed for configuring and maintaining
                      Unix-like operating systems attached
                      to a TCP/IP network.
@end direntry
@end ifinfo

@ifnottex
@node Top, Introduction - System automation, (dir), (dir)
@top CFEngine Concepts
@end ifnottex
@iftex
@contents
@end iftex

@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>
@end html
@end ifhtml

@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@i{This document is an abbreviated version of the CFEngine tutorial (http://cfengine.com/manuals/cf3-tutorial.html).}

@c **********************************************************************
@menu
* Introduction - System automation::           
* The components of CFEngine::  
* Bodies and bundles::          
* A simple crash course in concepts::  
* Knowledge Management::        
@end menu

@node Introduction - System automation, The components of CFEngine, Top, Top
@chapter Introduction - System automation

@menu
* Managing diverse and challenging environments seamlessly and invisibly::  
* Managing expectations - a theory of promises::  
* Why automation?::             
* How do you view CFEngine::    
@end menu

@node Managing diverse and challenging environments seamlessly and invisibly, Managing expectations - a theory of promises, Introduction - System automation, Introduction - System automation
@section Managing diverse and challenging environments seamlessly and invisibly

CFEngine was designed to enable scalable configuration management, for  
the
whole system life-cycle, in any kind of environment.
Almost every other system for configuration assumes that there will be
a reliable network in place and that changes will be pushed out
top-down from an authoritative node. Those systems are useless in
environments like

@itemize
@item Mobile systems with partial or unreliable connectivity (e.g. a  
submarine).
@item Systems where bandwidths are very low (e.g. a satellite or space  
probe).
@item Systems where computing power is very low (e.g. ad hoc sensors  
or kitchen appliances).
@end itemize

CFEngine does not need reliable infrastructure. It works
opportunistically in almost any environment, using few resources. It
has few software dependencies.  So, not only does it work in all of the
traditional fixed-plan scenarios, but it is capable of working in
totally ad hoc deployment: an temporary incident room, a submarine
drifting on and off line, a satellite or a robot explorer.

One could argue `well I don't need that kind of system, because my
network is reliable'. However, your network is not as reliable as you
think, and mobility is an increasingly important topic. Even with a
very strong redundant network, the services that support the network
can be paralyzed by any of a number of failed dependencies or
mishaps. It is crucial in a modern pervasive environment that systems
remain available, fault tolerant and as far as possible independent of
external requirements. This is how to build scalable and reliable
services.

@cartouche
CFEngine works in all the places you think it should, and all the new
places you haven't even thought of yet. How do we know? Because it
is based on almost 20 years of careful research and experience.
@end cartouche


@c --------------------------------------------------------------
@node Managing expectations - a theory of promises, Why automation?, Managing diverse and challenging environments seamlessly and invisibly, Introduction - System automation
@section Managing expectations - a theory of promises

One of the hardest things in management is to make everyone aware of
their roles and tasks, and to be able to rely on others to do the same.
@i{Trust} is an economic time-saver. If you can't trust you have to  
verify,
and that is expensive.

To improve trust we make promises. A promise is the documentation of an
intention to act or behave in some manner. This is what we need to  
learn to
trust systems, no matter whether they are machines or humans.

One CFEngine user once said to me, that the thing that had helped him
the most in deploying CFEngine was its design based around voluntary
cooperation. ``Our main problems were not technical but political --
getting everyone to agree in all of our departments around the
world''.  This was because, for all the technology, it is people who
make the decisions and people need to feel that the system is
empowering rather than disempowering them.

@cartouche

CFEngine works on a simple notion of promises. Everything in
CFEngine can be thought of as a promise to be kept by different
resources in the system.

Combining promises with patterns to describe where and when
promises should apply is what CFEngine is all about.

@end cartouche


@c --------------------------------------------------------------
@node Why automation?, How do you view CFEngine, Managing expectations - a theory of promises, Introduction - System automation
@section Why automation?


Humans are good at making decisions and awful at reliable
implementation.  Machines are pitiful at making decisions and very
good at reliable implementation. It makes sense to let each side do
the job that they are good at.

The main problem in managing systems is a loss of self-discipline.  
Discipline
does not imply that orders have to be barked from a central command. It
only requires that every part of the system knows its job and carries
it out seamlessly and flawlessly.

Skilled workers tend to think that it is enough to be smart. In fact
this is wrong: smart people tend to be problem solvers and will
happily solve the same problem many times, wasting time and
effort. Moreover, human intervention is often based on panic and lack
of understanding so every time someone logs onto a system by hand,
they jeopardize everyone's understanding of the system.  Only the
self-discipline of stable procedures leads to predictability.

Ad hoc changes are bad because:
@itemize
@item Others have no idea what happened.
@item There is no record of changes or intentions.
@item A scar is left from the change.
@end itemize


People often rile against automation saying that it dehumanizes their
work.  In fact the opposite is true: forcing humans to do the work of
machines, in repetitive and reliable ways is what dehumanizes people.
The only way to make progress with a bad habit is to recognize it and
be willing to abandon the habit.


@c --------------------------------------------------------------
@node How do you view CFEngine, , Why automation?, Introduction - System automation
@section How do @i{you} view CFEngine?

CFEngine is a framework. It is not so complex, but it is certainly  
extensive.
Often when trying to describe CFEngine, it seems that there is too  
much to
tell and it is hard to convey in a simple way what the software can do.
The picture below shows a few ways in which you can think of CFEngine.

@center @image{boxes,12cm,,CFEngine application areas,png}

For many users, CFEngine is simply a configuration tool --
i.e. software for deploying and patching systems according to a
policy. Policy is described using promises -- indeed, every statement
in CFEngine 3 is a promise to be kept at some time or location.  More
than this, however, CFEngine is not like most automation tools that
`roll out' an image of some software once and hope for the best. Every
promise that you make in CFEngine is continuously verified and
maintained. It is not a one-off operation, but an encapsulated process
that repairs itself should anything deviate from the policy.

That clearly places CFEngine in the realm of automation, which often
begs the question: so it's just another scripting language? Certainly
CFEngine contains a powerful scripting language, but it is not like
any other. CFEngine is not a low level language like Perl, Python or
Ruby; it is a language of promises, in which you express very high
level intentions about the system and the inner details figure out the
algorithms needed to implement the result.

Above all, CFEngine is aimed to promote human understanding of complex
processes. Its promises are easily documentable using comments that
the system remembers and reminds us about in error reporting. It hides
irrelevant and transitory details of implementation so that the
@i{intentions} behind the promises are highlighted for all to see.
This means that the knowledge of your organization can be encoded into
the CFEngine language.

@cartouche
@i{WHY DOES KNOWLEDGE MATTER? 1. Technical descriptions are hard to remember. You might understand
your configuration decisions when you are writing them, but a few
months later when something goes wrong, you will probably have forgotten
what you were thinking. That costs you time and effort to diagnose.
2. Organizations are fragile to the loss
of those individuals who code policy. If they leave, often there is
no one left who can understand or fix the system. Only with proper
documentation is it possible to immunize against loss.}
@end cartouche





@c *****************************************************
@c * CHAPTER
@c *****************************************************

@node The components of CFEngine, Bodies and bundles, Introduction - System automation, Top
@chapter The components of CFEngine

CFEngine comprises a number of components. In this chapter we'll  
consider how to
build them and what they are for.


@menu
* The players::                 
* About the CFEngine architecture::  
* The policy decision flow::    
@end menu


@node The players, About the CFEngine architecture, The components of CFEngine, The components of CFEngine
@section The players

A CFEngine system is something like an orchestra.
It is composed of any number of computers (players), each of which has  
its
own copy of the music and knows what to play. It might or might not have
a conductor to help coordinate the individual parts -- that's up to you.

CFEngine's software agents are independent components that run on each individual computer. They can
communicate if they need to, as depicted in the figure below. This means
you don't have to arrange risky login credentials to run your network
-- and if something goes wrong with the communications network,
CFEngine is where it needs to be to repair or protect the system
during the outage.

@image{components,10cm,,CFEngine components,png}

If the network is not working, CFEngine just skips these parts and  
continues
with what it can do. It is fault tolerant and opportunistic.

@table @emph

@item cf-promises
The promise verifier and compiler. This is used to pre-check a set of
configuration promises before attempting to execute.

@item cf-agent

This is the instigator of change. The agent is the part of CFEngine  
that manipulates
system resources.

@item cf-serverd

The server is able to share files and receive requests to execute
existing policy on an individual machine. It is not possible to send
(push) new information to CFEngine from outside.

@item cf-execd

This is a scheduling daemon (which can either supplement or replace
@code{cron}). It also works as a wrapper, executing and collecting the
output of @code{cf-agent} and E-mailing it if necessary to a system  
account.

@item cf-runagent

This is a helper program that can talk to @code{cf-serverd} and
request that it execute @code{cf-agent} with its existing policy. It
can thus be used to simulate a push of changes to CFEngine hosts, if
their policy includes that they check for updates.

@item cf-report

This generates summary and other reports in a variety of formats for
export or integration with other systems.

@item cf-know

This agent can generate an ISO standard Topic Map from a number of
promises about system knowledge. It is used for rendering documentation
as a `semantic web'.

@end table



@c -------------------------------------------------------------------------
@node About the CFEngine architecture, The policy decision flow, The players, The components of CFEngine
@section About the CFEngine architecture

This section explains how CFEngine will operate autonomously in a
network, under your guidance.  If your site is large (thousands of
servers) you should spend some time discussing with CFEngine experts
how to tune this description to your environment as @emph{scale}
requires you to have more infrastructure, and a potentially more
complicated configuration. The essence of any CFEngine deployment
is the same.



There are four commonly cited phases in managing systems, summarized
as follows:

@itemize
@item Build
@item Deploy
@item Manage
@item Audit
@end itemize

These separate phases originate with a model of system management
based on transactional changes.  CFEngine's conception of management
is somewhat different, as transaction processing is not a good model for
system management, but we can use this template to see how
CFEngine works differently.

@table @emph
@item Build
A system is based on a number of decisions and resources that need to
be `built' before they can be implemented. Building the trusted
foundations of a system is the key to guiding its development.  You
don't need to decide every detail, just enough to build trust and
predictability into your system.

In CFEngine, what you build is a template of proposed promises for the
machines in an organization such that, if the machines all make and
keep these promises, the system will function seamlessly as
planned. This is how it works in a human organization, and this is how
is works for computers too.

@item Deploy
Deploying really means implementing the policy that was already
decided.  In transaction systems, one tries to push out changes one by
one, hence `deploying' the decision. In CFEngine you simply publish
your policy (in CFEngine parlance these are `promise proposals') and
the machines see the new proposals and can adjust accordingly. Each
machine runs an agent that is capable of implementing policies and
maintaining them over time without further assistance.

@item Manage
Once a decision is made, unplanned events will occur. Such
incidents traditionally set off alarms and humans rush to make new  
transactions
to repair them. In CFEngine, the autonomous agent manages the system,
and you only have to deal with rare events that cannot be dealt with
automatically.

@item Audit
In traditional configuration systems, the outcome is far from clear
after a one-shot transaction, so one audits the system
to determine what actually happened. In CFEngine, changes
are not just initiated once, but locally audited and maintained.
Decision outcomes are assured by design in CFEngine and maintained
automatically, so the main worry is managing conflicting
intentions. Users can sit back and examine regular reports of
compliance generated by the agents, without having to arrange
for new `roll out' transactions.

@end table

@cartouche
@emph{ROLL-OUT and ROLL-BACK?  You should not think of CFEngine as a
roll-out system, i.e. one that attempts to force out absolute changes
and perhaps reverse them in case of error. Roll-out and roll-back are
theoretically flawed concepts that only sometimes work in practice.
With CFEngine, you publish a sequence of policy revisions, always
moving forward (because like it or not, time only goes in one
direction).  All of the desired-state changes are managed locally by
each individual computer, and continuously repaired to ensure on-going
compliance with policy. }
@end cartouche


@c ------------------------------------------------------------------
@node The policy decision flow, , About the CFEngine architecture, The components of CFEngine
@section The policy decision flow

CFEngine does not make absolute choices for you, like other
tools. Almost everything about its behavior is matter of policy and
can be changed.  However, a structure for use, like the following, is
recommended (see the following figure).

In order to keep operations as simple as possible, CFEngine maintains
a private working directory on each machine referred to in
documentation as WORKDIR and in policy by the variable
@code{$(sys.workdir)}. By default, this is located at
@file{/var/cfengine} or @file{C:\var\CFEngine}. It contains everything
CFEngine needs to run.

The figure below shows how decisions flow through the parts of a system.

@image{arch,15cm,,The CFEngine architecture,png}


@itemize
@item
It makes sense to have a single point of coordination.  Decisions are
therefore usually made in a single location (the Policy Definition
Point).  The history of decisions and changes can be tracked by a
version control system of your choice (e.g. Subversion, CVS, etc.).

@item
Decisions are made by editing CFEngine's policy file
@file{promises.cf} (or one of its included sub-files). This process is
carried out off-line.

@item
Once decisions have been formalized and coded, this new policy is
copied @emph{manually} (a human decision) to a @emph{decision
distribution point}, which by default is located in the directory
@file{/var/cfengine/masterfiles} on all policy distribution servers.

In this introduction, we shall assume that there is only one central
policy distribution server, a specially-appointed server which is
referred to simple as the @code{policy server}.


@item
Every client machine contacts the policy server and downloads these
updates. The policy server can be replicated if the number of clients
is very large, but we shall assume here that there is only one policy
server.
@end itemize

Once a client machine has a copy of the policy, it extracts only those
promise proposals that are relevant to it, and implements any changes
without human assistance.  This is how CFEngine manages change.

@cartouche

@emph{WHY DO THIS? CFEngine tries to minimize dependencies by decoupling
processes. By following this pull-based architecture, CFEngine will
tolerate network outages and will recover from deployment errors
easily. By placing the burden of responsibility for decision at the
top, and for implementation at the bottom, we avoid needless fragility
and keep two independent quality assurance processes apart.}

@end cartouche



@c *****************************************************
@c * CHAPTER
@c *****************************************************

@node Bodies and bundles, A simple crash course in concepts, The components of CFEngine, Top
@chapter Bodies and bundles

To emphasize the fact that CFEngine is not an imperative programming
language, and to keep closely to the nomenclature of Promise Theory,
CFEngine uses two concepts throughout: bundles and bodies.


@menu
* Bodies::                      
* Bundles::                     
* A simple syntax pattern::     
@end menu

@node Bodies, Bundles, Bodies and bundles, Bodies and bundles
@section Bodies

Promises are the fundamental statements in CFEngine. Promises are the policy atoms.
If there is no promise, nothing happens.

However, promises can become quite complicated and readability becomes
an issue, so it is useful to have a way of breaking them down into independent
components. The structure of a promise is this:

@table @i
@item Promiser
This is the object that formally makes the promise. It is always the @i{affected object},
since objects can only make promises about their own state or behavior in CFEngine.

@item Promisee (optional)
This is a possible stakeholder, someone who is interested in the outcome of the
promise. It is used as documentation, and it is used for reasoning in the commercial
CFEngine product.

@item Promise body
Everything else about a promise is defined in the body of the promise. 
We use this word in the sense of `body of a contract' or the `body of a document'
(like @code{<body>}) tags in HTML, for example.

A promise body is a list of declarations of the following form:

@verbatim
CFEngine_attribute_type => user_defined_value or template
@end verbatim

@end table

@menu
* Body parts::                  
* Control bodies::              
@end menu

@node Body parts, Control bodies, Bodies, Bodies
@subsection Body parts

The CFEngine reserved word @code{body} is used to define
@i{parameterized templates} for bodies to hide the details of complex
promise specifications. For complex body lists, you must fill in a
body declaration as an `attachment' to the promise, e.g.

@verbatim
files:

  "/tmp/promiser"        # Promiser

    perms => myexample;  # The body is just one line, 
                         # but needs an attachment

@end verbatim
The attachment is declared like this, with a `type' that matches the left
hand side of the declaration in the promise:
@verbatim
body perms myexample
{
mode => "644";
owners => { "mark", "sarah", "angel" };
groups => { "users", "sysadmins", "mythical_beasts" };
}
@end verbatim
The structure is this:

@sp 1
@cartouche
@smallexample

  @var{promiser}

    @b{LVALUE} => @var{RVALUE}

..

body @b{LVALUE} @var{RVALUE}
@{
@b{LVALUE} => @var{RVALUE};
@b{LVALUE} => @var{RVALUE};
@}
@end smallexample
@end cartouche
@sp 1

Another way of looking at it is this:

@sp 1
@cartouche
@smallexample

  @var{promiser}

    @b{CFEngine_word} => @var{user_defined_value}

..

 body @b{CFEngine_word} @var{user_defined_value}
 @{
 @b{CFEngine_word} => @var{user_defined_value};
 @b{CFEngine_word} => @var{user_defined_value};
 ...
 @}

@end smallexample
@end cartouche
@sp 1

Body attachments are required items. You cannot choose to put the
attachments in-line. This is a lesson that was learned from CFEngine
2. Readability is quickly lost if too many details are placed in-line.

@center @image{body_bundle,10cm}

@node Control bodies,  , Body parts, Bodies
@subsection Control bodies

Some promises in CFEngine are implicit and hard-coded into the program.
For example, the fact that CFEngine looks for a number of files to read and
execute them in a sequence cannot be changed.
However, you can change the behavior of such promises by setting control
parameters. These are formally parts of the `promise body', so we use the body structure to set them. Each agent, (CFEngine software component) has a special body whose name is @code{control}, used for setting these parameters. For cf-agent and cf-serverd we can have:

@verbatim
body agent control
{
bundlesequence => { "test" };
}
@end verbatim

@verbatim
body server control
{
allowconnects         => { "127.0.0.1" , "::1", @(def.acl) };
}
@end verbatim


@node Bundles, A simple syntax pattern, Bodies, Bodies and bundles
@section Bundles

A bundle is a simple concept. A bundle is merely a collection of promises
in a `sub-routine-like' container. The purpose of bundles is to allow
you greater flexibility to break down the contents of your policies and
give them names. Bundles also allow you to re-use promise code by
parameterizing it.

Like bodies, bundles also have `types'. Bundles belong to the agent that
is used to keep the promises in the bundle. So @code{cf-agent} has bundles
declared as

@verbatim
bundle agent my_name
{
}
@end verbatim

@noindent The @code{cf-serverd} program has bundles declared as:
@verbatim
bundle server my_name
{
}
@end verbatim
@noindent and so on. 



@menu
* Bundle scope::                
@end menu

@node Bundle scope,  , Bundles, Bundles
@subsection Bundle scope

Variables and classes defined inside bundles are not directly visible outside.
All variables in CFEngine are globally accessible, however if you refer to a variable
by @samp{$(unqualified)}, then it is assumed to belong to the current bundle. To
access any other (scalar) variable, you must qualify the name using the name of
the bundle in which it is defined:
@samp{$(bundle_name.qualified)}.

Some promise types, like @code{var}, @code{classes} may be made
by any agent. These are called @code{common} promises. Bundles of type @code{common}
are special. They may contain common promises. 
Classes defined in common bundles have global scope.

@node A simple syntax pattern,  , Bundles, Bodies and bundles
@section A simple syntax pattern

The syntax of CFEngine follows a simple pattern in all cases and has a few simple rules: 

@itemize
@item CFEngine built-in words, and identifiers of your choosing (the names
of variables, bundles, body templates and classes) may only contain
the usual alphanumeric and underscore characters (@samp{a-zA-Z0-9_}).

@item All other `literal' data must be quoted.

@item Declarations of promise bundles
in the form:
@example
bundle @var{agent-type} identifier 
@{
...
@}
@end example

@item Declarations of promise body-parts in the form:
@example
body constraint_type template_identifier 
@{
...
@} 
@end example
matching and expanding on a reference inside a promise
of the form
@samp{constraint_type => template_identifier}.


@item CFEngine uses many `constraint expressions'
as part of the body of a promise. These take the form: left-hand-side (cfengine word)
@samp{=>} right-hand-side (user defined data). This can take several forms:

@verbatim
cfengine_word => user_defined_template(parameters)
                 user_defined_template
                 builtin_function()
                 "quoted literal scalar"
                 { list }
@end verbatim
In each of these cases, the right hand side is a user choice.
@end itemize

Once you have learned this pattern,
it will make sense anywhere in the program. The figure below illustrates
this pattern. Some words are reserved by CFEngine, and are used as types or categories
for talking about promises. Other words (in blue) are to be defined by you.
Look at the examples and try to identify these patterns yourself.

@image{cfengineword,14cm}


@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node A simple crash course in concepts, Knowledge Management, Bodies and bundles, Top
@chapter A simple crash course in concepts


@menu
* Rules are promises::          
* Best practice for writing promises::  
@c * Containers::                  
* Decisions::                   
* Types in CFEngine 3::         
* Datatypes in CFEngine 3::     
* Variables::                   
* Loops::                       
* The main promise types::      
* Test a promise?::             
@end menu

@node Rules are promises, Best practice for writing promises, A simple crash course in concepts, A simple crash course in concepts
@section Rules are promises

Everything in CFEngine 3 can be interpreted as a promise. Promises can
be made about all kinds of different subjects, from file attributes,
to the execution of commands, to access control decisions and
knowledge relationships.

This simple but powerful idea allows a very practical uniformity in
CFEngine syntax.  There is only one grammatical form for statements in
the language that you need to know and it looks generically like this:

@smallexample

type:

classes::

  "promiser" -> @{ "promisee1", "promisee2", ... @}

     attribute_1 => value_1,
     attribute_2 => value_2,
     ...
     attribute_n => value_n;

@end smallexample

@noindent
We speak of a promiser (the abstract object making the promise), the
promisee is the abstract object to whom the promise is made, and then
there is a list of associations that we call the `body' of the
promise, which together with the promiser-type tells us what it is all
about.

@cartouche
The promiser is always the object
affected by the promise.
@end cartouche

Not all of these elements are necessary every time. Some promises
contain a lot of implicit behavior. In other cases we might want to
be much more explicit.  For example, the simplest reports promise
looks like this:

@smallexample

reports:

"hello world";

@end smallexample

And the simplest commands promise looks like this

@smallexample

commands:

"/bin/echo hello world";

@end smallexample

@noindent
This promise has default attributes for everything except the  
`promiser', i.e. the
command string that promises to execute.
A more complex promise contains many attributes:

@smallexample

# Promise type
files:

# promiser                  -> promisee (no curly braces needed if only one)
"/home/mark/tmp/test_plain" -> "system blue team",

 # attribute => value
     comment => "This comment follows the rule for knowledge  integration",
     perms   => owner("@@(usernames)"),
     create  => "true";

@end smallexample
The list of promisees is not used by CFEngine except for  
documentation, just
as the comment attribute (which can be added to any promise) has no  
actual function
other than to provide more information to the user in error tracing  
and auditing.

You see several kinds of object in this example. All literal strings
(e.g. @code{"true"}) in CFEngine 3 must be quoted. This provides
absolute consistency and makes type-checking easy and error-correction
powerful. All function-like objects (e.g. @code{users("..")}) are  
either built-in
special functions or parameterized templates which contain the `meat'  
of the right hand
side.

The words @code{commands}, and @code{files} are built-in promise
types. Promise types generally belong each to a particular component
of CFEngine, as the components are designed to keep different kinds of
promises.  A few types, such as @code{vars}, @code{classes} and
@code{reports} are common to all the different component bundles. You
will find a full list of the promise types that can be made by the
different components in the reference manual.


@c -----------------------------------------------------------------------
@c @node Best practice for writing promises, Containers, Rules are promises, A simple crash course in concepts
@node Best practice for writing promises, Decisions, Rules are promises, A simple crash course in concepts
@section Best practice for writing promises

When writing promises, get into the habit of giving every promise a comment
that explains its intention.

Also, give related promises @i{handles}, or labels that can be used to
refer to them by.

@verbatim

files:

  "/var/cfengine/inputs"

    handle => "update_policy",
    comment => "Update the configuration from a master server",

    perms => system("600"),
    copy_from => mycopy("$(master_location)","$(policy_server)"),
    depth_search => recurse("inf"),
    file_select => input_files,
    action => immediate;

@end verbatim
If a promise affects another promise in some way, you can make the affected
promise one of the promisees, like this:

@verbatim

access:

  "/master/cfengine/inputs" -> { "update_policy", "other_promisee" },

    comment => "Grant access to policy to our clients",
    handle  => "serve_updates",

    admit   => { "217.77.34.*" };

@end verbatim

Conversely, if a promise might depend on another in some (even indirect) way, document this too.

@verbatim

files:

  "/var/cfengine/inputs"

    comment => "Update the configuration from a master server",
    handle     => "update_policy",

    depends_on => {"serve_updates"},

    perms => system("600"),
    copy_from => mycopy("$(master_location)","$(policy_server)"),
    depth_search => recurse("inf"),
    file_select => input_files,
    action => immediate;


@end verbatim

Get into the habit of adding the cause-effect lines of influence.
Enterprise editions of CFEngine will track the dependencies between these
promises and map out impact analyses.

@c -----------------------------------------------------------------------
@c @node Containers, Decisions, Best practice for writing promises, A simple crash course in concepts
@c @section Containers


@c CFEngine allows you to group multiple promise statements into containers called bundles.
@c @smallexample

@c bundle agent identifier

@c @{
@c commands:
@c 
@c   "/bin/echo These commands are a silly way to use CFEngine";
@c   "/bin/ls -l";
@c   "/bin/echo But they illustrate a point";

@c @}

@c @end smallexample

@c Bundles serve two purposes: they allow us to collect related promises under a
@c single heading, like a subroutine, and they allow us to mix configuration for different
@c parts of CFEngine in the same file. The type of a bundle is the name of the component
@c of CFEngine for which it is intended.

@c For instance, we can make a self-contained example agent-server
@c configuration by labeling the bundles:

@c @smallexample

@c #
@c # Not a complete example
@c #

@c bundle agent testbundle

@c @{
@c files:

@c   "/home/mark/tmp/testcopy"

@c     comment      => "Throwaway example...",
@c     copy_from    => mycopy("/home/mark/LapTop/words","127.0.0.1"),
@c     perms        => system,
@c     depth_search => recurse("inf");
 
@c @}

@c #

@c bundle server access_rules

@c @{
@c access:

@c   "/home/mark/LapTop"

@c     admit   => @{ "127.0.0.1" @};
@c @}

@c @end smallexample

@c Another type of container in CFEngine 3 is a `body' part. Body parts
@c exist to hide complex parameter information in reusable containers.
@c The right hand side of some attribute assignments use body containers
@c to reduce the amount of in-line information and preserve readability.
@c You cannot choose where to use bodies: either they are used or they
@c are not used for a particular kind of attribute. What you can choose, however, is
@c the name and number of parameters for the body; and you can make as many of them as you like:
@c For example:

@c @smallexample

@c body copy_from mycopy(from,server)

@c @{
@c source      => "$(from)";
@c servers     => @{ "$(server)" @};
@c copy_backup => "true";

@c special_class::

@c   purge       => "true";
@c @}

@c @end smallexample

@c Notice also that classes can be used in bodies as well as parameters so that
@c you can hide environmental adaptations in these bodies also. The classes used
@c here are effectively ANDed with the classes under which the calling promise
@c is defined.


@c ------------------------------------------------------------------
@c @node Decisions, Types in CFEngine 3, Containers, A simple crash course in concepts
@node Decisions, Types in CFEngine 3, Best practice for writing promises, A simple crash course in concepts
@section Decisions

CFEngine decisions are made behind the scenes and the results of
certain true/false propositions are cached in Booleans referred to as
`classes'. There are no if-then-else statements in CFEngine; all
decisions are made with classes.

CFEngine runs on every computer individually and each time it wakes up
the underlying generic agent platform discovers and classifies
properties of the environment or context in which it runs.  This  
information
is effectively cached and may be used to make decisions about  
configuration.

Classes fall into hard (discovered) and soft (user-defined) types.  A
single hard class can be one of several things:

@itemize @bullet

@item The name of an operating system architecture e.g.   
@code{ultrix}, @code{sun4}, etc.

@item The unqualified name of a particular host. If your system  
returns a fully
qualified domain name for your host, CFEngine truncates it at the  
first dot. Note: @code{www.sales.company.com} and
@code{www.research.company.com} have the same unqualified name -- @code{www}.

@item The name of a user-defined group of hosts.

@item A day of the week (in the form @code{Monday, Tuesday,  
Wednesday, ..}).

@item An hour of the day, current time zone (in the form @code{Hr00,  
Hr01 ... Hr23}).

@item An hour of the day GMT (in the form @code{GMT_Hr00, GMT_Hr01 ...  
GMT_Hr23}).
This is consistent the world over, in case you need virtual  
simultaneity of change
coordination.

@item Minutes in the hour (in the form @code{Min00, Min17 ... Min45}).

@item A five minute interval in the hour (in the form @code{Min00_05,  
Min05_10 ... Min55_00})

@item The quarter-hour (in the form @code{Q1, Q2, Q3, Q4}).

@item A day of the month (in the form @code{Day1, Day2, ... Day31}).

@item A month (in the form @code{January, February, ... December}).

@item A year (in the form @code{Yr1997, Yr2004}).

@item A shift in @code{Night,Morning,Afternoon,Evening}, which fall  
into six hour blocks
starting at 00:00 hours.

@item A `lifecycle index', which is the year number modulo 3 (used in  
long term resource memory).

@item An arbitrary user-defined string.

@item The IP address octets of any active interface (in the form  
@code{@w{ipv4_192_0_0_1}},
@code{@w{ipv4_192_0_0}}, @code{@w{ipv4_192_0}}, @code{@w{ipv4_192}}).

@end itemize

@c chew end Hard classes

To see all of the classes define on a particular host, run

@smallexample
host# cf-promises -v
@end smallexample
as a privileged user. Note that some of the classes are set only
if a trusted link can be established with cfenvd, i.e. if both
are running with privilege, and the @file{/var/cfengine/state/env_data}
file is secure. More information about classes can be found in  
connection with
@code{allclasses}.

User-defined or soft classes are defined in bundles. Bundles of type
@code{common} yield classes that are global in scope, whereas in all
other bundle types classes are local.  Soft classes are evaluated when  
the
bundle is evaluated. They can be based on test functions or simply from
other classes:

@verbatim

bundle agent myclasses
{
classes:

"solinus" expression => "linux||solaris";

# List form useful for including functions

"alt_class" or => { "linux", "solaris", fileexists("/etc/fstab") };

"oth_class" and => { fileexists("/etc/shadow"), fileexists("/etc/ 
passwd") };

reports:

alt_class::

   # This will only report "Boo!" on linux, solaris, or any system
   # on which the file /etc/fstab exists
   "Boo!";
}

@end verbatim

@noindent Classes may be combined with the operators listed here in order
from highest to lowest precedence:

@table @samp
@item ()
The parenthesis group operator.
@item !
The NOT operator.
@item .
The AND operator.
@item &
The AND operator (alternative).
@item |
The OR operator.
@item ||
The OR operator (alternative).
@end table

@noindent
So the following expression would be only true on Mondays or Wednesdays
from 2:00pm to 2:59pm on Windows XP systems:

@example

(Monday|Wednesday).Hr14.WinXP::

@end example

@noindent Consider the following more advanced example.  Promises in bundles
of type @samp{common} are global in scope -- all other promises are local to
the scope of their bundle.


@verbatim

body common control
{
bundlesequence => { "g","ls_1", "ls_2" };
}

#################################

bundle common g
{
classes:

# The promise "zero" is always satisfied , and is global in scope
"zero" expression => "any";

}

#################################

bundle agent ls_1
{
classes:

# The promise "one" is always satisfied , and is local in scope to ls_1
"one" expression => "any";
}

#################################

bundle agent ls_2
{
classes:

# The promise "two" is always satisfied , and is local in scope to ls_2
"two" expression => "any";

reports:

zero.!one.two::

  # This report @b{will} be generated
  "Success";
}

@end verbatim

Here we see that class @samp{zero} is global while classes @samp{one}  
and @samp{two} are local.
The report `Success' result is therefore true because only @samp{zero}  
and @samp{two} are in scope in the @samp{ls_2} bundle (and the class
expression for bundle @samp{ls_2} requires that both @samp{zero} and
@samp{two} be true and that @samp{one} not be true).

CFEngine is controlled by a series of locks which prevent it from
checking promises too often, and which prevent it from spending too
long trying to verify promises it already verified recently. The locks
work in such a way that you can start several CFEngine processes
simultaneously without them interfering with each other. You can
control two things about each kind of action in the action sequence:

@table @samp

@item ifelapsed
The minimum time (in minutes) which should have passed since the last time
that promise was verified. It will not be executed again until
this amount of time has elapsed.
(Default time is 1 minute.)

@item expireafter
The maximum amount (in minutes) of time cf-agent should wait for an old
instantiation to finish before killing it
and starting again. (Default time is 120 minutes.)

@end table

@noindent
You can set these values either globally (for all
actions) or for each action separately. If you
set global and local values, the local values override
the global ones. All times are written in units
of @emph{minutes}. Global setting is in the control body:

@verbatim

body agent control
{
ifelapsed => "60";	# one hour
}

@end verbatim

@noindent
or locally in the transaction bodies:


@verbatim

body action example
{
ifelapsed => "90";	# 1.5 hours
}

@end verbatim

These locks do not prevent the whole of cf-agent from running, only
atomic promise checks. Several different atoms can be run concurrently
by different cf-agents.  The locks ensure that atoms will never be
started by two cf-agents at the same time, or too soon after a
verification, causing contention and wasting CPU cycles.


@c -----------------------------------------------------------------------
@node Types in CFEngine 3, Datatypes in CFEngine 3, Decisions, A simple crash course in concepts
@section Types in CFEngine 3

A key difference in CFEngine 3 compared to earlier versions is the
presence of types. Types are a mechanism for associating
values and checking consistency in a language. Once again, there is a
simple pattern to types in CFEngine.

The principle is very simple: types exist in order to match like a
plug-socket relationship. In the examples above, you can see two places
where types are used to match templates:

@itemize
@item Matching bundles to components:
@smallexample

bundle TYPE name  # matches TYPE to running agent
@{
@}

@end smallexample

@item Match bodies templates to lvalues in @code{lvalues => rvalue} constraints:

@smallexample

body TYPE name    # matches TYPE => name in promise
@{
@}

@end smallexample
@end itemize


@c -----------------------------------------------------------------------
@node Datatypes in CFEngine 3, Variables, Types in CFEngine 3, A simple crash course in concepts
@section Datatypes in CFEngine 3

CFEngine variables have two meta-types: scalars and lists. A scalar is a single value,
a list is a collection of scalars. Each scalar may have one of three types:
@code{string}, @code{int} or @code{real}. Typing is dynamic, so these are
interchangeable in many instances. However arguments to special functions check legal
type for consistency.

Integer constants may use suffixes to represent large numbers.

@itemize
  @item 'k'
          = value times 1000.

  @item 'K'
          = value times 1024.

  @item 'm'
          = value times 1000^2
  @item 'M'
          = value times 1024^2
  @item 'g'
          = value times 1000^3
  @item 'G'
          = value times 1024^3

  @item '%'
	  meaning percent, in limited contexts

  @item 'inf'
	  = a constant representing an unlimited value.
@end itemize


@c --------------------------------------------------------------------
@node Variables, Loops, Datatypes in CFEngine 3, A simple crash course in concepts
@section Variables

Variables (or "variable definitions") are also promises -- the promise to
represent their values.  We can write these in
any promise bundle. CFEngine recognizes two variable object types: scalars and  
lists (lists contain 0 or more objects)@footnote{Arrays can be scalars or lists of the RHS (rvalues). An array is really just a pattern in the names of the LHS (lvalues), not a separate type.}, as well as
three data-types (string, integer and real). Typing in CFEngine is  
dynamic, as in
Perl and other scripting languages. Thus variables of any data-type  
may be used as strings.


@menu
* Scalar variable expansion::   
* List variable substitution and expansion::           
* Special list value cf_null::   
* Arrays in CFEngine 3::
@end menu

@node Scalar variable expansion, List variable substitution and expansion, Variables, Variables
@subsection Scalar variable expansion

Scalar variables hold a single value. The are declared as follows:

@smallexample
bundle @i{<type>} name
@{
vars:

"my_scalar" string => "String contents...";
    "my_int" int    => "1234";
   "my_real" real   => "567.89";

@}

@end smallexample

The @samp{@i{<type>}} indicates that any kind of bundle applies here.
Scalar variables are referenced by @samp{$(name)} (or  
@samp{$@{name@}}) and they represent
a single value at a time.

@itemize
@item Scalars that are written without a context, e.g. @samp{$(myvar)}
are local to the current bundle.

@item Scalars are globally available everywhere provided one
uses the context to verify them e.g. @samp{$(context.myvar)}
may be written to access the variable `myvar' in bundle `context'.
@end itemize


@c -----------------------------------------------------------------------
@node List variable substitution and expansion, Special list value cf_null, Scalar variable expansion, Variables
@subsection List variable substitution and expansion

List variables hold several values. The are declared as follows:

@smallexample
bundle @i{<type>} name
@{
vars:

   "my_slist" slist => @{ "list", "of", "strings" @};
   "my_ilist" ilist => @{ "1234", "5678" @};
   "my_rlist" rlist => @{ "567.89" @};

@}

@end smallexample
An entire list is referred to with the at symbol @samp{@@}, but it does
not usually make sense to use this reference in a string. For instance
@smallexample

reports:

  cfengine_3::

     "My list is @@(my_slist)";

@end smallexample
@noindent means nothing and cannot be expanded (it does not generate an
error, but instead inserts the text @@(my_slist) into the string); but if
we use the scalar reference to a list variable, CFEngine will iterate over
the  values in
the list essentially making this into a list of promises.

@noindent To summarize:
@itemize

@item Scalar references to @i{local} list variables imply iteration,  
e.g.
suppose we have local list variable @samp{@@(list)}, then the
scalar @samp{$(list)} implies an iteration over every value of the
list.


@item Lists can be passed in their entirety in any context
where a list is expected as @samp{@@(list)}., e.g.

@verbatim

vars:

"longlist" slist => { @(shortlist), "plus", "plus" };

"shortlist" slist => { "you", "me" };

@end verbatim

The declaration order does not matter -- CFEngine will execute the promise
to assign the variable @samp{@@(shortlist)} before the promise to assign the
variable @samp{@@(longlist)}.

@item Only local lists can be expanded directly. Thus @samp{$(list)}
can be expanded but not @samp{$(context.list)}.  Global
list references have to be mapped into a local context if you want to
use them for iteration. 
@end itemize

Instead of doing this in some
arbitrary way, with possibility of name collisions, CFEngine
asks you to make this explicit. There are two possible approaches.

The first uses parameterization to map a global list into a local
context.
@verbatim

#
# Show access of external lists.
#
# - to pass lists globally, use a parameter to dereference them
#

body common control
{
bundlesequence => { hardening(@(va.tmpdirs)) };
}

#########################################################

bundle common va
{
vars:

 "tmpdirs"  slist => { "/tmp", "/var/tmp", "/usr/tmp"  };

}

##########################################################

bundle agent hardening(x)
{
classes:

  "ok" expression => "any";

vars:

 "other"    slist => { "/tmp", "/var/tmp" };

reports:

  ok::

    "Do $(x)";
    "Other: $(other)";
}

@end verbatim

This alternative uses a direct `short-circuit' approach to map the global
list into the local context.

@verbatim
#
# Show access of external lists.
#

body common control
{
bundlesequence => { hardening };
}

#########################################################

bundle common va
{
vars:

 "tmpdirs"  slist => { "/tmp", "/var/tmp", "/usr/tmp"  };

}

##########################################################

bundle agent hardening
{
classes:

  "ok" expression => "any";

vars:

 "other"    slist => { "/tmp", "/var/tmp" };
 "x"        slist => { @(va.tmpdirs) };

reports:

  ok::

    "Do $(x)";
    "Other: $(other)";
}
@end verbatim


@c -----------------------------------------------------------------------
@node Special list value cf_null, Arrays in CFEngine 3, List variable substitution and expansion, Variables
@subsection Special list value @code{cf_null}

As of CFEngine core version 3.1.0, the value @samp{cf_null} may be used as a NULL
value within lists. This value is ignored in list variable expansion.

@verbatim

vars:

  "empty_list" slist => { "cf_null" };

@end verbatim


@c -----------------------------------------------------------------------
@node Arrays in CFEngine 3,  , Special list value cf_null, Variables
@subsection Arrays in CFEngine 3

Array variables are written with @samp{[} and @samp{]} brackets, e.g.

@verbatim

bundle agent example

{
vars:

  "component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

  "array[cf-monitord]" string => "The monitor";
  "array[cf-serverd]" string => "The server";
  "array[cf-execd]" string => "The executor, not executioner";

commands:

   "/bin/echo $(component) is"

            args => "$(array[$(component)])";

}

@end verbatim

Arrays are associative and may be of type scalar or list. Enumerated
arrays are simply treated as a special case of associative arrays, since
there are no numerical loops in CFEngine. Special functions exist to
extract lists of keys from array variables for iteration purposes.

Thus one could have written the example above in the form of the
following example:

@verbatim

bundle agent array

{
vars:

  "v[index_1]" string => "value_1";
  "v[index_2]" string => "value_2";

  "parameter_name" slist => getindices("v");

reports:

  Yr2008::

   "Found index: $(parameter_name)";

}

@end verbatim


@c ------------------------------------------------------------------
@node Loops, The main promise types, Variables, A simple crash course in concepts
@section Loops
If you are looking for loops in CFEngine then we need to reprogram you
a little, as you are thinking like a programmer!  CFEngine is not a
programming language that is meant to give you low level control, but
rather a set of declarations that embody processes. It's the difference
between the gears on a bicycle and the automated transmission in a
transporter.

Loops are executed implicitly in CFEngine, but there is no visible
mechanism for it -- because that would steal attention from the
intention of the promises. The way to express them is through lists.

Loops are really a way to iterate a variable over a list. Try the  
following.

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{
vars:

# This is a list

"component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

# This is an associative array

"array[cf-monitord]" string => "The monitor";
"array[cf-serverd]" string => "The server";
"array[cf-execd]" string => "The executor, not executionist";

reports:

cfengine_3::

"$(component) is $(array[$(component)])";

}

@end verbatim
The output looks something like this:
@smallexample

/var/cfengine/bin/cf-agent -f ./unit_loops.cf -K

R: cf-monitord is The monitor
R: cf-serverd is The server
R: cf-execd is The executor, not executionist

@end smallexample
You see from this that, if we refer to a list variable using the  
scalar reference
operator @samp{$()}, CFEngine interprets this to mean ``please iterate  
over all
values of the list''. Thus, we have effectively a `foreach' loop, without the  
attendant syntax.

@c ---------------------------------------------------------------------------
@node The main promise types, Test a promise?, Loops, A simple crash course in concepts
@section The main promise types

@noindent The following promise types may be used in any bundle:
@table @code
@item vars
A promise to be a variable, representing a value.
@item classes
A promise to be a class representing a state of the system.
@item reports
A promise to report a message.
@end table

@noindent These additional promise types may be used only in agent bundles
@table @code
@item commands
A promise to execute a command.
@item databases
A promise to configure a database.
@item files
A promise to configure a file, including its existence, attributes and  
contents.
@item interfaces
A promise to configure a network interface.
@item methods
A promise to take on a whole bundle of other promises.
@item packages
A promise to install a package.
@item storage
A promise to verify attached storage.
@end table

@noindent These promise types belong to other components:
@table @code
@item access
A promise to grant or deny access to file objects in @code{cf-serverd}.
@item measurements
A promise to measure or sample data from the system, for monitoring or  
reporting in @code{cf-monitord} (CFEngine Nova and above).
@item roles
A promise to allow certain users to activate certain classes when  
executing @code{cf-agent} remotely, in @code{cf-serverd}.
@item topics
A promise to associate knowledge with a name, and possibly other  
topics, in @code{cf-know}.
@item occurrences
A promise to point or refer to a knowledge resource, in @code{cf-know}.
@end table


@c ---------------------------------------------------------------------------
@node Test a promise?, , The main promise types, A simple crash course in concepts
@section Test a promise?

If you are impatient to get hands-on experience, now might be a good time to take a break from Concepts and try out your first promises (@url{http://cfengine.com/manuals/cf3-tutorial.html#First-promises}. Still, since knowledge management is an integral part of CFEngine, we strongly recommend to read the following section on this very issue sooner rather than later.

@c *****************************************************
@c * CHAPTER
@c *****************************************************
@node Knowledge Management,  , A simple crash course in concepts, Top
@chapter Knowledge Management


A unique aspect of CFEngine, that is fully developed in the commercial
editions of the software, its ability to enable integrated knowledge
management as part of an automation process, and to use its configuration
technology as a `semantic' documentation engine.

@image{topicmap,15cm,,,png}

Knowledge management is the challenge of our times.  Organizations  
frequently waste significant effort re-learning old lessons because they have
not been documented and entered into posterity.  Now you can alleviate
this problem with some simple rules of thumb and even build
sophisticated index-databases of documents.


@menu
* Promises and Knowledge::      
* The basics of knowledge::     
* Annotating promises::         
* A promise model of topic maps::  
* What topic maps offer::       
* The nuts and bolts of topic maps::  
* Example of topics promises::  
* Modeling configuration promises as topic maps::  
@end menu

@node Promises and Knowledge, The basics of knowledge, Knowledge Management, Knowledge Management
@section Promises and Knowledge

The learning curve for configuration management systems has been the
brunt of frequent criticism over the years. Users are expected to either
confront the informational complexity of systems at a detailed level, or
abandon the idea of fine control altogether.  This has led either to
information overload or over-simplification. The ability to cope with
information complexity is therefore fundamental to IT management

CFEngine introduced the @emph{promise model} for configuration in
order to flatten out this learning curve. It can lead to
simplifications in use, because a lot of the thinking has been done
already and is encapsulated into the model. One of its special
properties is that it is both a model for system behaviour and a model
for knowledge representation (this is what declarative languages seek
to be, of course). More specifically, it incorporated a subset of the
ISO standard for `Topic Maps', an open technology for semantic
indexing of information resources.  By bringing together these two
technologies (which are highly compatible), we end up with a seamless
front-end for sewing together and browsing system information.

Knowledge management is a field of research in its own right, and it
covers a multitude of issues both human and technological. Most would
agree that knowledge is composed of facts and relationships and that
there is a need both for clear definitions and semantic context to
interpret knowledge properly; but how do we attach @emph{meaning} to
raw information without ambiguity?

Knowledge has quite a lot in common with configuration: what after all  
is
knowledge but a configuration of ideas in our minds, or on some
representation medium (paper, silicon etc). It is a coded pattern,
preferably one that we can agree on and share with others.  Both
knowledge and configuration management are about describing patterns.
A simple knowledge model can be used to represent a policy or
configuration; conversely, a simple model of policy configuration can
manufacture a knowledge structure just as it might manufacture
a filesystem or a set of services.


@node The basics of knowledge, Annotating promises, Promises and Knowledge, Knowledge Management
@section The basics of knowledge

Knowledge only truly begins when we write things down:

@itemize
@item The act of formulating something in writing brings a discipline  
of thought than often lends clarity to an idea.
@item You never confront an idea fully until you try to put it into  
language.
@item Any written record that is kept allows others to read it and  
pass on the knowledge.
@end itemize

The trouble is that writing is something people don't like to do, and
few are very good at.  To an engineer, it can feel like a waste of
time, especially during a busy day, to break off from the doing to
write about the doing. Also, writing requires a spurt of creative
thinking and engineers are often more comfortable with manipulating
technical patterns and notations than writing fluent linguistic
formulations that seem overtly long-winded.

CFEngine tries to bridge this gap by making documentation simple and
part of the technical configuration. CFEngine's knowledge agent then
uses AI and network science algorithms to construct a readable
documentation from these technical annotations. It can do this because
a lot of thought has already gone into the meaning of the promise
model.

@node  Annotating promises, A promise model of topic maps, The basics of knowledge, Knowledge Management
@section Annotating promises

The beginning of knowledge is to annotate the technical specifications.
Remember that the point of a promise is to convey an @i{intention}.
When writing promises, get into the habit of giving every promise a
comment that explains its intention.  Also, expect to give special  
promises
@i{handles}, or helpful labels that can be used to refer to them in  
other
promise statements. A handle could be something dumb like `xyz', but  
you should
try to use more meaningful titles to help make references clear.

@verbatim

files:

"/var/cfengine/inputs"

     handle => "update_policy",
    comment => "Update the CFEngine input files from the policy server",
      perms => system("600"),
  copy_from => rcp("$(master_location)","$(policy_server)"),
depth_search => recurse("inf"),
file_select => input_files,
     action => immediate;

@end verbatim
@noindent If a promise affects another promise in some way, you can
make the affected one
promise one of the promisees, like this:

@verbatim

access:

"/master/CFEngine/inputs" -> { "update_policy", "other_promisee" },

handle  => "serve_updates",
  admit   => { "217.77.34.*" };

@end verbatim

@noindent Conversely, if a promise might depend on another in some  
(even indirect) way, document this too.

@verbatim

files:

"/var/cfengine/inputs"

      handle => "update_policy",
     comment => "Update the CFEngine input files from the policy  
server",
  depends_on => { "serve_updates" },
       perms => system("600"),
   copy_from => rcp("$(master_location)","$(policy_server)"),
depth_search => recurse("inf"),
file_select => input_files,
      action => immediate;

@end verbatim

@noindent This use of annotation is the first level of documentation  
in CFEngine.
The annotations are used internally by CFEngine to provide meaningful
error messages with context and to compute dependencies that reveal
the existence of process chains. These can be turned into a topic map
for browsing the policy relationships in a web browser, using
@code{cf-know}.


@cartouche
The CFEngine Knowledge Map is only available in commercial editions
of the software, where the necessary support to set up and maintain
this technology can be provided.
@end cartouche


@node A promise model of topic maps, What topic maps offer, Annotating promises, Knowledge Management
@section A promise model of topic maps

CFEngine's model of promises can also be used to promise information
and its relevance in different contexts. The Knowledge agent @code{cf-know}
understands three kinds of promise.

@table @code
@item topics:
A topic is merely a string that can be associated with another string. It represents a `subject to be talked about'.
Like other promise types, you can use contexts, which are formed from other topics expressions to limit the scope of
the current topic promise.
@item things:
Things are a simplified interface to topics, that were introduced to make it easier
for users to contribute knowledge about more concrete `things', or less abstract ideas.
A challenge with knowledge management is the abstract and technical nature of the models
one must use to represent it. Things attempt to make that task easier.
@item occurrences:
An occurrence is a reference to a document or a piece of text that actually represents
knowledge content about the topic concerned. Occurrences are generally URLs or strings
explaining things or topics.
@end table

@node What topic maps offer, The nuts and bolts of topic maps, A promise model of topic maps, Knowledge Management
@section What topic maps offer

CFEngine is capable of automating the documentation of a policy, using basic annotations provided above, as a
knowledge map. They require very little effort from the user. If you
are using the Community Edition of CFEngine, you can develop a topic
map, but we do not support the backend technology without a
commercial license. In either case, once you become familiar with the
use of Topic Maps, you will want to extend your knowledge manually to
incorporate things like:

@itemize
@item Local (high level) policy documents
@item Related databases, such as CMDBs
@end itemize

@noindent So let us spend a while showing how to encode knowledge in  
topic maps
using @code{cf-know}.

The kind of result you can expect is shown in the pictures below.  The
example figures show typical pages generated by the knowledge agent
@code{cf-know}. The first of these shows how we use the technology to
power the web knowledge base in the commercial CFEngine product.

In this use, all of the data are based on documentation for
the CFEngine software, and most of the relationships are manually
entered.

For a second example, consider how CFEngine can generate such a
knowledge map analysis of its own configuration (self-analysis).  The
data in the images below describe the CFEngine configuration
promises. One such page is generated, for instance, for each policy
promise, and pages are generated for reports from different computers
etc. You can also create you own `topic pages' for any local
(enterprise) information that you have.

In this example, the promise has been given the promise-handle
@code{update_policy}, and the associations and the lower graph shows
how this promise relates to other promises through its documented
dependencies (these are documented from the promisees and
@code{depends_on} attributes of other promises.).

The example page shows two figures, one above the other.
The upper figure shows the thirty nearest topics (of any kind) that  
are related to this one.
Here the relationships are unspecific. This diagram can reveal  
pathways to related information
that are often unexpected, and illustrates relationships that broaden  
one's understanding
of the place the current promise occupies within the whole.

Although the graphical illustrations are just renderings of
semantic associations shown more fully in text, they are useful for  
visualizing
several levels of depth in the associative network. This can be
surprisingly useful for brainstorming and reasoning alike. In
particular, one can see the other promises that could be affected if
we were to make a change to the current promise.  Such impact analyses
can be crucial to planning change and release management of policy.



@cartouche

A knowledge base is a slightly improved implementation of a Topic Map which is an ISO
standard technology. A topic map works like an index that can point to
many different kinds of external resources, and may contain simple
text and images internally. So you use it to bind together documents
of any kind. A CFEngine knowledge base is not a new document format, it
is an overlay map that joins ideas and resources together, and
displays relationships.

@end cartouche




@node The nuts and bolts of topic maps, Example of topics promises, What topic maps offer, Knowledge Management
@section The nuts and bolts of topic maps


@menu
* Topic map definitions::       
@end menu

@node Topic map definitions,  , The nuts and bolts of topic maps, The nuts and bolts of topic maps
@subsection Topic map definitions

Topic maps are really electronic indices, but they form and work like  
webs.
A topic is the technical representation of a `subject', i.e. anything  
you might want
to discuss, abstract or physical e.g.  an item of `abstract
knowledge', which probably has a number of concrete exemplars. It
might be a person, a machine, a quality, etc.

Topics can be classified into boxes called @emph{topic-types} so that  
related
things can be collated and unrelated things can be separated, e.g.
types allow us to distinguish between @code{rmdir} the Unix utility
and @code{rmdir} the Unix system-call.

Each typed topic can further point to a number of references or
exemplars called @emph{occurrences}. For instance, an occurrence of
the topic `computer' might include books, web documents, database
entries, physical manifestations, or any other information.  An
occurrence is a reference that exemplifies the abstract
topic. Occurrence references are like the page numbers in an
index.


A book index typically has `see also' references which point from one  
topic to another.
Topic Maps allow one to define any kind of @emph{association} between
topics. Unlike an ordinary index, a topic map has a rich (potentially
infinite) variety of cross reference types.
For instance,
@smallexample
topic_1 ``is a kind of'' topic_2
topic_1 ``is improved by'' topic 2
topic_1 ``solves the problem of'' topic_2
@end smallexample

@noindent The topic map model thus has three levels of containers:

@table @emph
@item Contexts
The box into which we classify a topic to disambiguate different
topics with the same name (`in the context of')@footnote{Here, CFEngine differs from the topic map standard in allowing contexts
to be overlapping sets, rather than mutually exclusive `types'.
CFEngine is guided by Promise Theory in this respect in order to enable
distributed cooperation and the development of a free and emergent ontology.}.

@item Topics/Things
The representation of a subject (an index term).

@item Occurrence Types
A term that explains how an actual document occurrence relates
to the topic is claims to say something about. e.g. (tutorial, manual,  
or
example, definition, photo-album etc).

@item Occurrences
Specific information resources: these are pointers to the actual  
documents
that we want to read  (like page numbers in an index).
@end table


Contexts map conveniently into CFEngine classes.
Topics map conveniently into promisers.
Occurrences also map to promisers of a different type.
These three label different levels of granularity of meaning. Contexts
represent a set of topics that might be relevant, which in turn encompass a set of
occurrences of resources that contain actual information about the topics in that context. The primacy of topics in this
stems from their ability to form networks by @emph{association}.

The classic approach to information modeling is to build a
hierarchical decomposition of non-overlapping objects. Data are
manipulated into non-overlapping containers which often prove
to be overly restrictive. Topic maps allow us to avoid the kinds of
mistakes that have led to monstrosities like the Common Information
Model (CIM) with its @emph{thousands} of strictly non-overlapping type
categories.

Each topic allows us to effectively `shine a light' onto the
occurrences of information that highlight the concepts pertinent to
the topic somehow.


@node Example of topics promises, Modeling configuration promises as topic maps, The nuts and bolts of topic maps, Knowledge Management
@section Example of topics promises

You can use @code{cf-know} to render a topic map either as text (for  
command line
use) or as HTML (for web rendering). We begin with the text rendering  
as it requires less
infrastructure. You will just need a database.

Try typing in the following knowledge promises:

@smallexample

body common control
@{
bundlesequence  => @{ "tm" @};
@}

###################################################

bundle knowledge tm
@{
topics:


"server" comment => "Common name for a computer in a desktop";
"desktop" comment => "Common name for a computer for end users";

programs:: # context of programs

"httpd" comment => "A web service process";
"named" comment => "A name service process";

services::

"WWW" comment => "World Wide Web service",
      association => a("is implemented by",
                       "programs::httpd",
                       "implements");

 # if we don't specify a context, it is "any"

"WWW" association => a("looks up addresses with",
                       "named",
                       "serves addresses to");

occurrences:

httpd::
   "http://www.apache.org"
     represents => @{ "website" @};

@}

###################################################

body association a(f,name,b)

@{
forward_relationship => "$(f)";
backward_relationship => "$(b)";
associates => @{ $(name) @};
@}
@end smallexample

@noindent The simplified things interface is similar, but uses fixed relations:

@verbatim
bundle knowledge company_knowledge
{
things:
 regions::

   "EMEA"     comment => "Europe, The Middle-East and Africa";
   "APAC"     comment => "Asia and the Pacific countries";

 countries::
   "UK"            synonyms => { "Great Britain" },
              is_located_in => { "EMEA", "Europe" };

   "Netherlands"   synonyms => { "Holland" },
              is_located_in => { "EMEA", "Europe" };

   "Singapore"     is_located_in => { "APAC", "Asia" };

 locations::
   "London_1"    is_located_in => { "London", "UK" };
   "New_Jersey"  is_located_in => { "USA" };

 networks::

  "192.23.45.0/24"         comment => "Secure network, zone 0. Single octet for corporate offices",
                   is_connected_to => { "oslo-hub-123" };

@end verbatim

@menu
* Analyzing and indexing the policy::  
* cf-know::                     
@end menu

@node Analyzing and indexing the policy, cf-know, Example of topics promises, Example of topics promises
@subsection Analyzing and indexing the policy

CFEngine can analyze the promises you have made, index and cross
reference them using the command:

@verbatim
# cf-promises -r
@end verbatim
Normally, the default policy in Nova/Enterprise will perform this
command each time the policy is changed.

@node cf-know,  , Analyzing and indexing the policy, Example of topics promises
@subsection @code{cf-know}

CFEngine's knowledge agent @code{cf-know} allows you to make promises
about knowledge and its inter-relationships. It is not specifically a
generic topic map language: rather it provides a powerful configuration
language for managing a knowledge base that can be compiled into a
topic map.

To build a topic map from a set of knowledge promises in @file{knowledge.cf}, you would write:

@verbatim
# cf-know -b -f ./knowledge.cf
@end verbatim

The syntax of this file is hinted at below.
The full ISO standard topic map model is too rich to be a useful tool
for system knowledge management. However, this is where powerful
configuration management can help to simplify the process: encoding a
topic map is a complex problem in configuration, which is exactly what
CFEngine is for. CFEngine's topic map promises have the following
form:

@smallexample

bundle knowledge example
@{
topics:

topic_type_context::                          # canonical container

"Topic name"                                # short topic name

      comment => "Use this for a longer description",
  association => a("forward assoc to","Other topic","backward assoc");

  "Other topic";

occurrences:

Topic_name::                                   # Topic

  "http://www.example.org/document.xyz"        # URI to instance

    represents => @{ "Definition", "Tutorial"@}; # sub-types
@}

@end smallexample
The association body templates look like this:
@verbatim

body association a(f,name,b)
{
forward_relationship => "$(f)";
backward_relationship => "$(b)";
associates => { $(name) };
}

@end verbatim



@cartouche

Promise theory adds a clear structure to the topic map ontology, which
is highly beneficial as experience shows that weak conceptual models
lead to poor knowledge maps.

@end cartouche


@node Modeling configuration promises as topic maps,  , Example of topics promises, Knowledge Management
@section Modeling configuration promises as topic maps

We can model topic maps as promises within CFEngine; the
question then remains as to how to use topic maps to model
configurations so that CFEngine users can navigate the documented
promises using a web browser and be able to see all of the
relationships between otherwise isolated and fragmentary rules. This
will form the basis of a semantic Configuration Management Database
(sCMDB) for the CFEngine software. The key to making these ends meet
is to see the configuration of the topic map as a number f promises
made in the abstract space of topics and the turning each promise into
a meta-promise that models the configuration as a topic with attendant
associations. Consider the following CFEngine promise.

@verbatim

bundle agent update
{
files:

any::

``/var/cfengine/inputs'' -> { ``policy_team'', ''dependent'' },

          comment => ``Check policy updates from source'',
            perms => true,
             mode => 600,
        copy_from => true,
      copy_source => /policy/masterfiles,
          compare => digest,
     depth_search => true,
            depth => inf,
         ifelapsed => 1;

}
@end verbatim

This system configuration promise can be mapped by CFEngine into a
number of other promise proposals intended for the @code{cf-know}
agent. Suppressing some of the details, we have:

@verbatim

type_files::

"/var/cfengine/inputs"
    association => a("promise made in bundle","update","bundle  
contains promise");
"/var/cfengine/inputs"
    association => a("specifies body type","perms","is specified in");
"/var/cfengine/inputs"
    association => a("specifies body type","mode","is specified in");
"/var/cfengine/inputs"
    association => a("specifies body type","copy_from","is specified  
in");

# etc ...

occurrences:

_var_CFEngine_inputs::

  "promise_output_common.html#promise__var_CFEngine_inputs_update_cf_13"
     represents => { "promise definition" };

@end verbatim
Note that in this mapping, the actual promise (viewed as a real world
entity) is an occurrence of the topic `promise'; at the same time each
promise could be discussed as a different topic allowing
meta-modeling of the entity-relation model in the real-world
data. Conversely the topics themselves become configuration items or
`promisers' in the promise model. The effect is to create a navigable
semantic web for traversing the policy; this documents the structure
and intention of the policy using a small ontology of standard
concepts and can be extended indefinitely by human domain experts.





@chapter More...

@cartouche

You will find extensive help, examples and documentation as part of  
the commercial CFEngine support. Visit the website @url{http://www.cfengine.com} for more
details.

@end cartouche

@noindent Need help getting started?
@itemize 
@item CFEngine Installation: @url{http://cfengine.com/manuals/cf3-installation.html}
@item Get started, first promises: @url{http://cfengine.com/manuals/cf3-tutorial.html#First-promises}
@end itemize

@noindent For a complete overview:
@itemize
@item Tutorial: @url{http://cfengine.com/manuals/cf3-tutorial.html}
@item Reference manual: @url{http://cfengine.com/manuals/cf3-Reference.html}
@end itemize



@ifhtml
@html
<a name="Contents">
@contents
@end html
@end ifhtml

@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https:// 
ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google- 
analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml

@bye
