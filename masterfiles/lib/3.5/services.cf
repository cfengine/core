############################################################################
#  Copyright (C) CFEngine AS
#
#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License LGPL as published by the
#  Free Software Foundation; version 3.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  To the extent this program is licensed as part of the Enterprise
#  versions of CFEngine, the applicable Commerical Open Source License
#  (COSL) may apply to this file if you as a licensee so wish it. See
#  included file COSL.txt.
###########################################################################
#
# CFEngine Community Open Promise-Body Library
#
# This initiative started by CFEngine promotes a
# standardized set of names and promise specifications
# for template functionality within CFEngine 3.
#
# The aim is to promote an industry standard for
# naming of configuration patterns, leading to a
# de facto middleware of standardized syntax.
#
# Names should be intuitive and parameters should be
# minimal to assist readability and comprehensibility.

# Contributions to this file are voluntarily given to
# the cfengine community, and are moderated by CFEngine.
# No liability or warranty for misuse is implied.
#
# If you add to this file, please try to make the
# contributions "self-documenting". Comments made
# after the bundle/body statement are retained in
# the online docs
#

# For CFEngine Core: 3.5.1 to 3.5.x
# Services bodies

###################################################
# If you find CFEngine useful, please consider    #
# purchasing a commercial version of the software.#
###################################################

##-------------------------------------------------------
## service promises
##-------------------------------------------------------

body service_method bootstart
{
      service_autostart_policy => "boot_time";
      service_dependence_chain => "start_parent_services";
    windows::
      service_type => "windows";
}

##

body service_method force_deps
{
      service_dependence_chain => "all_related";
    windows::
      service_type => "windows";
}

##

bundle agent standard_services(service,state)
{
      # DATA,

  vars:

    any::

      "default[prefix]" string => "/etc/init.d";
      "default[pattern]" string => "\b$(service)\b";
      "default[cmd]" string => "$(default[prefix])/$(service) $(state)";

      "stakeholders[cfengine3]" slist => { "cfengine_in" };
      "stakeholders[acpid]" slist => { "cpu", "cpu0", "cpu1", "cpu2", "cpu3" };
      "stakeholders[mongod]" slist => { "mongo_in" };
      "stakeholders[postfix]" slist => { "smtp_in" };
      "stakeholders[sendmail]" slist => { "smtp_in" };
      "stakeholders[www]" slist => { "www_in", "wwws_in", "www_alt_in" };
      "stakeholders[ssh]" slist => { "ssh_in" };
      "stakeholders[mysql]" slist => { "mysql_in" };
      "stakeholders[nfs]" slist => { "nfsd_in" };
      "stakeholders[syslog]" slist => { "syslog" };
      "stakeholders[rsyslog]" slist => { "syslog" };
      "stakeholders[tomcat5]" slist => { "www_alt_in" };
      "stakeholders[tomcat6]" slist => { "www_alt_in" };

    linux::

      "pattern[acpid]"          string => ".*acpid.*";
      "pattern[cfengine3]"      string => ".*cf-execd.*";
      "pattern[fancontrol]"     string => ".*fancontrol.*";
      "pattern[hddtemp]"        string => ".*hddtemp.*";
      "pattern[irqbalance]"     string => ".*irqbalance.*";
      "pattern[lm-sensor]"      string => ".*psensor.*";
      "pattern[mongod]"         string => ".*mongod.*";
      "pattern[openvpn]"        string => ".*openvpn.*";
      "pattern[postfix]"        string => ".*postfix.*";
      "pattern[rsync]"          string => ".*rsync.*";
      "pattern[rsyslog]"        string => ".*rsyslogd.*";
      "pattern[sendmail]"       string => ".*sendmail.*";
      "pattern[tomcat5]"        string => ".*tomcat5.*";
      "pattern[tomcat6]"        string => ".*tomcat6.*";
      "pattern[varnish]"        string => ".*varnish.*";
      "pattern[wpa_supplicant]" string => ".*wpa_supplicant.*";

    SuSE|suse::

      "ezconf[mysql]"       string => "mysqld";
      "pattern[mysql]"      string => ".*mysqld.*";

      "ezconf[www]"         string => "apache2";
      "pattern[www]"        string => ".*apache2.*";

      "ezconf[ssh]"         string => "sshd";
      "pattern[ssh]"        string => ".*sshd.*";

      "pattern[ntpd]"       string => ".*ntpd.*";

    redhat::

      "pattern[anacron]"          string => ".*anacron.*";
      "pattern[atd]"              string => ".*sbin/atd.*";
      "pattern[auditd]"           string => ".*auditd$";
      "pattern[autofs]"           string => ".*automount.*";
      "pattern[capi]"             string => ".*capiinit.*";
      "pattern[conman]"           string => ".*conmand.*";
      "pattern[cpuspeed]"         string => ".*cpuspeed.*";
      "pattern[crond]"            string => ".*crond.*";
      "pattern[dc_client]"        string => ".*dc_client.*";
      "pattern[dc_server]"        string => ".*dc_server.*";
      "pattern[dnsmasq]"          string => ".*dnsmasq.*";
      "pattern[dund]"             string => ".*dund.*";
      "pattern[gpm]"              string => ".*gpm.*";
      "pattern[haldaemon]"        string => ".*hald.*";
      "pattern[hidd]"             string => ".*hidd.*";
      "pattern[irda]"             string => ".*irattach.*";
      "pattern[iscsid]"           string => ".*iscsid.*";
      "pattern[isdn]"             string => ".*isdnlog.*";
      "pattern[lvm2-monitor]"     string => ".*vgchange.*";
      "pattern[mcstrans]"         string => ".*mcstransd.*";
      "pattern[mdmonitor]"        string => ".*mdadm.*";
      "pattern[mdmpd]"            string => ".*mdmpd.*";
      "pattern[messagebus]"       string => ".*dbus-daemon.*";
      "pattern[microcode_ctl]"    string => ".*microcode_ctl.*";
      "pattern[multipathd]"       string => ".*multipathd.*";
      "pattern[netplugd]"         string => ".*netplugd.*";
      "pattern[NetworkManager]"   string => ".*NetworkManager.*";
      "pattern[nfs]"              string => ".*nfsd.*";
      "pattern[nfslock]"          string => ".*rpc.statd.*";
      "pattern[nscd]"             string => ".*nscd.*";
      "pattern[ntpd]"             string => ".*ntpd.*";
      "pattern[oddjobd]"          string => ".*oddjobd.*";
      "pattern[pand]"             string => ".*pand.*";
      "pattern[pcscd]"            string => ".*pcscd.*";
      "pattern[portmap]"          string => ".*portmap.*";
      "pattern[postgresql]"       string => ".*postmaster.*";
      "pattern[rdisc]"            string => ".*rdisc.*";
      "pattern[readahead_early]"  string => ".*readahead.*early.*";
      "pattern[readahead_later]"  string => ".*readahead.*later.*";
      "pattern[restorecond]"      string => ".*restorecond.*";
      "pattern[rpcgssd]"          string => ".*rpc.gssd.*";
      "pattern[rpcidmapd]"        string => ".*rpc.idmapd.*";
      "pattern[rpcsvcgssd]"       string => ".*rpc.svcgssd.*";
      "pattern[saslauthd]"        string => ".*saslauthd.*";
      "pattern[smartd]"           string => ".*smartd.*";
      "pattern[svnserve]"         string => ".*svnserve.*";
      "pattern[syslog]"           string => ".*syslogd.*";
      "pattern[tcsd]"             string => ".*tcsd.*";
      "pattern[xfs]"              string => ".*xfs.*";
      "pattern[ypbind]"           string => ".*ypbind.*";
      "pattern[yum-updatesd]"     string => ".*yum-updatesd.*";
      "pattern[munin-node]"       string => ".*munin-node.*";

      "ezconf[bluetoothd]"        string => "bluetooth";
      "pattern[bluetoothd]"       string => ".*hcid.*";

      #  "startcommand[ip6tables]"   string => "/etc/init.d/ip6tables start";
      #  "restartcommand[ip6tables]" string => "/etc/init.d/ip6tables restart";
      #  "reloadcommand[ip6tables]"  string => "/etc/init.d/ip6tables reload";
      #  "stopcommand[ip6tables]"    string => "/etc/init.d/ip6tables stop";
      #  "pattern[ip6tables]"        string => ".*ip6tables.*";

      #  "startcommand[iptables]"   string => "/etc/init.d/iptables start";
      #  "restartcommand[iptables]" string => "/etc/init.d/iptables restart";
      #  "reloadcommand[iptables]"  string => "/etc/init.d/iptables reload";
      #  "stopcommand[iptables]"    string => "/etc/init.d/iptables stop";
      #  "pattern[iptables]"        string => ".*iptables.*";


      "ezconf[mysql]"         string => "mysqld";
      "pattern[mysql]"        string => ".*mysqld.*";

      "ezconf[www]"           string => "httpd";
      "pattern[www]"          string => ".*httpd.*";

      "ezconf[ssh]"           string => "sshd";
      "pattern[ssh]"          string => ".*sshd.*";

      "startcommand[rhnsd]"   string => "/sbin/service rhnsd start";
      "restartcommand[rhnsd]" string => "/sbin/service rhnsd restart";
      "reloadcommand[rhnsd]"  string => "/sbin/service rhnsd reload";
      "stopcommand[rhnsd]"    string => "/sbin/service rhnsd stop";
      "pattern[rhnsd]"        string => "rhnsd";

      "ezconf[snmpd]"         string => "snmpd";
      "pattern[snmpd]"        string => "/usr/sbin/snmpd";

    debian|ubuntu::

      "pattern[atd]"            string => "atd.*";
      "pattern[bluetoothd]"     string => ".*bluetoothd.*";
      "pattern[bootlogd]"       string => ".*bootlogd.*";
      "pattern[crond]"          string => ".*cron.*";
      "pattern[kerneloops]"     string => ".*kerneloops.*";
      "pattern[mysql]"          string => ".*mysqld.*";
      "pattern[NetworkManager]" string => ".*NetworkManager.*";
      "pattern[ondemand]"       string => ".*ondemand.*";
      "pattern[plymouth]"       string => ".*plymouthd.*";
      "pattern[saned]"          string => ".*saned.*";
      "pattern[udev]"           string => ".*udev.*";
      "pattern[udevmonitor]"    string => ".*udevadm.*monitor.*";
      "pattern[snmpd]"          string => "/usr/sbin/snmpd";
      "pattern[pgbouncer]"      string => ".*pgbouncer.*";
      "pattern[supervisor]"     string => ".*supervisord.*";
      "pattern[munin-node]"     string => ".*munin-node.*";
      "pattern[carbon-cache]"   string => ".*carbon-cache.*";
      "pattern[cassandra]"      string => ".*jsvc\.exec.*apache-cassandra\.jar.*";
      "pattern[ssh]"            string => ".*sshd.*";

      "ezconf[ntpd]"            string => "ntp";
      "pattern[ntpd]"           string => ".*ntpd.*";

      "ezconf[postgresql84]"    string => "postgresql-8.4";
      "pattern[postgresql84]"   string => ".*postgresql.*";

      "ezconf[postgresql91]"    string => "postgresql-9.1";
      "pattern[postgresql91]"   string => ".*postgresql.*";

      "ezconf[www]"             string => "apache2";
      "pattern[www]"            string => ".*apache2.*";

      "ezconf[nrpe]"            string => "nagios-nrpe-server";
      "pattern[nrpe]"           string => ".*nrpe.*";

      "ezconf[omsa-dataeng]"    string => "dataeng";
      "pattern[omsa-dataeng]"   string => ".*dsm_sa_datamgr.*";


      # METHODS that implement these ............................................


  classes:

      "start" expression => strcmp("start","$(state)"),
      comment => "Check if to start a service";
      "restart" expression => strcmp("restart","$(state)"),
      comment => "Check if to restart a service";
      "reload" expression => strcmp("reload","$(state)"),
      comment => "Check if to reload a service";
      "stop"  expression => strcmp("stop","$(state)"),
      comment => "Check if to stop a service";

      # Do we want to include the packages here too?

  processes:

    start::

      "$(pattern[$(service)])" ->  { "@(stakeholders[$(service)])" }

      comment => "Verify that the service appears in the process table",
      restart_class => "start_$(service)",
      ifvarclass => and(isvariable("pattern[$(service)]"));

      "$(default[pattern])" ->  { "@(stakeholders[$(service)])" }

      comment => "Verify that the service appears in the process table",
      restart_class => "start_$(service)",
      ifvarclass => and(not(isvariable("pattern[$(service)]")));

    stop::

      "$(pattern[$(service)])" -> { "@(stakeholders[$(service)])" }

      comment => "Verify that the service does not appear in the process",
      process_stop => "$(stopcommand[$(service)])",
      signals => { "term", "kill"},
      ifvarclass => and(isvariable("stopcommand[$(service)]"),isvariable("pattern[$(service)]"));

      "$(default[pattern])" -> { "@(stakeholders[$(service)])" }

      comment => "Verify that the service does not appear in the process",
      process_stop => "$(stopcommand[$(service)])",
      signals => { "term", "kill"},
      ifvarclass => and(isvariable("stopcommand[$(service)]"),not(isvariable("pattern[$(service)]")));

      "$(pattern[$(service)])" -> { "@(stakeholders[$(service)])" }

      comment => "Verify that the service does not appear in the process",
      process_stop => "$(default[prefix])/$(ezconf[$(service)]) $(state)",
      signals => { "term", "kill"},
      ifvarclass => and(not(isvariable("stopcommand[$(service)]")),isvariable("ezconf[$(service)]"),isvariable("pattern[$(service)]"));

      "$(default[pattern])" -> { "@(stakeholders[$(service)])" }

      comment => "Verify that the service does not appear in the process",
      process_stop => "$(default[prefix])/$(ezconf[$(service)]) $(state)",
      signals => { "term", "kill"},
      ifvarclass => and(not(isvariable("stopcommand[$(service)]")),isvariable("ezconf[$(service)]"),not(isvariable("pattern[$(service)]")));

      "$(pattern[$(service)])" -> { "@(stakeholders[$(service)])" }

      comment => "Verify that the service does not appear in the process",
      process_stop => "$(default[cmd])",
      signals => { "term", "kill"},
      ifvarclass => and(not(isvariable("stopcommand[$(service)]")),not(isvariable("ezconf[$(service)]")),isvariable("pattern[$(service)]"));

      "$(default[pattern])" -> { "@(stakeholders[$(service)])" }

      comment => "Verify that the service does not appear in the process",
      process_stop => "$(default[cmd])",
      signals => { "term", "kill"},
      ifvarclass => and(not(isvariable("stopcommand[$(service)]")),not(isvariable("ezconf[$(service)]")),not(isvariable("pattern[$(service)]")));

  commands:

      "$(startcommand[$(service)])" -> { "@(stakeholders[$(service)])" }
      comment => "Execute command to start the $(service) service",
      ifvarclass => and(isvariable("startcommand[$(service)]"),canonify("start_$(service)"));

      "$(default[prefix])/$(ezconf[$(service)]) $(state)" -> { "@(stakeholders[$(service)])" }
      comment => "Execute (ezconf init) command to start the $(service) service",
      ifvarclass => and(not(isvariable("startcommand[$(service)]")),isvariable("ezconf[$(service)]"),canonify("start_$(service)"));

      "$(default[cmd])" -> { "@(stakeholders[$(service)])" }
      comment => "Execute (default) command to start the $(service) service",
      ifvarclass => and(not(isvariable("startcommand[$(service)]")),not(isvariable("ezconf[$(service)]")),canonify("start_$(service)"));

    restart::
      "$(restartcommand[$(service)])" -> { "@(stakeholders[$(service)])" }
      comment => "Execute command to restart the $(service) service",
      ifvarclass => and(isvariable("restartcommand[$(service)]"));

      "$(default[prefix])/$(ezconf[$(service)]) $(state)" -> { "@(stakeholders[$(service)])" }
      comment => "Execute (ezconf init) command to restart the $(service) service",
      ifvarclass => and(not(isvariable("restartcommand[$(service)]")),isvariable("ezconf[$(service)]"));

      "$(default[cmd])" -> { "@(stakeholders[$(service)])" }
      comment => "Execute (default) command to restart the $(service) service",
      ifvarclass => and(not(isvariable("restartcommand[$(service)]")),not(isvariable("ezconf[$(service)]")));

    reload::
      "$(reloadcommand[$(service)])" -> { "@(stakeholders[$(service)])" }
      comment => "Execute command to reload the $(service) service",
      ifvarclass => and(isvariable("reloadcommand[$(service)]"));

      "$(default[prefix])/$(ezconf[$(service)]) $(state)" -> { "@(stakeholders[$(service)])" }
      comment => "Execute (ezconf init) command to reload the $(service) service",
      ifvarclass => and(not(isvariable("reloadcommand[$(service)]")),isvariable("ezconf[$(service)]"));

      "$(reloadcommand[$(service)])" -> { "@(stakeholders[$(service)])" }
      comment => "Execute (default) command to reload the $(service) service",
      ifvarclass => and(not(isvariable("reloadcommand[$(service)]")),not(isvariable("ezconf[$(service)]")));
}

