
CFEngine is a suite of programs for integrated autonomic management of
either individual or networked computers. It has existed as as
software suite since 1993 and this version published under the GNU
Public License (GPL v3) and a Commercial Open Source License (COSL).
CFEngine is Copyright by @b{CFEngine AS}, a company founded by CFEngine
author Mark Burgess.

This document describes major version 3 of CFEngine, which is a
significant departure from earlier versions, and represents the newest
and most carefully researched technology available for configuration
management. It is both simpler and more powerful.  CFEngine 3 will
exist as both free open source and commercial enterprise versions:

@itemize
@item @b{Community Edition} - a free and gratis core of the software (available now).
@item @b{Nova} - a commercial enhanced version for basic enterprise needs (available now).
@item @b{Constellation} - a commercial enhancement for larger enterprises (coming 2012).
@end itemize

This document is valid for @b{all versions} of CFEngine.  Whenever a feature is only
available in a specific version, that fact will be noted in the documentation for that
feature (if there is no note, then that feature is available in all versions).

CFEngine 3 has been changed to be both a more powerful tool and a much
simpler tool. CFEngine 3's language interface is not backwards
compatible with the CFEngine 2 configuration language, but it
interoperates with CFEngine 2 so that it is "run-time compatible".
This means that you can change over to version 3 slowly, with low risk
and at your own speed.

With CFEngine 3 you can install, configure and maintain computers
using powerful hands-free tools. You can also integrate knowledge
management and diagnosis into the processes.

CFEngine differs from most management systems in being

@itemize
@item Open software (GPL or COSL).
@item Lightweight and generic.
@item Non-reliant on a working network to function correctly.
@item Capable of making each and every host autonomous
@end itemize

@menu
* Software components::
* Core concepts::
* A renewed CFEngine::
* Installation::
* Syntax::
* Work directory::
* Decisions::
* Filenames and paths::
* Upgrading from CFEngine 2::
* Testing as a non-privilieged user::
* The bare necessities of a CFEngine 3::
* Familiiarizing yourself::
* Remote access troubleshooting::
@end menu

@node Software components
@section Software components

CFEngine 3 consists of a number of components.  The names of the programs are
intentionally different from those in CFEngine 2 to help disambiguate them (and
some CFEngine 2 components have been merged and/or eliminated).  The
starred components are new to CFEngine 3:

@menu
* cf-agent::
* cf-execd::
* cf-know::
* cf-monitord::
* cf-promises::
* cf-runagent::
* cf-serverd::
* cf-report::
* cf-key::
* cf-hub::
@end menu


@node cf-agent
@subsection cf-agent

Active agent -- responsible for maintaining promises about the state of
    your system (in CFEngine 2 the agent was called @code{cfagent}).
    You can run @code{cf-agent} manually, but if you want to have it
    run on a regular basis, you should use @ref{cf-execd, ,cf-execd}
    (instead of using @code{cron}).

@code{cf-agent} keeps the promises made in @ref{Bundles for common, ,common}
and @ref{Bundles for agent, ,agent} bundles, and is affected by
@ref{control common, , common} and @ref{control agent, ,agent}
control bodies.

@node cf-execd
@subsection cf-execd
Scheduler -- responsible for running cf-agent on a regular (and
    user-configurable) basis (in CFEngine 2 the scheduler was called
    @code{cfexecd}).

EXECUTOR
@code{cf-execd} keeps the promises made in @ref{Bundles for common, ,common}
bundles, and is affected by
@ref{control common, , common} and @ref{control executor, ,executor}
control bodies.

@node cf-know
@subsection cf-know*
Knowledge modelling agent -- responsible for building and analysing a
       semantic knowledge network.

@code{cf-know} keeps the promises made in @ref{Bundles for common, ,common}
and @ref{Bundles for knowledge, ,knowledge} bundles, and is affected by
@ref{control common, , common} and @ref{control knowledge, ,knowledge}
control bodies.

@node cf-monitord
@subsection cf-monitord

Passive monitoring agent -- responsible for collecting information about
    the status of your system (which can be reported upon or used to
    enforce promises or influence when promises are enforced).  In CFEngine 2
    the passive monitoring agent was known as @code{cfenvd}.

@code{cf-monitord} keeps the promises made in @ref{Bundles for common, ,common}
and @ref{Bundles for monitor, ,monitor} bundles, and is affected by
@ref{control common, , common} and @ref{control monitor, ,monitor}
control bodies.

@node cf-promises
@subsection cf-promises
Promise validator -- used to verify that the promises used by the other
    components of CFEngine are syntactically valid.
@code{cf-promises} does not execute any promises, but can syntax-check
all of them.

@node cf-runagent
@subsection cf-runagent

Remote run agent -- used to execute @code{cf-agent} on a remote machine (in
    CFEngine 2 the remote run agent was called @code{cfrun}).
@code{cf-runagent} does not keep any promises, but instead is used to ask
another machine to do so.

@node cf-serverd
@subsection cf-serverd
Server -- used to distribute policy and/or data files to clients requesting
    them and used to respond to requests from @code{cf-runagent} (in  
    CFEngine 2 the remote run agent was called @code{cfservd}).

@code{cf-serverd} keeps the promises made in @ref{Bundles for common, ,common}
and @ref{Bundles for server, ,server} bundles, and is affected by
@ref{control common, , common} and @ref{control server, ,server}
control bodies.

@node cf-report
@subsection cf-report
Self-knowledge extractor -- takes data stored in CFEngine's embedded
    databases and converts them to human readable form

@code{cf-report} keeps the promises made in @ref{Bundles for common, ,common}
bundles, and is affected by
@ref{control common, , common} and @ref{control reporter, ,reporter}
control bodies.

@node cf-key
@subsection cf-key
Key generation tool -- run once on every host to create public/private key
    pairs for secure communication (in CFEngine 2 the key generation tool
    was called @code{cfkey}).  @code{cf-key} does not keep any promises.

@node cf-hub
@subsection cf-hub
A data aggregator used as part of the commercial product. This stub is not
used in the community edition of CFEngine.



@node Core concepts
@section Core concepts

Unlike previous versions of CFEngine, which had no consistent model
for its features, you can recognize @i{everything} in CFEngine 3
from just a few concepts.

@table @i
@item Promise
A declaration about the @i{state} we desire to maintain (@i{e.g.,} the permissions
or contents of a file, the availability or absence of a service, the
(de)installation of a package).
@item Promise bundles
A collection of promises.
@item Promise bodies
A part of a promise which details and constrains its nature.
@item Data types
An interpretation of a scalar value: string, integer or real number.
@item Variables
An association of the form "LVALUE @i{represents} RVALUE", where rval may be a scalar value or a list of scalar values.
@item Functions
Built-in parameterized rvalues.
@item Classes
CFEngine's boolean classifiers that describe context.
@end table


If you have used CFEngine before then the most visible part of
CFEngine 3 will be its new language interface.  Although it has been
clear for a long time that the organically grown language used in
CFEngine 1 and 2 developed many problems, it was not immediately
clear exactly what would be better. It has taken years of research to
simplify the successful features of CFEngine to a single overarching
model. To understand the new CFEngine, it is best to set aside any
preconceptions about what CFEngine is today. CFEngine 3 is a genuine
"next generation" effort, which will be a springboard into the
future of system management.

@node A renewed CFEngine
@section A renewed CFEngine


CFEngine 3 is a significant rewrite of underlying CFEngine technology
which preserves the core principles and methodology of CFEngine's
tried and tested approach.  It comes with a new, improved language,
with a consistent syntax and powerful pattern expression features that
display the intent behind CFEngine code more clearly. The main goal in
changing the language is to simplify and improve the robustness and
functionality without sacrificing the basic freedoms and self-repairing
concepts.

CFEngine 3's new language is a direct implementation of a model
developed at Oslo University College over the past four years, known
colloquially as "Promise Theory".  Promises were originally introduced
by Mark Burgess as a way to talk about CFEngine's model of autonomy
and have since become a powerful way of modelling cooperative systems
-- not just computers, but humans too.

@quotation

@i{   ``The biggest challenge of implementing CFEngine in our organization@*
     was not technical but political -- getting everyone to agree.@*
     Promise theory was a big help in understand this.''}

@end quotation

CFEngine 3 is a generic implementation of the language of promises
that allows all of the aspects of configuration and change management to be
unified under a single umbrella.

Why talk about promises instead of simply talking about changes? After
all, the trend in business and IT management today is to talk about
Change Management (with capital letters), e.g. in the IT
Infrastructure Library (ITIL) terminology.  This comes from a long
history of process management thinking. But we are not really
interested in change -- we are interested in avoiding it, i.e. being
in a state where we don't need to make any changes. In other words we
want to be able to promise that the system is correct, verify this and
only make changes if our promises are not kept. If you want
to think ITIL, think of this as a service that CFEngine provides.

To put it another way, CFEngine is not really a @i{change
management} system, it is a @i{maintenance system}. Maintenance
is the process of making small changes or corrections to a model. A
`model' is just another word for a template or a specification of how
we want the system to work. CFEngine's model is based on the idea of
promises, which means that it focuses on what is stable and lasting
about a system -- not about what is changing.


This is an important philosophical shift. It means we are focused
mainly on what is right and not on what is wrong. By saying what
"right" is (the ideal state of our system) we are focused on the
actual behaviour. If we focus too much on the changes, i.e. the
differences between now and the future, we might forget to verify that what
we assume is working now in fact works.


Models that talk about change management tend to forget that after
every change there is a litany of @i{incidents} during which it is
necessary to repair the system or return it to its intended state.
But if we know what we have promised, it is easy to verify whether the
promise is kept.
This means that it is the @i{promises} about how the system should
be that are most important, not the actual changes that are made in
order to keep them.




@node Installation
@section Installation

In order to install CFEngine, you should first ensure that the following
packages are installed.

@table @r
@item @b{OpenSSL}
Open source Secure Sockets Layer for encryption.@*URL: @url{http://www.openssl.org}
@item @b{Tokyo Cabinet} (version 1.4.42 or later)
Lightweight flat-file database system.@*URL: @url{http://fallabs.com/tokyocabinet/}
@item @b{PCRE}
Perl Compatible Regular Expression library.@*URL: @url{http://www.pcre.org/}

@item
On Windows machines, you need to install the basic Cygwin DLL from @url{http://www.cygwin.com}
in order to run CFEngine.
@end table

Additional functionality becomes available if other libraries are present, e.g.
OpenLDAP, client libraries for MySQL and PostgreSQL, etc. It is possible to run
CFEngine without these, but related functionality will be missing.

Unless you have purchased ready-to-run binaries, or are using a
package distribution, you will need to compile CFEngine. For this you
will also need a build environment tools: @code{gcc}, @code{flex}, @code{bison}.

@noindent
The preferred method of installation is then

@smallexample
tar zxf cfengine-x.x.x.tar.gz
cd cfengine-x.x.x
./configure
make
make install
@end smallexample

@noindent
This results in binaries being installed in @file{/var/cfengine/bin}.

@node Syntax
@section Syntax, identifiers and names

The CFEngine 3 language has a few simple rules:

@itemize
@item CFEngine built-in words, and identifiers of your choosing (the names
of variables, bundles, body templates and classes) may only contain
the usual alphanumeric and underscore characters (@samp{a-zA-Z0-9_}).

@item All other `literal' data must be quoted.

@item Declarations of promise bundles
in the form:
@example
bundle @var{agent-type} identifier 
@{
...
@}
@end example

@item Declarations of promise body-parts in the form:
@example
body constraint_type template_identifier 
@{
...
@} 
@end example
matching and expanding on a reference inside a promise
of the form
@samp{constraint_type => template_identifier}.


@item CFEngine uses many `constraint expressions'
as part of the body of a promise. These take the form: left-hand-side (CFEngine word)
@samp{=>} right-hand-side (user defined data). This can take several forms:

@verbatim
cfengine_word => user_defined_template(parameters)
                 user_defined_template
                 builtin_function()
                 "quoted literal scalar"
                 { list }
@end verbatim
In each of these cases, the right hand side is a user choice.
@end itemize


@node Work directory
@section The work directory

In order to achieve the desired simplifications, it was decided to
reserve a private work area for the CFEngine tool-set.
@c chew begin Work directory

@cartouche
In CFEngine 1.x, the administrator could choose the locations of
configuration files, locks, and logging data independently. In
CFEngine 2.x, this diversity has been simplified to a single directory
which defaults to @file{/var/cfengine} (similar to @file{/var/cron}), and in
CFEngine 3.x this is preserved.
@end cartouche

@w{}
@smallexample
/var/cfengine
/var/cfengine/bin
/var/cfengine/inputs
/var/cfengine/outputs
@end smallexample
@c chew end Work directory

A trusted cache of the input files must now be maintained
in the @file{inputs} subdirectory. When CFEngine is invoked by the
scheduler, it reads only from this directory. It is up to the user to
keep this cache updated, on each host. This simplifies and
consolidates the CFEngine resources in a single place.

Unlike CFEngine 2, CFEngine 3 does not recognize the
@code{CFINPUTS} environment variable.

The @file{outputs} directory is now a record of spooled run-reports. These
are often mailed to the administrator by @code{cf-execd}, or can be copied
to another central location and viewed in an alternative browser.


@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node Decisions
@section Decisions

CFEngine decisions are made behind the scenes and the results of
certain true/false propositions are cached in Booleans referred to as
`classes'. There are no if-then-else statements in CFEngine; all
decisions are made with classes.

Classes fall into hard (discovered) and soft (user-defined) types.  A
single hard class can be one of several things:

@menu
* Hard classes::
* Class combination operators and precedence::
* Global and local classes::
@end menu

@node Hard classes
@subsection CFEngine hard classes

CFEngine runs on every computer individually and each time it wakes up
the underlying generic agent platform discovers and classifies
properties of the environment or context in which it runs.  This information
is cached and may be used to make decisions about configuration@footnote{There are
no if-then-else statements in CFEngine; all decisions are made with classes.}.

Classes fall into hard (discovered) and soft (defined) types.  A
single class can be one of several things:

@c chew start Hard classes

@itemize @bullet

@item The name of an operating system architecture e.g.  @code{ultrix}, @code{sun4}, etc.

@item The unqualified name of a particular host (e.g., @code{www}). If your
system returns a fully qualified domain name for your host (e.g.,
@code{www.iu.hio.no}), CFEngine will also define a hard class for the fully
qualified name, as well as the partially-qualified component names
@code{iu.hio.no}, @code{hio.no}, and @code{no}.

@item The name of a user-defined group of hosts.

@item A day of the week (in the form @code{Monday, Tuesday, Wednesday, ..}).

@item An hour of the day, in the current time zone (in the form @code{Hr00,
Hr01 ... Hr23}).

@item An hour of the day GMT (in the form @code{GMT_Hr00, GMT_Hr01 ... GMT_Hr23}).
This is consistent the world over, in case you need virtual simulteneity of change
coordination.

@item Minutes in the hour (in the form @code{Min00, Min17 ... Min45}).

@item A five minute interval in the hour (in the form @code{Min00_05, Min05_10 ... Min55_00}).

@item A fifteen minute (quarter-hour) interval (in the form @code{Q1, Q2,
Q3, Q4}).

@item An expression of the current quarter hour (in the form @code{Hr12_Q3}).

@item A day of the month (in the form @code{Day1, Day2, ... Day31}).

@item A month (in the form @code{January, February, ... December}).

@item A year (in the form @code{Yr1997, Yr2004}).

@item A shift in @code{Night,Morning,Afternoon,Evening}, which fall into six hour blocks
starting at 00:00 hours.

@item A `lifecycle index', which is the year number modulo 3 (in the form
@code{Lcycle_0, Lcycle_1, Lcycle_2}, used in long term resource memory).

@item An arbitrary user-defined string (as specified in the @code{-D} command
line option, or defined in a @code{classes} promise or body,
@code{restart_class} in a @code{processes} promise, etc).

@item The IP address octets of any active interface (in the form @code{@w{ipv4_192_0_0_1}},
@code{@w{ipv4_192_0_0}}, @code{@w{ipv4_192_0}}, @code{@w{ipv4_192}}),
provided they are not excluded by a regular expression in the file @file{WORKDIR/inputs/ignore_interfaces.rx}.

@item The names of the active interfaces (in the form @code{net_iface_xl0},
@code{net_iface_vr0}).

@item System status and entropy information reported by @code{cf-monitord}.

@item On Solaris-10 systems, the zone name (in the form @code{zone_global,
zone_foo, zone_baz}).

@end itemize

@c chew end Hard classes

To see all of the classes defined on a particular host, run

@smallexample
host# cf-promises -v
@end smallexample
as a privileged user. Note that some of the classes are set only
if a trusted link can be established with cf-monitord, i.e. if both
are running with privilege, and the @file{/var/cfengine/state/env_data}
file is secure. More information about classes can be found in connection with
@code{allclasses}.

@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node Class combination operators and precedence
@subsection Class combination operators and precedence

Classes may be combined with the usual boolean operators, in the usual precedence (AND binds
stronger than OR). On addition the dot may be used for AND to improve readability, or
imply the interpretation `subset' or `subclass'. In order of precedence:

@table @samp
@item ()
The parenthesis group operator.
@item !
The NOT operator.
@item .
The AND operator.
@item &
The AND operator (alternative).
@item |
The OR operator.
@item ||
The OR operator (alternative).
@end table

@noindent
So the following expression would be only true on Mondays or Wednesdays
from 2:00pm to 2:59pm on Windows XP systems:

@example

(Monday|Wednesday).Hr14.WinXP::

@end example



@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node Global and local classes
@subsection Global and local classes

User defined classes are mostly defined in bundles, but they are used as a
signalling mechanism between promises. We'll return to those in a moment.

Classes promises define new classes based on combinations of old ones.
This is how to make complex decisions in CFEngine, with readable results.
It is like defining aliases for class combinations.
Such class `aliases' may be specified in any kind of bundle.
Bundles of type @code{common} yield classes that are global in scope,
whereas in all other bundle types classes are local.  Classes are
evaluated when the bundle is evaluated (and the bundles are evaluated
in the order specified in the @code{bundlesequence}).  Consider the
following example.

@verbatim

body common control
{
bundlesequence => { "g","tryclasses_1", "tryclasses_2" };
}

#################################

bundle common g
{
classes:

  "one" expression => "any";

}

#################################

bundle agent tryclasses_1
{
classes:

  "two" expression => "any";
}

#################################

bundle agent tryclasses_2
{
classes:

  "three" expression => "any";

reports:

  one.three.!two::

    "Success";
}

@end verbatim

Here we see that class @samp{one} is global (because it is defined inside the
@code{common} bundle), while classes @samp{two} and @samp{three} are local (to
their respective bundles).
The report result `Success' is therefore true because only @samp{one} and
@samp{three} are in scope (and @samp{two} is @i{not} in scope) inside of the
third bundle.

Note that any class promise must have one - and only one - value
constraint. That is, you might not leave @samp{expression} in the
example above or add both @samp{and} and @samp{xor} constraints to the
single promise.

Another type of class definition happens when you define classes based on the
outcome of a promise, e.g. to set a class if a promise is repaired, one might write:

@verbatim
 "promiser..."

    ...

    classes => if_repaired("signal_class");
@end verbatim

These classes are global in scope. Finally @code{restart_class} classes in @code{processes}
are global.

@c -------------------------------------------------------------------------------
@c SECTION
@c -------------------------------------------------------------------------------

@node Filenames and paths
@section Filenames and paths

@c chew start Unix filenames

Filenames in Unix-like operating systems use the forward slash
@samp{/} character for their directory separator . All references to
file locations must be absolute pathnames in CFEngine, i.e. they must
begin with a complete specification of which directory they are
in. For example:

@smallexample
/etc/passwd
/var/cfengine/masterfiles/distfile
@end smallexample
@noindent
The only place where it makes sense to refer to a file without a complete
directory specification is when searching through directories for different
kinds of file, e.g. in pattern matching

@verbatim

leaf_name => { "tmp_.*", "output_file", "core" };

@end verbatim

@noindent
Here, one can write @file{core} without a path, because one is looking for any
file of that name in a number of directories.
@c chew end Unix filenames

@c chew start Windows filenames
The Windows operating systems traditionally use a different filename
convention.  The following are all valid absolute file names under
Windows:

@smallexample
 c:\winnt
 "c:\spaced name"
 c:/winnt
 /var/cfengine/inputs
 //@var{fileserver}/share2/dir
@end smallexample
The `drive' name ``C:'' in Windows refers to a partition or device. Unlike Unix,
Windows does not integrate these seamlessly into a single file-tree.
This is not a valid absolute filename:

@smallexample
\var\cfengine\inputs
@end smallexample
Paths beginning with a backslash are assumed to be win32 paths.  They
must begin with a drive letter or double-slash server name.
@c chew end Windows filenames

Note in recent versions of Cygwin you can decide to use the
@code{/cygdrive} to specify a path to windows file E.g
@file{/cygdrive/c/myfile} means @file{c:\myfile} or you can do it straight away in
CFEngine as @code{c:\myfile}.

@c ---------------------------------------------------------------------------
@node Upgrading from CFEngine 2
@section Upgrading from CFEngine 2

CFEngine 3 has a completely new syntax, designed to solve the issues
brought up from 15 years of experience with configuration
management. Rather than clutter CFEngine 3 with buggy
backward-compatability issues, it was decided to make no compromises
with CFEngine 3 and instead allow CFEngine 2 and CFEngine 3 to
coincide in a cooperative fashion for the foreseeable future.  This
means that users can upgrade at their own pace, in the classic
CFEngine incremental fashion. We expect that CFEngine 2 installations
will be around for years to come so this upgrade path seems the most
defensible.

The daemons and support services are fully interoperable between
CFEngine 2 and CFEngine 3, so it does not matter whether you run
@code{cfservd} (cf2) together with @code{cf-agent} (cf3) or
@code{cf-serverd} (cf3) together with @code{cfagent} (cf2). You can
change the servers at your own pace.

CFEngine 3's @code{cf-execd} replaces CFEngine 2's @code{cfexecd} and
it is designed to work optimally with @code{cf-agent} (cf3). Running
this daemon has no consequences for access control, only for
scheduling @code{cf-agent}. You can (indeed should) replace
@code{cfexecd} with @code{cf-execd} immediately. You will want to
alter your @file{crontab} file to run the new component instead of the
old. The sample CFEngine 3 input files asks @code{cf-agent} to do
this automatically, simply replacing the string.

The sample @file{inputs} files supplied with CFEngine 3 contain
promises to integrate CFEngine 2 as described. What can you do to
upgrade? Here is a simple recipe that assumes you have a standardized
CFEngine 2 setup, running @code{cfexecd} in @file{crontabs} and possibly
running @code{cfservd} and @code{cfenvd} as daemons.

@enumerate

@item Install the CFEngine 3 software on a host.

@item Go to the @file{inputs/} directory in the source and copy these
files to your master update repository, i.e.  where you will publish
policies for distribution.

@item Remove any self-healing rules to reinstall CFEngine 2, especially
rules to add @code{cfexecd} or @code{cfagent} to @file{crontabs} etc. CFEngine 3
will handle this from now on and encapsulate old CFEngine 2 scripts.

@item Move to this inputs directory: @code{cd @var{your-path}/inputs}.

@item Set the location of this master update directory in the @file{update.cf}
file to the location of the master directory.

@item Set the email options for the executor in @file{promises.cf}.

@item Run @code{cf-agent --bootstrap} as the root or privileged user. This will install
CFEngine 3 in place of CFEngine 2, integrate your old CFEngine 2
configuration, and warn you about any rules that need to be removed
from your old CFEngine configuration.

@item You should now be running CFEngine 3. You can now add new rules to the files
in your own time, or convert the old CFEngine 2 rules and gradually comment them
out of the CFEngine 2 files.

@item Make sure there are no rules in your old CFEngine 2 configuration to activate
CFEngine 2 components, i.e. rules that will fight against CFEngine 3.
Then, when you are ready, convert @file{cfservd.conf} into a server bundle e.g. in @file{promises.cf}
and remove all rules to run @code{cfservd} and replace them with rules to run
@code{cf-serverd} at your own pace.

@end enumerate


@c ---------------------------------------------------------------------------
@node Testing as a non-privilieged user
@section Testing as a non-privilieged user

One of the practical advantages of CFEngine is that you can test it
without the need for root or administrator privileges. This is
recommended for all new users of CFEngine 3.

CFEngine operates with the notion of a work-directory. The default
work directory for the @code{root} user is @file{/var/cfengine}
(except on Debian Linux and various derivatives which prefer
@file{/var/lib/cfengine}).  For any other user, the work directory
lies in the user's home directory, named @file{~/.cfagent}. CFEngine
prefers you to keep certain files here.  You should not resist this
too strongly or you will make unnecessary trouble for yourself.  The
decision to have this `known directory' was made to simplify a lot of
configuration.

To test CFEngine as an ordinary user, do the following:

@itemize
@item Compile and make the software.
@item Copy the binaries into the work directory:
@smallexample
host$ mkdir -p ~/.cfagent/inputs
host$ mkdir -p ~/.cfagent/bin
host$ cd src
host$ cp cf-* ~/.cfagent/bin
host$ cd ../inputs
host$ cp *.cf ~/.cfagent/inputs
@end smallexample
@end itemize

You can test the software and play with configuration files by editing the basic get-started files
directly in the @file{~/.cfagent/inputs} directory. For example, try the following:

@smallexample
host$ ~/.cfagent/bin/cf-promises
host$ ~/.cfagent/bin/cf-promises --verbose
@end smallexample

This is always the way to start checking a configuration in CFEngine
3. If a configuration does not pass this check/test, you will not be
allowed to use it, and @file{cf-agent} will look for the file
@file{failsafe.cf}.

Notice that the CFEngine 3 binaries have slightly different names than the CFEngine
2 binaries. They all start with the @file{cf-} prefix.
@smallexample
host$ ~/.cfagent/bin/cf-agent
@end smallexample


@c ---------------------------------------------------------------------------
@node The bare necessities of a CFEngine 3
@section The `bare necessities' of a CFEngine 3

Here is the simplest `Hello world' program in CFEngine 3:

@verbatim

body common control
{
bundlesequence  => { "test" };
}

bundle agent test
{
reports:

 Yr2009::
    "Hello world";
}

@end verbatim

@noindent If you try to process this using the @code{cf-promises} command, you will
see something like this:

@smallexample
atlas$ ~/LapTop/CFEngine3/trunk/src/cf-promises -r -f ./unit_null_config.cf
Summarizing promises as text to ./unit_null_config.cf.txt
Summarizing promises as html to ./unit_null_config.cf.html
@end smallexample

@noindent The @samp{-r} option produces a report. Examine the files produced:

@smallexample
cat ./unit_null_config.cf.txt
firefox ./unit_null_config.cf.html
@end smallexample

You will see a summary of how CFEngine interprets the files, either in
HTML or text. By default, the CFEngine components also dump a debugging
file, e.g. @file{promise_output_agent.html}, @file{promise_output_agent.txt}
with an expanded view.

@c ---------------------------------------------------------------------------
@node Familiiarizing yourself
@section Familiarizing yourself


To familiarize yourself with CFEngine 3, type or paste in the following example text:

@verbatim
########################################################
#
# Simple test execution
#
########################################################

body common control

{
bundlesequence  => { "testbundle"  };
}

########################################################

bundle agent testbundle

{
vars:

  "size" int => "46k";
  "rand" int => randomint("33","$(size)");

commands:

  "/bin/echo"
     args => "Hello world - $(size)/$(rand)",
     contain => standard,
     classes => cdefine("followup","alert");

  followup::

     "/bin/ls"
       contain => standard;

reports:

  alert::

     "What happened?";

}

######################################################################

body contain standard

{
exec_owner => "mark";
useshell => "true";
}

######################################################################

body classes cdefine(class,alert)

{
promise_repaired => { "$(class)" };
repair_failed => { "$(alert)" };
}
@end verbatim

This example shows all of the main features of CFEngine: bundles,
bodies, control, variables, and promises.  To the casual eye it might
look complex, but that is because it is explicit about all of the
details. Fortunately it is easy to hide many of these details to
make the example simpler without sacrificing any functionality.


The first thing to try with this example is to verify it -- did we
make any mistakes? Are there any inconsistencies? To do this we use
the new CFEngine program @code{cf-promises}. Let's assume that you
typed this into a file called @file{test.cf} in the current directory.

@smallexample
cf-promises -f ./test.cf
@end smallexample

If all is well, typing this command shows no output. Try now running the
command with verbose output.

@smallexample
cf-promises -f ./test.cf -v
@end smallexample

Now you see a lot of information

@smallexample
Reference time set to Sat Aug  2 11:26:06 2008

cf3 CFEngine - 3.0.0
Free Software Foundation 1994-
Donated by Mark Burgess, Oslo University College, Norway
cf3 ------------------------------------------------------------------------
cf3 Host name is: atlas
cf3 Operating System Type is linux
cf3 Operating System Release is 2.6.22.18-0.2-default
cf3 Architecture = x86_64
cf3 Using internal soft-class linux for host linux
cf3 The time is now Sat Aug  2 11:26:06 2008
cf3 ------------------------------------------------------------------------
cf3 Additional hard class defined as: 64_bit
cf3 Additional hard class defined as: linux_2_6_22_18_0_2_default
cf3 Additional hard class defined as: linux_x86_64
cf3 Additional hard class defined as: linux_x86_64_2_6_22_18_0_2_default
cf3 GNU autoconf class from compile time: compiled_on_linux_gnu
cf3 Interface 1: lo
cf3 Trying to locate my IPv6 address
cf3 Looking for environment from cf-monitord...
cf3 Unable to detect environment from cf-monitord
---------------------------------------------------------------------
Loading persistent classes
---------------------------------------------------------------------

---------------------------------------------------------------------
Loaded persistent memory
---------------------------------------------------------------------
cf3   > Parsing file ./test.cf
---------------------------------------------------------------------
Agent's basic classified context
---------------------------------------------------------------------


Defined Classes = ( any Saturday Hr11 Min26 Min25_30 Q2 Hr11_Q2 Day2
August Yr2008 linux atlas 64_bit linux_2_6_22_18_0_2_default x86_64
linux_x86_64 linux_x86_64_2_6_22_18_0_2_default
linux_x86_64_2_6_22_18_0_2_default__1_SMP_2008_06_09_13_53_20__0200
compiled_on_linux_gnu net_iface_lo )

Negated Classes = ( )

Installable classes = ( )
cf3 Wrote expansion summary to promise_output_common.html
cf3 Inputs are valid
@end smallexample


The last two lines of this are of interest. Each time a component of
CFEngine 3 parses a number of promises, it summarizes the information
in an HTML file called generically @code{promise_output_@i{component-type}.html}.
In this case the @code{cf-promises} command represents all possible promises,
by the type "common". You can view this output file in a suitable web browser
to see exactly what CFEngine has understood by the configuration.


Now that you have verified it, you can execute it. To run this example you need
to change the username `mark' to your own, or obtain root privileges to change
to another user. 
The non-verbose output of the script when run in the CFEngine 3
directory looks something like this:

@verbatim
host$ ./cf-agent -f ../tests/units/unit_exec_in_sequence.cf
Q ".../bin/echo Hello": Hello world - 46k/219
 -> Last 1 QUOTEed lines were generated by "/bin/echo Hello world - 46k/219"
Q ".../bin/ls": agent.c
Q ".../bin/ls": agentdiagnostic.c
Q ".../bin/ls": agentdiagnostic.o
Q ".../bin/ls": agent.o
Q ".../bin/ls": args.c
Q ".../bin/ls": args.lo
Q ".../bin/ls": args.o
...
Q ".../bin/ls": verify_reports.o
Q ".../bin/ls": verify_storage.c
Q ".../bin/ls": verify_storage.o
 -> Last 288 QUOTEed lines were generated by "/bin/ls"
atlas$
@end verbatim



@c ---------------------------------------------------------------------------
@node Remote access troubleshooting
@section Remote access troubleshooting

@menu
* Server connection::           
* Key exchange::                
* Time windows::                
* Other users than root::       
* Encryption::                  
@end menu

@node Server connection
@subsection Server connection

When setting up @code{cf-serverd}, you might see the error message

@verbatim
  Unspecified server refusal
@end verbatim

This means that @code{cf-serverd} is unable or is unwilling to
authenticate the connection from your client machine. The message is
generic: it is deliberately non-specific so that anyone attempting to
attack or exploit the service will not be given information which
might be useful to them. There is a simple checklist for curing this
problem:

@enumerate
@item
Make sure that the domain variable is set in the configuration files read by both client
and server; alternatively use @code{skipidentify} and @code{skipverify} to decouple DNS from the
the authentication.

@item
Make sure that you have granted access to your client in the server body

@smallexample

body server control
@{
allowconnects         => @{ "127.0.0.1" , "::1" @var{...etc} @};
allowallconnects      => @{ "127.0.0.1" , "::1" @var{...etc} @};
trustkeysfrom         => @{ "127.0.0.1" , "::1" @var{...etc} @};
@}

@end smallexample

@item
Make sure you have created valid keys for the hosts using @code{cf-key}.
@item
If you are using secure copy, make sure that you have created a key
file and that you have distributed and installed it to all
participating hosts in your cluster.
@end enumerate

@noindent Always remember that you can run CFEngine in verbose or
debugging modes to see how the authentication takes place:

@verbatim
cf-agent -v
cf-serverd -v
@end verbatim

@code{cf-agent} reports that access is denied regardless of the nature
of the error, to avoid giving away information which might be used by
an attacker. To find out the real reason for a denial, use verbose @samp{-v} or
even debugging mode @samp{-d2}.


@node Key exchange
@subsection Key exchange

The key exchange model used by CFEngine is based on that used by
OpenSSH. It is a peer to peer exchange model, not a central
certificate authority model. This means that there are no scalability
bottlenecks (at least by design, though you might introduce your own
if you go for an overly centralized architecture).

The problem of key distribution is the conundrum of every public key
infrastructure. Key exchange is handled automatically by CFEngine and all you
need to do is to decide which keys to trust.

When public keys are offered to a server, they could be accepted
automatically on trust because no one is available to make a decision
about them. This would lead to a race to be the first to submit a key
claiming identity.

Even with DNS checks for correct name/IP address correlation (turned
off with @code{skipverify}), it might be possible to submit a false
key to a server.

The server @code{cf-serverd} blocks the acceptance of unknown keys by
default. In order to accept such a new key, the IP address of the
presumed client must be listed in the @code{trustkeysfrom} stanza of a
@code{server} bundle (these bundles can be placed in any file). Once a
key has been accepted, it will never be replaced with a new key, thus
no more trust is offered or required.

Once you have arranged for the right to connect to the server, you
must decide which hosts will have access to which files. This is done
with @code{access} rules.

@verbatim

bundle server access_rules()

{
access:

  "/path/file"

    admit   => { "127.0.0.1", "127.0.0.2", "127.0.0.3" },
    deny    => { "192\..*" };
}

@end verbatim

On the client side, i.e. @code{cf-runagent} and @code{cf-agent}, there are three issues:

@enumerate
@item
Choosing which server to connect to.
@item
Trusting the identity of any previously unknown servers, i.e. trusting
the server's public key to be its and no one else's. (The issues here are
the same as for the server.)
@item
Choosing whether data transfers should be encrypted (with @code{encrypt}).
@end enumerate

Because there are two clients for connecting to @code{cf-serverd}
(@code{cf-agent} and @code{cf-runagent}), there are also two ways of
managing trust of server keys by a client. One is an automated option, setting the option
@code{trustkey} in a @code{copy_from} stanza, e.g.

@verbatim

body copy_from example
     {
     # .. other settings ..
     trustkey => "true";
     }

@end verbatim

Another way is to run @code{cf-runagent} in interactive mode. When you run @code{cf-runagent}, unknown
server keys are offered to you interactively (as with @code{ssh}) for you to
accept or deny manually:

@smallexample

WARNING - You do not have a public key from host ubik.iu.hio.no = 128.39.74.25
          Do you want to accept one on trust? (yes/no)
-->

@end smallexample

@node Time windows
@subsection Time windows (races)

Once public keys have been exchanged from client to server and from
server to client, the issue of trust is solved according to public key
authentication schemes. You only need to worry about trust when one side
of a connection has never seen the other side before.

Often you will have a central server and many client satellites. Then
the best way to transfer all the keys is to set the @code{trustkey}
flags on server and clients sides to coincide with a time at which you
know that @code{cf-agent} will be run, and when a spoofer is unlikely
to be able to interfere.

This is a once-only task, and the chance of an attacker being able to
spoof a key-transfer is small. It would require skill and
inside-information about the exchange procedure, which would tend to
imply that the trust model was already broken.

Another approach would be to run @code{cf-runagent} against all the hosts
in the group from the central server and accept the keys one by one,
by hand, though there is little to be gained from this.

Trusting a host for key exchange is unavoidable. There is no clever
way to avoid it. Even transferring the files manually by diskette, and
examining every serial number of the computers you have, the host has
to trust the information you are giving it. It is all based on
assertion. You can make it almost impossible for keys to be faked
or attacked, but you cannot make it absolutely impossible. Security is
about managing reasonable levels of risk, not about magic.

All security is based on a moment of trust, that is granted by a user
at some point in time -- and is assumed thereafter (once given, hard
to rescind). Cryptographic key methods only remove the need for a
repeat of the trust decision. After the first exchange, trust is no
longer needed, because they keys allow identity to be actually
verified.

Even if you leave the trust options switched on, you are not blindly
trusting the hosts you know about. The only potential insecurity lies
in any new keys that you have not thought about. If you use wildcards
or IP prefixes in the trust rules, then other hosts might be able to
spoof their way in on trust because you have left open a hole for them
to exploit. That is why it is recommended to return the system to the
default state of zero trust immediately after key transfer, by
commenting out the trust options.


It is possible, though somewhat laborious to transfer the keys out of
band, by copying @file{/var/cfengine/ppkeys/localhost.pub} to
@code{/var/cfengine/ppkeys/user-aaa.bbb.ccc.mmm} (assuming IPv4) on
another host. e.g.

@smallexample

localhost.pub -> root-128.39.74.71.pub

@end smallexample

This would be a silly way to transfer keys between nearby hosts that you
control yourself, but if transferring to long distance, remote hosts
it might be an easier way to manage trust.

@node Other users than root
@subsection Other users than root

CFEngine normally runs as user "root" (except on Windows which does
not normally have a root user), i.e. a privileged administrator. If other users
are to be granted access to the system, they must also generate a key
and go through the same process. In addition, the users must be added
to the server configuration file.

@node Encryption
@subsection Encryption

CFEngine provides encryption for keeping file contents private during
transfer. It is assumed that users will use this judiciously. There is
nothing to be gained by encrypting the transfer of public files --
overt use of encryption just contributes to global warming, burning
unnecessary CPU cycles without offering any security.

The main role for encryption in configuration management is for
authentication. CFEngine always uses encryption during authentication, so
none of the encryption settings affect the security of authentication.




@c ---------------------------------------------------------------------------
@node A simple crash course
@chapter  A simple crash course in concepts

@menu
* Rules are promises::          
* Best practice for writing promises::  
* Containers::                  
* When and where are promises made?::  
* Types in CFEngine 3::         
* Datatypes in CFEngine 3::     
* Variable expansion in CFEngine 3::  
* Name spaces::
* Normal ordering::             
* Loops and lists in CFEngine 3::  
* Pattern matching and referencing::  
* Distributed discovery::       
@end menu

@node Rules are promises
@section Rules are promises

Everything in CFEngine 3 can be interpreted as a promise. Promises can
be made about all kinds of different subjects, from file attributes,
to the execution of commands, to access control decisions and
knowledge relationships.

This simple but powerful idea allows a very practical uniformity in
CFEngine syntax.  There is only one grammatical form for statements in
the language that you need to know and it looks generically like this:

@smallexample

 type:

   classes::

    "promiser" -> @{ "promisee1", "promisee2", ... @}

       attribute_1 => value_1,
       attribute_2 => value_2,
       ...
       attribute_n => value_n;

@end smallexample

@noindent
We speak of a promiser (the abstract object making the promise), the promisee
is the abstract object to whom the promise is made, and them there is a list
of associations that we call the `body' of the promise, which together with the
promiser-type tells us what it is all about.

Not all of these elements are necessary every time. Some promises contain a lot
of implicit behaviour. In other cases we might want to be much more explicit.
For example, the simplest promise looks like this:

@smallexample

commands:

  "/bin/echo hello world";

@end smallexample

@noindent
This promise has default attributes for everything except the `promiser', i.e. the
command string that promises to execute.
A more complex promise contains many attributes:

@smallexample

files:

  "/home/mark/tmp/test_plain" -> "system blue team",

       comment => "This comment follows the rule for knowledge integration",
       perms   => users("@@(usernames)"),
       create  => "true";

@end smallexample
The list of promisees is not used by CFEngine except for documentation, just
as the comment attribute (which can be added to any promise) has no actual function
other than to provide more information to the user in error tracing and auditing.

You see several kinds of object in this example. All literal strings
(e.g. @code{"true"}) in CFEngine 3 must be quoted. This provides
absolute consistency and makes type-checking easy and error-correction
powerful. All function-like objects (e.g. @code{users("..")}) are either builtin
special functions or parameterized templates which contain the `meat' of the right hand
side.

The words @code{commands}, and @code{files} are built-in promise
types. Promise types generally belong each to a particular component
of CFEngine, as the components are designed to keep different kinds of
promises.  A few types, such as @code{vars}, @code{classes} and
@code{reports} are common to all the different component bundles. You
will find a full list of the promise types that can be made by the
different components in the `bundles' chapters that follow.

@c -----------------------------------------------------------------------
@node Best practice for writing promises
@section Best practice for writing promises

When writing promises, get into the habit of giving every promise a comment
that explains its intention.

Also, give related promises @i{handles}, or labels that can be used to
refer to them.

@verbatim

files:

  "/var/cfengine/inputs"

    handle => "update_policy",
    comment => "Update the configuration from a master server",

    perms => system("600"),
    copy_from => mycopy("$(master_location)","$(policy_server)"),
    depth_search => recurse("inf"),
    file_select => input_files,
    action => immediate;

@end verbatim
If a promise affects another promise in some way, you can make the affected
promise one of the promisees, like this:

@verbatim

access:

  "/master/cfengine/inputs" -> { "update_policy", "other_promisee" },

    comment => "Grant access to policy to our clients",
    handle  => "serve_updates",

    admit   => { "217.77.34.*" };

@end verbatim

@noindent Conversely, if a promise might depend on another in some (even indirect) way, document this too.

@verbatim

files:

  "/var/cfengine/inputs"

    comment => "Update the configuration from a master server",
    handle     => "update_policy",

    depends_on => {"serve_updates"},

    perms => system("600"),
    copy_from => mycopy("$(master_location)","$(policy_server)"),
    depth_search => recurse("inf"),
    file_select => input_files,
    action => immediate;


@end verbatim

Get into the habit of adding the cause-effect lines of influence.
Enterprise editions of CFEngine will track the dependencies between these
promises and map out impact analyses.

@c -----------------------------------------------------------------------
@node Containers
@section Containers

CFEngine allows you to group multiple promise statements
    into containers called bundles.
@smallexample

bundle agent identifier

@{
commands:

  "/bin/echo These commands are a silly way to use CFEngine";
  "/bin/ls -l";
  "/bin/echo But they illustrate a point";

@}

@end smallexample

Bundles serve two purposes: they allow us to collect related promises under a
single heading, like a subroutine, and they allow us to mix configuration for different
parts of CFEngine in the same file. The type of a bundle is the name of the component
of CFEngine for which it is intended.

For instance, we can make a self-contained example agent-server
configuration by labelling the bundles:

@smallexample

#
# Not a complete example
#

bundle agent testbundle

@{
files:

  "/home/mark/tmp/testcopy"

    comment      => "Throwaway example...",
    copy_from    => mycopy("/home/mark/LapTop/words","127.0.0.1"),
    perms        => system,
    depth_search => recurse("inf");

@}

#

bundle server access_rules

@{
access:

  "/home/mark/LapTop"

    admit   => @{ "127.0.0.1" @};
@}

@end smallexample

Another type of container in CFEngine 3 is a `body' part. Body parts
exist to hide complex parameter information in reusable containers.
The right hand side of some attribute assignments use body containers
to reduce the amount of in-line information and preserve readability.
You cannot choose where to use bodies: either they are used or they
are not used for a particular kind of attribute. What you can choose, however, is
the name and number of parameters for the body; and you can make as many of them as you like:
For example:

@smallexample

body copy_from mycopy(from,server)

@{
source      => "$(from)";
servers     => @{ "$(server)" @};
copy_backup => "true";

special_class::

  purge       => "true";
@}

@end smallexample

Notice also that classes can be used in bodies as well as parameters so that
you can hide environmental adaptations in these bodies also. The classes used
here are effectively ANDed with the classes under which the calling promise
is defined.


@c -----------------------------------------------------------------------
@node When and where are promises made?
@section When and where are promises made?

When you type a promise into a CFEngine bundle, the promise will be
read by every cf-agent that reads the file, each time it is
called into being. For some promises this is okay, but for others
you only want to verify the promise once in a while, e.g. once per day
or once per hour. There are two ways to say when and where a promise
applies in CFEngine:

@table @i
@item Classes
Classes are the double-colon decision syntax in CFEngine. They
determine in what context a promise is made, i.e. when and
where. Recall the basic syntax of a promise:
@smallexample

 @var{promise-type}:

    @var{class-expression}::

       @var{promiser} -> @var{promisee}

          @var{attribute} => @var{body},
               ifvarclass => @var{other-class-expression};

@end smallexample
The class expression may contain words like @samp{Hr12}, meaning
from 12:00 p.m - 13:00 p.m., or @samp{Hr12&Min05_10}, meaning
between 12:05 and 12:10. Classes may also have spatial descriptors
like @samp{myhost} or @samp{solaris}, which decide which hosts
in the namespace, or @samp{ipv4_192_168_1_101} which decides the location
in IPv4 address space.

If the class expression is true, the promise can be considered made
for the duration of the current execution.

CFEngine 3 has a new class predicate @code{ifvarclass} which is
ANDed with the normal class expression, and which is evaluated
together with the promise. It may contain variables as long as the
resulting expansion is a legal class expression.
@cindex ifvarclass

@item Locks
Locks determine how often a promise is verified.
@end table

CFEngine is controlled by a series of locks which prevent it from
checking promises too often, and which prevent it from spending too
long trying to verify promises it already verified recently. The locks
work in such a way that you can start several CFEngine processes
simultaneously without them interfering with each other. You can
control two things about each kind of action in the action sequence:

@table @samp

@item ifelapsed
The minimum time (in minutes) which should have passed since the last time
that promise was verified. It will not be executed again until
this amount of time has elapsed.
(Default time is 1 minute.)

@item expireafter
The maximum amount (in minutes) of time cf-agent should wait for an old
instantiation to finish before killing it
and starting again. (Default time is 120 minutes.)

@end table

@noindent
You can set these values either globally (for all
actions) or for each action separately. If you
set global and local values, the local values override
the global ones. All times are written in units
of @emph{minutes}. Global setting is in the control body:

@verbatim

body agent control
{
ifelapsed => "60";	# one hour
}

@end verbatim

@noindent
or locally in the transaction bodies:


@verbatim

body action example
{
ifelapsed => "90";	# 1.5 hours
}

@end verbatim

These locks do not prevent the whole of cf-agent from running, only
atomic promise checks. Several different atoms can be run concurrently
by different cf-agents.  The locks ensure that atoms will never be
started by two cf-agents at the same time, or too soon after a
verification, causing contention and wasting CPU cycles.


@c -----------------------------------------------------------------------
@node Types in CFEngine 3
@section Types in CFEngine 3

A key difference in CFEngine 3 compared to earlier versions is the
presence of data types. Data types are a mechanism for associating
values and checking consistency in a language. Once again, there is a
simple pattern to types in CFEngine.

The principle is very simple: types exist in order to match like a
plug-socket relationship. In the examples above, you can see two places
where types are used to match templates:

@itemize
@item Matching bundles to CFEngine components (such as agent, server, common, etc.):
@smallexample

bundle TYPE name  # matches TYPE to running agent
@{
@}

@end smallexample

@item Match bodies templates to lvalues in @code{lvalues => rvalue} constraints:

@smallexample

body TYPE name    # matches TYPE => name in promise
@{
@}

@end smallexample
@end itemize

Check these by identifying the words @samp{agent} and @samp{copy_from}
in the examples above. Types are there to make configuration more robust.

@c -----------------------------------------------------------------------
@node Datatypes in CFEngine 3
@section Datatypes in CFEngine 3

CFEngine variables have two meta-types: scalars and lists. A scalar is a single value,
a list is a collection of scalars. Each scalar may have one of three types:
@code{string}, @code{int} or @code{real}. Typing is dynamic, so these are
interchangable in many instances. However arguments to special functions check legal
type for consistency.

Integer constants may use suffixes to represent large numbers.

@itemize
  @item 'k'
          = value times 1000.

  @item 'K'
          = value times 1024.

  @item 'm'
          = value times 1000^2
  @item 'M'
          = value times 1024^2
  @item 'g'
          = value times 1000^3
  @item 'G'
          = value times 1024^3

  @item '%'
	  meaning percent, in limited contexts

  @item 'inf'
	  = a constant representing an unlimited value.
@end itemize

@c -----------------------------------------------------------------------
@node Variable expansion in CFEngine 3
@section Variable expansion in CFEngine 3

CFEngine 3 has some simple rules for variable expansion. These make
a couple of restrictions that enforce discipline of clarity and
allow automatic dependency tracking in enterprise versions of CFEngine.

@menu
* Scalar variable expansion::   
* List variable substitution and expansion::  
* Special list value cf_null::
* Arrays in CFEngine 3::        
@end menu

@node Scalar variable expansion
@subsection Scalar variable expansion

Scalar variables are written @samp{$(name)} and they represent
a single value at a time.

@itemize
@item Scalars that are written without a context, e.g. @samp{$(myvar)}
are local to the current bundle (and are equivalent to @samp{$(this.myvar)}).

@item Scalars are globally available everywhere provided one
uses the context to verify them e.g. @samp{$(context.myvar)}
may be written to access the variable `myvar' in bundle `context'.

@end itemize

@c -----------------------------------------------------------------------
@node List variable substitution and expansion
@subsection List variable substitution and expansion

@itemize

@item Scalar references to @i{local} list variables imply iteration, e.g.
suppose we have local list variable @samp{@@(list)}, then the
scalar @samp{$(list)} implies an iteration over every value of the
list.


@item Lists can be passed around in their entirety in any context
where a list is expected as @samp{@@(list)}., e.g.

@verbatim

 vars:

   "longlist" slist => { @(shortlist), "plus", "plus" };

   "shortlist" slist => { "you", "me" };

@end verbatim

@end itemize

You can pass lists to functions by parameter or by qualified reference.
The first uses parameterization to map a global list into a local
context.
@verbatim

#
# Show access of external lists.
#
# - to pass lists globally, use a parameter to dereference them
#

body common control
{
bundlesequence => { hardening(@(va.tmpdirs)) };
}

#########################################################

bundle common va
{
vars:

 "tmpdirs"  slist => { "/tmp", "/var/tmp", "/usr/tmp"  };

}

##########################################################

bundle agent hardening(x)
{
classes:

  "ok" expression => "any";

vars:

 "other"    slist => { "/tmp", "/var/tmp" };

reports:

  ok::

    "Do $(x)";
    "Other: $(other)";
}

@end verbatim

This alternative uses a direct `short-circuit' approach to map the global
list into the local context.

@verbatim
#
# Show access of external lists.
#

body common control
{
bundlesequence => { hardening };
}

#########################################################

bundle common va
{
vars:

 "tmpdirs"  slist => { "/tmp", "/var/tmp", "/usr/tmp"  };

}

##########################################################

bundle agent hardening
{
classes:

  "ok" expression => "any";

vars:

 "other"    slist => { "/tmp", "/var/tmp" };
 "x"        slist => { @(va.tmpdirs) };

reports:

  ok::

    "Do $(x)";
    "Other: $(other)";
}
@end verbatim

@c -----------------------------------------------------------------------

@node Special list value cf_null
@subsection Special list value @code{cf_null}

As of CFEngine core version 3.1.0, the value @samp{cf_null} may be used as a NULL
value within lists. This value is ignored in list variable expansion.

@verbatim

vars:

  "empty_list" slist => { "cf_null" };

@end verbatim

@c -----------------------------------------------------------------------
@node Arrays in CFEngine 3
@subsection Arrays in CFEngine 3

Array variables are written with @samp{[} and @samp{]} brackets, e.g.

@verbatim

bundle agent example

{
vars:

  "component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

  "array[cf-monitord]" string => "The monitor";
  "array[cf-serverd]" string => "The server";
  "array[cf-execd]" string => "The executor, not executioner";

commands:

   "/bin/echo $(component) is"

            args => "$(array[$(component)])";

}

@end verbatim

Arrays are associative and may be of type scalar or list. Enumerated
arrays are simply treated as a special case of associative arrays, since
there are no numerical loops in CFEngine. Special functions exist to
extract lists of keys from array variables for iteration purposes.

Thus one could have written the example above in the form of the
following example. Note, too, that the use of @code{getindices} avoids the earlier poor practice of repeating the enumeration of key names, and instead uses the better strategy of automatically deriving them.

@verbatim

bundle agent example

{
vars:

  "array[cf-monitord]" string => "The monitor";
  "array[cf-serverd]" string => "The server";
  "array[cf-exced]" string => "The executor, not executioner";

  "component" slist => getindices("array");

commands:

  "/bin/echo $(component) is"

           args => "$(array[$(component)])";
}

@end verbatim


@c -----------------------------------------------------------------------
@node Name spaces
@section Name spaces

Name spaces are private bundle and body contexts, allowing multiple files
to define the bundles and bodies with the same name, without conflict.

To isolate a file into its own name space, you add a control promise
to the file before the relevant bundles or bodies. All files start off in the
default namespace if you don't explicitly set this. Once set, this applies
until the end of the file or the next namespace change.

@verbatim
body file control
{
namespace => "myspace"; 
}
@end verbatim

To distinguish the bundle @code{mymethod} in the default namespace
from one in another namespace, you can prefix the 
@verbatim
methods:

  "namespace demo" usebundle => myspace:mymethod("arg1");

  "namespace demo" usebundle => mymethod("arg1","arg2");

@end verbatim

To distinguish a body from one in another namespace, you can prefix
the
@verbatim
files:

   "/file"

       create => "true",
        perms => name1:settings;

@end verbatim

The namespace that is default, i.e. that which is implied by not making any namespace
declarations, can be accessed or referred to by prefixing with the default string

@verbatim
files:

   "/file"

       create => "true",
        perms => default:settings;

@end verbatim
@noindent For example, this can be used to refer to standard library objects from
within a private namespace.

Global classes are not handled by namespaces, and you are advised to prefix
them with the namespace like this:

@verbatim
files:

   "/file"

       create => "true",
       action => if_repaired("namespace_done");

@end verbatim
@noindent This is not prepended automatically because references to this
class in class expressions cannot be detected and modified automatically.

To access variables or meta-data in bundles in a different namespace, use the colon
as a namespace prefix:

@verbatim

 $(namespace:bundle.variable)
 $(namespace:bundle_meta.variable)

@end verbatim


@c -----------------------------------------------------------------------
@node Normal ordering
@section Normal ordering


CFEngine takes a pragmatic point of view to ordering. When promising
`scalar' attributes and properties, ordering is irrelevant and need
not be considered. More complex patterned data structures require
ordering to be preserved, e.g. editing in files. CFEngine
solves this in a two-part strategy:
@itemize
@item CFEngine maintains a default order of promise-types. This is based
on a simple logic of what needs to come first, e.g. it makes no sense to create something
and then delete it, but it could make sense to delete and then create (an equilibrium).
This is called @i{normal ordering} and is described below.

@item You can override normal ordering in exceptional circumstances by making
a promise in a class context and defining that class based on the outcome of another
promise.
@end itemize

@menu
* Agent normal ordering::       
* Server normal ordering::      
* Monitor normal ordering::     
* Knowledge normal ordering::   
@end menu

@node Agent normal ordering
@subsection Agent normal ordering

@enumerate
@item
CFEngine tries to keep variable and class promises before starting to
consider any other kind of promise.  In this way, global variable and
classes can be set, as well as creating @code{classes} promises, upon
which later agent-bundle @code{vars} promises may depend. Place these
at the start of your configuration (see next item).

@item If you set variables based on classes that are determined by variables, in a
complex dependency chain, then you introduce an order dependence to
the resolution that might be non-unique. Since CFEngine starts trying
to converge values as soon as possible, it is best to define variables
in bundles before using them, i.e. as early as possible in your
configuration.  In general it is wise to avoid class-variable
dependency as much as possible.

@item
CFEngine executes agent promise bundles in the strict order defined by
the @code{bundlesequence} (possibly overridden by the @code{-b} or
@code{--bundlesequence} command line option).
@item
Within a bundle, the promise types are executed in a round-robin
fashion according to so-called `normal ordering' (essentially deletion
first, followed by creation). The actual sequence continues for up to three
iterations of the following, converging towards a final state:

@verbatim
   vars
   classes
   outputs
   interfaces
   files
   packages
   guest_environments
   methods
   processes
   services
   commands
   storage
   databases
   reports
@end verbatim

Within @code{edit_line} bundles in @code{files} promises
(See `File editing in CFEngine 3' for important details),
the normal ordering is:
@verbatim
   vars
   classes
   delete_lines
   field_edits
   insert_lines
   replace_patterns
   reports
@end verbatim

@item
The order of promises within one of the above types follows their
top-down ordering within the bundle itself

@item
The order may be overridden by making a promise depend on a class
that is set by another promise.

@end enumerate

@node Server normal ordering
@subsection Server normal ordering


As with the agent, common bundles are executed before any server bundles;
following this @i{all} server bundles are executed (the @code{bundlesequence}
is only used for @code{cf-agent}).
Within a server bundle, the promise types are unamgibuous.
Variables and classes are resolved in the same way as the agent.
On connection, access control must be handled first, then a role
request might be made once access has been granted. Thus ordering
is fully constrained by process with no additional freedoms.

Within a server bundle, the normal ordering is:

@verbatim
   vars
   classes
   access
   roles
@end verbatim

@node Monitor normal ordering
@subsection Monitor normal ordering

As with the agent, common bundles are executed before any monitor bundles;
following this @i{all} monitor bundles are executed (the @code{bundlesequence}
is only used for @code{cf-agent}).
Variables and classes are resolved in the same way as the agent.

Within a monitor bundle, the normal ordering is:

@verbatim
   vars
   classes
   measurements
   reports
@end verbatim

@node Knowledge normal ordering
@subsection Knowledge normal ordering

As with the agent, common bundles are executed before any knowledge bundles;
following this @i{all} knowledge bundles are executed (the @code{bundlesequence}
is only used for @code{cf-agent}).
Variables and classes are resolved in the same way as the agent.

Within a knowledge bundle, the normal ordering is:

@verbatim
   vars
   classes
   topics
   occurrences
   inferences
   reports
@end verbatim


@c -----------------------------------------------------------------------
@node Loops and lists in CFEngine 3
@section Loops and lists in CFEngine 3

There are no explicit loops in CFEngine, instead there are lists.
To make a loop, you simply refer to a list as a scalar and CFEngine
will assume a loop over all items in the list.

For example, in the examples below the list @code{component} has three
elements. The list as a whole may be referred to as
@code{@@(component)}, in order to pass the whole list to a promise
where a list is expected. However, if we write @code{$(component)},
i.e. the scalar variable, then CFEngine assumes that it should substitute
each scalar from the list in turn, and thus iterate over the list
elements using a loop.

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{
vars:

  "component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

  "new_list" slist => { "cf-know", @(component) };

processes:

  "$(component)" restart_class => canonify("start_$(component)");

commands:

   "/bin/echo /var/cfengine/bin/$(component)"

       ifvarclass => canonify("start_$(component)");
}

@end verbatim

If a variable is repeated, its value is tied throughout
the expression; so the output of:

@verbatim

body common control

{
bundlesequence  => { "example" };
}

###########################################################

bundle agent example

{
vars:

  "component" slist => { "cf-monitord", "cf-serverd", "cf-execd" };

  "array[cf-monitord]" string => "The monitor";
  "array[cf-serverd]" string => "The server";
  "array[cf-execd]" string => "The executor, not executioner";

commands:

   "/bin/echo $(component) is"

            args => "$(array[$(component)])";
}

@end verbatim

@noindent is as follows:

@verbatim

Q ".../bin/echo cf-mo": cf-monitord is The monitor
 -> Last 1 QUOTEed lines were generated by "/bin/echo cf-monitord is The monitor"
Q ".../bin/echo cf-se": cf-serverd is The server
 -> Last 1 QUOTEed lines were generated by "/bin/echo cf-serverd is The server"
Q ".../bin/echo cf-ex": cf-execd is The executor, not executioner
 -> Last 1 QUOTEed lines were generated by "/bin/echo cf-execd is The executor, not executioner"

@end verbatim


@c -----------------------------------------------------------------------
@node Pattern matching and referencing
@section Pattern matching and referencing

One of the strengths of CFEngine 3 is the ability to recognize and
exploit patterns.  All string patterns in CFEngine 3 are matched using
PCRE regular expressions.

CFEngine has the ability to extract back-references from pattern matches.
This makes sense in two cases. Back references are fragments of a string
that match parenethetic expressions. For instance, suppose we have the string:

@smallexample

 Mary had a little lamb ...

@end smallexample

@noindent and apply the regular expression

@smallexample

 "Mary ([^l]+)little (.*)"

@end smallexample
The pattern matches the entire string, and it
contains two parenthesized subexpressions, which respectively match
the fragments `had a ' and `lamb ...'. The regular
expression libraries assign @i{three} matches to this
result, labelled 0, 1 and 2.

The zeroth value is the entire string matched by the
total expression. The first value is the fragment matched
by the first parenthesis, and so on.

Each time CFEngine matches a string, these values are
assigned to a special variable context @code{$(match.@var{n})}.
The fragments can be referred to in the remainder of the promise.
There are two places where this makes sense. One is in pattern replacement
during file editing, and the other is in searching for files.

Consider the examples below:
@verbatim

bundle agent testbundle

{
files:

  # This might be a dangerous pattern - see explanation in the next section
  # on "Runaway change warning"

  "/home/mark/tmp/cf([23])?_(.*)"
       edit_line => myedit("second backref: $(match.2)");
}

@end verbatim
There are other filenames that could match this pattern, but if, for
example, there were to exist a file @file{/home/mark/tmp/cf3_test},
then we would have:

@table @samp
@item $(match.0)
equal to `/home/mark/tmp/cf3_test'
@item $(match.1)
equal to `3'
@item $(match.2)
equal to `test'
@end table

Note that because the pattern allows for an @i{optional} '2' or '3' to follow
the letters 'cf', it is possible that @code{$(match.1)} would contain the
empty string.  For example, if there was a file named
@file{/home/mark/tmp/cf_widgets}, then we would have@table @samp
@item $(match.0)
equal to `/home/mark/tmp/cf_widgets'
@item $(match.1)
equal to `'
@item $(match.2)
equal to `widgets'
@end table

Now look at the edit bundle. This takes a parameter (which is the
back-reference from the filename match), but it also uses back references to
replace shell comment lines with C comment lines  (the same
approach is used to hash-comment lines in files).  The back-reference
variables @code{$(match.@var{n})} refer to the most recent pattern match, and
so in the @samp{C_comment} body, they do not refer to the filename components,
but instead to the hash-commented line in the @samp{replace_patterns} promise.

@verbatim

bundle edit_line myedit(parameter)
  {
  vars:

   "edit_variable" string => "private edit variable is $(parameter)";

  insert_lines:

     "$(edit_variable)";

  replace_patterns:

  # replace shell comments with C comments

   "#(.*)"

      replace_with => C_comment,
     select_region => MySection("New section");

  }

########################################
# Bodies
########################################

body replace_with C_comment

{
replace_value => "/* $(match.1) */"; # backreference from replace_patterns
occurrences => "all";  # first, last, or all
}

########################################################

body select_region MySection(x)

{
select_start => "\[$(x)\]";
select_end => "\[.*\]";
}

@end verbatim

Try this example on the file
@verbatim
[First section]

one
two
three

[New section]

four
#five
six

[final]

seven
eleven
@end verbatim

@noindent The resulting file is edited like this:
@verbatim
[First section]

one
two
three

[New section]

four
/* five */
six

[final]

seven
eleven

private edit variable is second backref: test
@end verbatim

@menu
* Runaway change warning::      
* Commenting lines::            
* Regular expressions in paths::  
* Anchored vs. unanchored regular expressions::
* Special topics on Regular Expressions::  
@end menu

@node Runaway change warning
@subsection Runaway change warning

Be careful when using patterns to search for files that are altered by CFEngine
if you are not using a file repository. Each time CFEngine makes a change it
saves an old file into a copy like @file{cf3_test.cf-before-edit}. These
new files then get matched by the same expression above -- because it ends
in the generic@code{.*}), or does not
specify a tail for the expression. Thus CFEngine will happily edit backups
of the edit file too, and generate a recursive process, resulting in something
like the following:

@smallexample
cf3_test                  cf3_test.cf-before-edit
cf3_test~                 cf3_test~.cf-before-edit.cf-before-edit
cf3_test~.cf-before-edit  cf3_test~.cf-before-edit.cf-before-edit.cf-before-edit
@end smallexample

Always try to be as specific as possible when specifying patterns. A lazy approach
will often come back to haunt you.


@node Commenting lines
@subsection Commenting lines

The following example shows how you would hash-comment lines in a file
using CFEngine 3.

@verbatim
######################################################################
#
# HashCommentLines implemented in CFEngine 3
#
######################################################################

body common control

{
version => "1.2.3";
bundlesequence  => { "testbundle"  };
}

########################################################

bundle agent testbundle

{
files:

  "/home/mark/tmp/comment_test"

       create    => "true",
       edit_line => comment_lines_matching;
}

########################################################

bundle edit_line comment_lines_matching
  {
  vars:

    "regexes" slist => { "one.*", "two.*", "four.*" };

  replace_patterns:

   "^($(regexes))$"
      replace_with => comment("# ");
  }

########################################
# Bodies
########################################

body replace_with comment(c)

{
replace_value => "$(c) $(match.1)";
occurrences => "all";
}

@end verbatim

@node Regular expressions in paths
@subsection Regular expressions in paths

When applying regular expressions in paths, the path will first be
split at the path separators, and each element matched
independently. For example, this makes it possible to write
expressions like @code{"/home/.*/file"} to match a single file inside
a lot of directories --- the .* does not eat the whole string.

Note that whenever regular expressions are used in paths, the @code{/} is
always used as the path separator, even on Windows.  However, on Windows, if
the pathname is interpreted literally (no regular expressions), then the
backslash is also recognized as the path separator.  This is because the
backslash has a special (and potentially ambiguous) meaning in regular
expressions (a @code{\d} means the same as @code{[0-9]}, but on Windows it
could also be a path separator and a directory named @code{d}).

The @code{pathtype} attribute allows you to force a specific behavior when
interpreting pathnames.  By default, CFEngine looks at your pathname and
makes an educated guess as to whether your pathname contains a regular
expression.  The values @code{"literal"} and @code{"regex"} explicitly force
CFEngine to interpret the pathname either one way or another.

(see the @code{pathtype} attribute).

@verbatim

body common control
{
bundlesequence => { "wintest" };
}

########################################

bundle agent wintest
{
files:
  "c:/tmp/file/f.*"		# "best guess" interpretation
    delete => nodir;


  "c:\tmp\file"
    delete => nodir,
    pathtype => "literal";	# force literal string interpretation


  "C:/windows/tmp/f\d"
    delete => nodir,
    pathtype => "regex";	# force regular expression interpretation
}

########################################

body delete nodir
{
rmdirs => "false";
}

@end verbatim

Note that the path @samp{/tmp/gar.*} will only match filenames
like @file{/tmp/gar}, @file{/tmp/garbage} and @file{/tmp/garden}.  It will
@i{not} match filename like @file{/tmp/gar/baz} (because even though the
@samp{.*} in a regular expression means "zero or more of any character",
CFEngine restricts that to mean "zero or more of any character @i{in a path
component}").  Correspondingly, CFEngine
also restricts where you can use the @samp{/} character (you can't use it
in a character class like @samp{[^/]} or in a parenthesized or repeated
regular expression component.

This means that regular expressions which include "optional directory
components" won't work.  You can't have a files promise to tidy the directory
@samp{(/usr)?/tmp}.  Instead, you need to be more verbose and specify
@samp{/usr/tmp|/tmp}, or even better, think declaratively and create an
@i{slist} that contains both the strings @samp{/tmp} and @samp{/usr/tmp},
and then allow CFEngine to iterate over the list!

This also means that the path @samp{/tmp/.*/something} will match files like
@file{/tmp/abc/something} or @file{/tmp/xyzzy/something}.  However, even
though the pattern @samp{.*} means "zero or more of any character (except
@samp{/})", CFEngine matches files bounded by directory separators.  So even
though the pathname @file{/tmp//something} is technically the same as the
pathname @file{/tmp/something}, the regular expression @samp{/tmp/.*/something}
will @i{not} match on the degenerate case of @file{/tmp//something} (or
@file{/tmp/something}).

@node Anchored vs. unanchored regular expressions
@subsection Anchored vs. unanchored regular expressions

CFEngine uses the full power of regular expressions, but there are two ``flavors'' of regex.  Because they
behave somewhat differently (while still utilizing the same syntax), it is
important to know which one is used for a particular component of CFEngine:

@itemize

@item
An ``anchored'' regular expression will only successfully match an
entire string, from start to end.  An anchored regular expression
behaves as if it starts with @samp{^} and ends with @samp{$}, whether
you specify them yourself or not.  Furthermore, an anchored regular
expression cannot have these automatic anchors removed.

@item
An ``unanchored'' regular expression may successfully match anywhere
in a string.  An unanchored regex may use anchors (such as @samp{^},
@samp{$}, @samp{\A}, @samp{\Z}, @samp{\b}, etc.) to restrict where
in the string it may match.  That is, an unanchored regular expression
may be easily converted into a partially- or fully-anchored regex.

@end itemize

For example, the @code{comment} parameter in @code{readstringarray}
is an unanchored regex (@pxref{Function readstringarray}).  If you
specify the regular expression as @code{"#.*"}, then on any line
which contains a pound sign, everything from there until the end
of the line will be removed as a comment.  However, if you specify
the regular expression as @code{"^#.*"} (note the @samp{^} anchor
at the start of the regex), then only lines which @i{start} with a
@samp{#} will be removed as a comment!  If you want to ignore C-style
comment in a multi-line string, then you have to a bit more clever,
and use this regex: @code{"(?s)/\*.*?\*/"}

Conversely, @code{delete_lines} promises use anchored regular
expressions to delete lines.  If our promise uses @code{"bob:\d*}
as a line-matching regex, then only the second line of this file
will be deleted (because only the second line starts with @samp{bob:}
and is then followed exclusively by digits, all the way to the end of
the string).

@verbatim
bobs:your:uncle
bob:111770
thingamabob:1234
robert:bob:xyz
i:am:not:bob
@end verbatim

If CFEngine expects an unanchored regular expression, then finding
every line that contains the letters @samp{bob} is easy.  You just
use the regex @code{"bob"}.  But if CFEngine expects an anchored
regular expression, then you must use @code{".*bob.*"}.

If you want to find every line that has a field which is exactly
@samp{bob} with no characters before or after, then it is only a
little more complicated if CFEngine expects an unanchored regex:
@code{"(^|:)bob(:|$)"}.  But if CFEngine expects an anchored
regular expression, then it starts getting ugly, and you'd need to
use @code{"bob:.*|.*:bob:.*|.*:bob"}.


@node Special topics on Regular Expressions
@subsection Special topics on Regular Expressions

Regular expressions are a complicated subject, and really are beyond the
scope of this document.  However, it is worth mentioning a couple of special
topics that you might want to know of when using regular expressions.

The first is how to @i{not} get a backreference.  If you want to have a
parenthesized expression that does not generate a back reference, there is a
special PCRE syntax to use.  Instead of using @code{()} to bracket the piece
of a regular expression, use @code{(?:)} instead.  For example, this will
match the filenames @file{foolish}, @file{foolishly}, @file{bearish},
@file{bearishly}, @file{garish}, and @file{garishly} in the @file{/tmp}
directory.  The variable @code{$match.0} will contain the full filename, and
@code{$match.1} will either contain the string @samp{ly} or the empty string.
But the @code{(?:}expression@code{)} which matches foo, bear,
or gar does @i{not} create a back-reference:

@verbatim
files:
    "/tmp/(?:foo|bear|gar)ish(ly)?"

@end verbatim

Note that sometimes multi-line strings are subject to be matched by
regular expressions. CFEngine internally matches all regular
expressions using PCRE_DOTALL option, so @code{.} matches newlines. If
you want to match any character except newline you could use @code{\N}
escape sequence.

Another thing you might want to do is ignore capitalization.  CFEngine is
case-sensitive (in all things), so the files promise @file{/tmp/foolish} will
not match the files @file{/tmp/Foolish} or @file{/tmp/fOoLish}, etc.  There are
two ways to acheive case-insensitivity.  The first is to use character classes:

@verbatim
files:
    "/tmp/[Ff][Oo][Oo][Ll][Ii][Ss][Hh]"

@end verbatim

While this is certainly correct, it can also lead to unreadability.  The PCRE
patterns in CFEngine have another way of introducing case-insensitvity into a
pattern:

@verbatim
files:
    "/tmp/(?i:foolish)"
@end verbatim

The @code{(?i:)} brackets impose case-insensitive matching on the text that
it surrounds, without creating a sub-expression.  You could also write the
regular expression like this (but be aware that the two expressions are
different, and work slightly differently, so check the documentation for the
specifics):

@verbatim
files:
    "/tmp/(?i)foolish"
@end verbatim


The @code{/s}, @code{/m}, and @code{/x} switches from PCRE are also
available, but use them with great care!


@c ----------------------------------------------------------------------------
@node Distributed discovery
@section Distributed discovery

CFEngine's philosophy and modus operandi is to make machines as self-reliant
as possible. This is the path to scalability. Sometimes we want machines
to be able to detect one another and sample each others' behaviour. This can
be accomplished using probes and server functions.

For example, testing whether services are up and running can be a useful
probe even from a local host. CFEngine has in-built functions for generically
probing the environment; these are designed to encourage decentralized
monitoring.

@verbatim

body common control

{
bundlesequence  => { "test"  };
}

###########################################################

bundle agent test

{
vars:

 "hosts" slist => { "server1.example.org", "server2", "server3" };

 "up_servers" int =>  selectservers("@(hosts)","80","","","100","alive_servers");

classes:

  "someone_alive" expression => isgreaterthan("$(up_servers)","0");

  "i_am_a_server" expression => regarray("up_servers","$(host)|$(fqhost)");

reports:

  someone_alive::

    "Number of active servers $(up_servers)" action => always;

    "First server $(alive_servers[0]) fails over to $(alive_servers[1])";


}

@end verbatim

@c -----------------------------------------------------------------------

@node How to run CFEngine 3 examples
@chapter How to run CFEngine 3 examples

The CFEngine @file{tests} directory contains a multitude of examples of CFEngine 3 code.
These instructions assume that you have all of your configuration in a
single test file, such as the example in the distribution directory
@file{tests/units}.

@enumerate
@item Test the file as a non-privileged user first, if you can.

@item Always verify syntax first with @code{cf-promises}. This requires no privileges.
An @code{cf-agent} will not execute a configuration that has not passed this test.

@smallexample

host$ cf-promises -f ./inputfile.cf

@end smallexample

@item Run the examples like this, e.g.

@smallexample

host$ src/cf-promises -f ./tests/units/unit_server_copy_localhost.cf
host$ src/cf-serverd -f ./tests/units/unit_server_copy_localhost.cf
host$ src/cf-agent -f ./tests/units/unit_server_copy_localhost.cf

@end smallexample

@end enumerate

Running @code{cf-agent} in verbose mode provides detailed information
about the state of the systems promises.

@smallexample
Outcome of version 1.2.3: Promises observed to be kept 99%,
Promises repaired 1%, Promises not repaired 0%
@end smallexample

The log-file @file{WORKDIR/promise.log} contains the summary of these reports
with timestamps. This is the simplest kind of high level audit record of the
system.




@c ---------------------------------------------------------------------------
@node A complete configuration
@chapter A complete configuration

To illustrate a complete configuration for agents and daemons,
consider the following example code, supplied in the @file{inputs/}
directory of the distribution. Comments indicate the thinking behind
this starting point.


@menu
* promises.cf::                 
* site.cf::                     
* update.cf::                   
* failsafe.cf::                 
* What should a failsafe or update file contain::  
* Recovery from errors in the configuration::  
* Recovery from errors in the software::  
@end menu

@node promises.cf
@section @file{promises.cf}

This file is the first file that @code{cf-agent} with no arguments
will try to look for. It should contain all of the basic
configuration settings, including a list of other files
to include. In normal operation, it must have a @code{bundlesequence}.

This file can stay fixed, except for extending the bundlesequence.
The bundlesequence acts like the `genetic makeup' of the
configuration.  In a large configuration, you might want to have a
different bundlesequence for different classes of host, so that you
can build a complete system like a check-list from different
combinations of building blocks. You can construct different lists by
composing them from other lists, or you can use @code{methods}
promises as an alternative for composing bundles for different classes.

@verbatim
#######################################################
#
# promises.cf
#
#######################################################

body common control

{
# List the `genes' for this system..

bundlesequence  => {
                   "update",
                   "garbage_collection",
                   "main",
                   "cfengine"
                   };


inputs          => {
                   "update.cf",
                   "site.cf",
                   "library.cf"
                   };
}

#######################################################
# Now set defaults for all components' hard-promises
#######################################################

body agent control
{
# if default runtime is 5 mins, we need more for long jobs
ifelapsed => "15";
}

#######################################################

body monitor control
{
forgetrate => "0.7";
}

###########si###########################################

body executor control

{
splaytime => "1";
mailto => "cfengine_mail@example.org";
smtpserver => "localhost";
mailmaxlines => "30";

# Instead of a separate update script, now do this

exec_command => "$(sys.workdir)/bin/cf-agent -f failsafe.cf && $(sys.workdir)/bin/cf-agent";
}

#######################################################

body reporter control

{
reports => { "performance", "last_seen", "monitor_history" };
build_directory => "/tmp/nerves";
report_output => "html";
}

#######################################################

body runagent control
{
hosts => {
          "127.0.0.1"
          # , "myhost.example.com:5308", ...
         };

}

#######################################################

body server control

{
allowconnects         => { "127.0.0.1" , "::1" };
allowallconnects      => { "127.0.0.1" , "::1" };
trustkeysfrom         => { "127.0.0.1" , "::1" };

# Make updates and runs happen in one

cfruncommand => "$(sys.workdir)/bin/cf-agent";

allowusers   => { "root" };
}

@end verbatim



@node site.cf
@section @file{site.cf}

Use this file to add your site-specific configuration.
Common bundles can be used to define global variables.
Otherwise, unqualified variables are local to the bundle in which
they are defined -- however they can be accessed by
writing @code{$(bundle_name.variable_name)}.

@verbatim
#######################################################
#
# site.cf
#
#######################################################

bundle common g
{
vars:

  SuSE::

   "crontab" string => "/var/spool/cron/tabs/root";

 !SuSE::

   "crontab" string => "/var/spool/cron/crontabs/root";
}

@end verbatim

The CFEngine bundle below detects whether CFEngine 2 is already
running on the host or not, and if so attempts to kill off old daemon
processes and encapsulate the agent. It also looks for rules in the
old CFEngine configuration that would potentially spoil CFEngine 3's
control of the system: the last thing we want is for CFEngine 2 and
CFEngine 3 to fight each other for control of the system.  CFEngine 3
tries to edit an existing crontab entry to replace any references to
@code{cfexecd} with @code{cf-execd}; if none are found it will add a 5
minute run schedule.  You should never put @code{cf-agent}or
@code{cf-agent} directly inside @code{cron} without the @code{cf-execd}
wrapper.

@verbatim
#######################################################
# Start with CFEngine itself
#######################################################

bundle agent cfengine

{
classes:

  "integrate_cfengine2"

      and => {
             fileexists("$(sys.workdir)/inputs/cfagent.conf"),
             fileexists("$(sys.workdir)/bin/cfagent")
             };

vars:

   "cf2bits" slist => { "cfenvd", "cfservd", "cfexecd" };

commands:

 integrate_cfengine2::

   "$(sys.workdir)/bin/cfagent"

        action => longjob;

files:

  # Warn about rules relating to CFEngine 2 in inputs - could conflict

  "$(sys.workdir)/inputs/.*"

       comment     => "Check if there are still promises about CFEngine 2 that need removing",
       edit_line   => DeleteLinesMatching(".*$(cf2bits).*"),
       file_select => OldCf2Files,
       action      => WarnOnly;

  # Check cf-execd and schedule is in crontab

  "$(g.crontab)"
       edit_line => upgrade_cfexecd,
         classes => define("exec_fix");

processes:

  exec_fix::

    "cron" signals => { "hup" };


}

#######################################################
# General site issues can be in bundles like this one
#######################################################

bundle agent main

{
vars:

  "component" slist => { "cf-monitord", "cf-serverd" };

 # - - - - - - - - - - - - - - - - - - - - - - - -

files:

  "$(sys.resolv)"  # test on "/tmp/resolv.conf" #

     create        => "true",
     edit_line     => resolver,
     edit_defaults => def;

 # Uncomment this to perform a change-detection scan

 #  "/usr"
 #     changes      => lay_trip_wire,
 #     depth_search => recurse("inf"),
 #     action       => measure;

processes:

  "cfenvd"             signals => { "term" };

 # Uncomment this when you are ready to upgrade the server
 #
 #  "cfservd"             signals => { "term" };
 #

 # Now make sure the new parts are running, cf-serverd will fail if
 # the old server is still running

  "$(component)" restart_class => canonify("start_$(component)");

 # - - - - - - - - - - - - - - - - - - - - - - - -

commands:

   "$(sys.workdir)/bin/$(component)"

       ifvarclass => canonify("start_$(component)");

}

@end verbatim

This section takes a backup of a user home directory.  This is
especially useful for a single laptop or personal workstation that
does not have a regular external backup. If a user deletes a file by
accident, this shadow backup might contain the file even while
travelling offline.

@verbatim

#######################################################
# Backup
#######################################################

bundle agent backup
{
files:

  "/home/backup"

     copy_from => cp("/home/mark"),
  depth_search => recurse("inf"),
   file_select => exclude_files,
        action => longjob;

}

#######################################################
# Garbage collection issues
#######################################################

bundle agent garbage_collection
{
files:

  "$(sys.workdir)/outputs"

    delete => tidy,
    file_select => days_old("3"),
    depth_search => recurse("inf");


}

###########################################################

body file_select OldCf2Files
{
leaf_name => {
             "promises\.cf",
             "site\.cf",
             "library\.cf",
             "failsafe\.cf",
             ".*\.txt",
             ".*\.html",
             ".*~",
             "#.*"
             };

file_result => "!leaf_name";
}

###########################################################

body action measure
{
measurement_class => "Detect Changes in /usr";
ifelapsed => "240";	# 4 hours
expireafter => "240";	# 4 hours
}

@end verbatim

Some basic anomaly detection: we respond with simple warnings
if resource anomalies are detected.

@verbatim
#######################################################
# Anomaly monitoring
#######################################################

bundle agent anomalies
{
reports:

rootprocs_high_dev2::

   "RootProc anomaly high 2 dev on $(mon.host) at $(mon.env_time)
    measured value $(mon.value_rootprocs) av $(mon.av_rootprocs)
    pm $(mon.dev_rootprocs)"

      showstate => { "rootprocs" };

entropy_www_in_high&anomaly_hosts.www_in_high_anomaly::

   "HIGH ENTROPY Incoming www anomaly high anomaly dev!!
    on $(mon.host) at $(mon.env_time)
    - measured value $(mon.value_www_in)
    av $(mon.av_www_in) pm $(mon.dev_www_in)"

      showstate => { "incoming.www" };

 entropy_www_in_low.anomaly_hosts.www_in_high_anomaly::

   "LOW ENTROPY Incoming www anomaly high anomaly dev!!
    on $(mon.host) at $(mon.env_time)
     - measured value $(svalue_www_in)
    av $(av_www_in) pm $(dev_www_in)"

     showstate => { "incoming.www" };

entropy_tcpsyn_in_low.anomaly_hosts.tcpsyn_in_high_dev2::

   "Anomalous number of new TCP connections on $(mon.host)
    at $(mon.env_time)
    - measured value $(mon.value_tcpsyn_in)
    av $(mon.av_tcpsyn_in) pm $(mon.dev_tcpsyn_in)"

     showstate => { "incoming.tcpsyn" };

 entropy_dns_in_low.anomaly_hosts.dns_in_high_anomaly::

   "Anomalous (3dev) incoming DNS packets on $(mon.host)
    at $(mon.env_time) - measured value $(mon.value_dns_in)
    av $(av_dns_in) pm $(mon.dev_dns_in)"

     showstate => { "incoming.dns" };

 entropy_dns_in_low.anomaly_hosts.udp_in_high_dev2::

   "Anomalous (2dev) incoming (non-DNS) UDP traffic
    on $(mon.host) at $(mon.env_time) - measured value
    $(mon.value_udp_in) av $(mon.av_udp_in) pm $(mon.dev_udp_in)"

     showstate => { "incoming.udp" };

 anomaly_hosts.icmp_in_high_anomaly.!entropy_icmp_in_high::

   "Anomalous low entropy (3dev) incoming ICMP traffic
    on $(mon.host) at $(mon.env_time) - measured value $(mon.value_icmp_in)
    av $(mon.av_icmp_in) pm $(mon.dev_icmp_in)"

     showstate => { "incoming.icmp" };
}

@end verbatim

Server access rules are a touchy business. In an enterprise
setting you generally want every host to allow a monitoring
host to be able to download data, and a backup host to be able
to access important data on every host. On a laptop or personal
workstation, there might not be any reason to run a server
for external use; however you might configure it as below
to allow localhost access for testing.

@verbatim

#######################################################
# Server configuration
#######################################################

bundle server access_rules()
{
access:

  "/home/mark/test_area"

    admit   => { "127.0.0.1" };

  # Rule for cf-runagent

  "/home/mark/.cfagent/bin/cf-agent"

    admit   => { "127.0.0.1" };

# New in cf3 - RBAC with cf-runagent

roles:

  ".*"  authorize => { "mark" };
}

@end verbatim


@node update.cf
@section @file{update.cf}

This file should rarely if ever change.  Should you ever change it (or when you
upgrade CFEngine), take special care to ensure the old and the new CFEngine can
parse and execute this file successfully. If not, you risk losing control of
your system (that is, if CFEngine cannot successfully execute this set of
promises, it has no mechanism for distributing @i{new} policy files).

By default, the policy defined in @file{update.cf} is executed from two sets
of promise bodies.  The ``usual'' one (defined in the @code{bundlesequence}
in @file{promises.cf}) and another in the backup/failsafe @code{bundlesequence}
(defined in @file{failsafe.cf}).

@verbatim
#########################################################
#
# update.cf
#
#########################################################

bundle agent update
{
vars:

 "master_location" string => "/your/master/cfengine-inputs";

files:

  # Update the configuration

  "/var/cfengine/inputs"

    perms => system("600"),
    copy_from => mycopy("$(master_location)","localhost"),
    depth_search => recurse("inf"),
    action => immediate;

}

############################################

body perms system(p)

{
mode  => "$(p)";
}

############################################

body file_select cf3_files

{
leaf_name => { "cf-.*" };

file_result => "leaf_name";
}

#########################################################

body copy_from mycopy(from,server)

{
source      => "$(from)";
compare     => "digest";
}

#########################################################

body action immediate
{
ifelapsed => "1";
}
@end verbatim




@node failsafe.cf
@section @file{failsafe.cf}

This file should probably never change.  The only job of @file{failsafe.cf} is
to execute the @code{update} bundle in a ``standalone'' context should there be
a syntax error somewhere in the main set of promises.  In this way, if a
client machine's policies are ever corrupted after downloading erroneous
policy from a server, that client will have a failsafe method for downloading
a corrected policy once it becomes available on the server.  Note that by
``corrupted'' and ``erroneous'' we typically mean ``broken via administrator
error'' - mistakes happen, and the @file{failsafe.cf} file is CFEngine's way
of being prepared for that eventuality.

If you ever change @file{failsafe.cf} (or when you
upgrade CFEngine), make sure the old and the new CFEngine can successfully
parse and execute this file.  If not, you risk losing control of your system
(that is, if CFEngine cannot successfully execute this policy file, it has no
failsafe/fallback mechanism for distributing @i{new} policy files).

@verbatim
#########################################################
#
# Failsafe file
#
#########################################################

body common control

{
bundlesequence => { "update" };

inputs => { "update.cf" };
}

############################################

body depth_search recurse(d)

{
depth => "$(d)";
}

@end verbatim


@node What should a failsafe or update file contain
@section What should a failsafe and update file contain?


The @file{failsafe.cf} file is to make sure that your system can
upgrade gracefully to new versions even when mistakes are made.


As a general rule:
@itemize

@item
Upgrade the software first, then add new features
to the configuration.

@item
Never use advanced features in the failsafe or update file.

@item
Avoid using library code (including any bodies from @file{cfengine_stdlib.cf}).
Copy/paste any bodies you need using a unique name that does not collide with
a name in library (we recommend simply adding the prefix ``@code{u_}'').  This
may mean that you create duplicate functionality, but that is okay in this
case to ensure a 100% functioning @i{standalone} update process).  The promises
which manage the update process should not have @i{any} dependencies on any
other files.

@end itemize

@noindent A CFEngine configuration will fail-over to the @code{failsafe.cf}
configuration
if it is unable to read or parse the contents successfully. That means
that any syntax errors you introduce (or any new features you utilize in a
configuration) will cause a
fail-over, because the parser will not be able to interpret the policy.  If
the failover is due to the use of new features, they will not parse until the
software itself has been updated (so we recommend that you always update
CFEngine before updating policy to use new features).  If you accidentally
cause a bad (i.e., unparseable) policy to be distributed to client machines,
the @code{failsafe.cf} policy on those machines will run (and will eventually
download a working policy, once you fix it on the policy host).



@node Recovery from errors in the configuration
@section Recovery from errors in the configuration

The @file{failsafe.cf} file should be able to download the latest
master configuration from source always.

@verbatim

#######################################################
#
# failsafe.cf
#
#######################################################

body common control

{
bundlesequence => { "update" };
}

#########################################################

bundle agent update
{
files:

  "/var/cfengine/inputs"

    perms => system,
    copy_from => mycopy("/home/mark/cfengine-inputs","localhost"),
    file_select => cf3_files,
    depth_search => recurse("inf");
}

#########################################################

body perms system

{
mode  => "0700";
}

#########################################################

body depth_search recurse(d)

{
depth => "$(d)";
}

############################################

body file_select cf3_files

{
leaf_name => { "cf-.*" };

file_result => "leaf_name";
}

#########################################################

body copy_from mycopy(from,server)

{
source       => "$(from)";
servers      => { "$(server)" , "failover.domain.tld" };
#copy_backup => "true";
#trustkey    => "true";
encrypt      => "true";
}

@end verbatim

@noindent If the @code{copy_backup} option is true, CFEngine will keep a single
previous version of the file before copy, if the value is @samp{timestamp}
CFEngine keeps time-stamped versions either in the location of the file, or in the
file repository if one is defined. The @code{trustkey} option should normally
be commented out so that public keys are only exchanged under controlled conditions.


@node Recovery from errors in the software
@section Recovery from errors in the software

The update should optionally include an update of software
so that a single failover from a configuration that is `too new'
for the software will still correct itself once the new software
is available.

@verbatim

#######################################################
#
# update.cf
#
#######################################################

bundle agent update

{
files:

  "/var/cfengine/inputs"

    perms => system("600"),
    copy_from => mycopy("/home/mark/cfengine-inputs","localhost"),
    depth_search => recurse("inf");
}

############################################

body perms system(p)

{
mode  => "$(p)";
}

############################################

body file_select cf3_files

{
leaf_name => { "cf-.*" };

file_result => "leaf_name";
}

#########################################################

body copy_from mycopy(from,server)

{
source      => "$(from)";
compare     => "digest";
}

@end verbatim
