\input texinfo-altfont
\input texinfo-logo
\input texinfo
@selectaltfont{cmbright}
@setlogo{CFEngineFrontPage} 

@c *********************************************************************
@c
@c  This is a TEXINFO file. It generates both TEX documentation and
@c  the "on line" documentation "info" files.
@c
@c  The file is structured like a programming language. Each chapter
@c  starts with a chapter comment.
@c
@c  Menus list the subsections so that an online info-reader can parse
@c  the file hierarchically.
@c
@c ***********************************************************************
@c %** start of header
@setfilename cf3-bestpractice.info
@settitle CFEngine 3 Best Practices
@setchapternewpage odd
@c %** end of header

@titlepage
@title CFEngine 3 Best Practices
@subtitle A CFEngine Handbook
@author CFEngine AS

@c @smallbook
    

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2008- CFEngine AS

@end titlepage


@c *************************** File begins here ************************


@ifinfo
@dircategory CFEngine Training
@direntry
* CFEngine Modularization:
                        CFEngine is a language based tool specifically
                        designed for configuring and maintaining
                        Unix-like operating systems attached
                        to a TCP/IP network.
@end direntry
@end ifinfo

@ifnottex
@node Top, Policy Style Guide, (dir), (dir)
@top CFEngine-Best-Practices
@end ifnottex
@iftex
@contents
@end iftex

@ifhtml
@html
<a href="#Contents"><h1>COMPLETE TABLE OF CONTENTS</h1></a>
<h2>Summary of contents</h2>
@end html
@end ifhtml

@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@menu
* Policy Style Guide::          
* Policy Dos and Don'ts::       
* Common Workflows ::           
* Quality Assurance around CFEngine::  
@end menu


@c **********************************************************************

@node Policy Style Guide, Policy Dos and Don'ts, Top, Top
@chapter Policy Style Guide

@c ....................................
@menu
* Arranging files::             
* Where to define variables and classes::  
* How to choose and name bundles::  
* How to decide when to make a bundle::  
* When to use a paramaterized bundle or method ::  
* When should classes be in common bundles::  
* When should variables be in common bundles::  
* When should variables be in local bundles::  
@end menu

@node Arranging files, Where to define variables and classes, Policy Style Guide, Policy Style Guide
@section Arranging files

Base your files on high level services as you do with bundles,
@xref{How to choose and name bundles}.  The purpose of breaking up
policy into files is to limit the scope of the policy to manageable
amounts, making it easier to understand. It will only be easier to
understand if the casual user can immediately locate promises from the
name of the file.

You can place related files in subdirectories of the inputs to localize them.
This also makes updating more efficient, as fewer objects need to be
checked.

@cartouche
The Enterprise Knowledge base allows you to search for
promises, but everything will make more sense if promises are found in
an intuitive place.
@end cartouche

@node Where to define variables and classes, How to choose and name bundles, Arranging files, Policy Style Guide
@section Where to define variables and classes

@cartouche
Note that all CFEngine variables are globally accessable, by using their
fully qualified name :@code{$(bundle.variable)}, or @code{@@(bundle.variable)},
so placing variables in one place or another does not affect their accessability.
@end cartouche

Variables should be defined as close to the place where they are used as possible.
The user will expect to find variables defined:

@itemize
@item In the current bundle, first and foremost.
@item In some common bundle for generic, global data.
@end itemize

@noindent Variables that define global aspects of configuration, e.g.

@itemize
@item Well known path names, e.g. document root.
@item Site specific data, e.g. the email address of the support unit.
@end itemize
@noindent can be defined in @code{common} bundles. This places them
in a neutral context.

The only reason to define a variable far from its place of use would
be when writing generically re-usable methods and passing data as
parameters, @xref{When to use a paramaterized bundle or method}.
However, re-usability can make rules harder to understand.

@node How to choose and name bundles, How to decide when to make a bundle, Where to define variables and classes, Policy Style Guide
@section How to choose and name bundles

Use the name of a bundle to represent a meaningful aspect of system adminstration,
We recommend using a two or three-part name, that explains the context, general subject heading and
special instance. Names should be service oriented and should guide non-experts to understand
what they are about.
e.g.
@itemize
@item app_mail_postfix
@item app_mail_mailman
@item app_web_apache
@item app_web_squid
@item app_web_php
@item app_db_mysql
@item garbage_collection
@item security_check_files
@item security_check_processes
@item system_name_resolution
@item system_xinetd
@item system_root_password
@item system_processes
@item system_files
@item win_active_directory
@item win_registry
@item win_services
@end itemize

@node How to decide when to make a bundle, When to use a paramaterized bundle or method , How to choose and name bundles, Policy Style Guide
@section How to decide when to make a bundle

Put things into a single bundle if:
@itemize
@item They belong to the same conceptual aspect of system administration.
@item They do not need to be switched on or off independently.
@end itemize


Put things into different bundles if:

@itemize
@item All of the promises in one bundle need to the checked
before all of the promises in another bundle.

@item You need to re-use the promises with different parameters.
@end itemize

In general, keep the number of bundles to a minimum. 
This is a knowledge management issue. Clarity comes from differentiation,
but only if the number of things is small.




@node When to use a paramaterized bundle or method , When should classes be in common bundles, How to decide when to make a bundle, Policy Style Guide
@section When to use a paramaterized bundle or method 

If you need to arrange for a @i{managed convergent collection} or
@i{sequence} of promises that will occur for a list of (multiple) names or
promisers, then use a bundle to simplify the code. 

Write the promises, which may or may not be ordered, using a parameter for the
different names, then call the method passing the list of names as a parameter
to reduce the amount of code.

@smallexample

bundle agent testbundle
@{
vars:

 "userlist" slist => @{ "mark", "jeang", "jonhenrik", "thomas", "eben" @};

methods:

 "any" @b{usebundle => subtest("$(userlist)")};

@}

###########################################

bundle agent subtest(@b{user})

@{
commands:

 "/bin/echo Fix @b{$(user)}";

files:

 "/home/@b{$(user)}/."

    create =>  "true";

reports:

 linux::

  "Finished doing stuff for @b{$(user)}";
@}

@end smallexample



@node When should classes be in common bundles, When should variables be in common bundles, When to use a paramaterized bundle or method , Policy Style Guide
@section When should classes be in @code{common} bundles?

@itemize
@item When you need to use them in multiple bundles (because classes defined
in @code{common} bundles have global scope).
@end itemize

@cartouche

Note, if you are converting from CFEngine 2 you should know the following.
In CFEngine 2, all classes were global and it was common to define all classes
in a big unmanageable list. That meant that there was a chance of
class name collisions.  CFEngine 3 has both local and global classes, allowing you
to limit the scope of classes and define them more in context.

@end cartouche

@node When should variables be in common bundles, When should variables be in local bundles, When should classes be in common bundles, Policy Style Guide
@section When should variables be in @code{common} bundles?

@itemize
@item For rationality, if the variable does not belong to any particular
bundle, because it is used elsewhere. 
(Qualified variable names e.g. @code{$(mybundle.myname)}are always
globally accessible, so this is a cosmetic issue.)
@end itemize

@node When should variables be in local bundles,  , When should variables be in common bundles, Policy Style Guide
@section When should variables be in local bundles?

@itemize
@item If they are not needed outside the bundles.
@item If they are used for iteration (without qualified scope).
@item If they are tied to a specific aspect of system maintenance represented
by the bundle, so that accessing @code{$(bundle.var)} adds clarity.
@end itemize

@c **********************************************************************
@c CHAPTER
@c **********************************************************************

@node Policy Dos and Don'ts, Common Workflows , Policy Style Guide, Top
@chapter Policy Dos and Don'ts

This chapter lists a number of recommended practices.



@menu
* Never do::                    
* Avoid::                       
* Recommended::                 
* Always do::                   
@end menu

@node Never do, Avoid, Policy Dos and Don'ts, Policy Dos and Don'ts
@section Never do

@menu
* Never change system policy when humans are absent::  
* Never embed simple shell commands::  
* Never manage more than one cron job::  
@end menu


@node Never change system policy when humans are absent, Never embed simple shell commands, Never do, Never do
@subsection Never change system policy when humans are absent

Never make system changes when humans are unavailable, e.g. just before
going offline for the weekend. No matter how careful you have been, mistakes
can be made and you need to have at least 24 hours experience with a running
policy to lend it your trust.



@node Never embed simple shell commands, Never manage more than one cron job, Never change system policy when humans are absent, Never do
@subsection Never embed simple shell commands


Do not embed simple shell commands with CFEngine @code{commands} promises, like this:

@smallexample

commands:

   # Don't do this!

   "/bin/rm -r /tmp/xyz*";
   "/bin/mkdir /tmp/abcd";

@end smallexample

@b{WHY?} Embedded shell commands like this cannot be managed by CFEngine,
so none of the protections that CFEngine offers can be applied to the process.
Moreover, this starts a new process, adding to the burden on the system.

Most importantly, this approach works like a covert channel, making changes
that are not directly visible to CFEngine. 


@node Never manage more than one cron job,  , Never embed simple shell commands, Never do
@subsection Never manage more than one cron job

When you run CFEngine, there is no reason to maintain separate cron
jobs.  Instead, use CFEngine's time classes to work like a user
interface for cron.  This allows you to have a single, central
CFEngine file which contains all the cron jobs on your system without
losing any of the fine control which cron affords you. All of the
usual advantages apply:
@itemize @bullet

@item
It is easier to keep track of what cron jobs are running on the
system when you have everything in one place.

@item
You can use all of your carefully crafted groups and user-defined
classes to identify which host should run which programs.
@end itemize

@b{WHY?} This gives you a single point of definition for batch jobs.
It encapsulates jobs under CFEngine's tutelage, for improved control
and security. Finally, CFEngine can collate and summarize the outputs
from multiple scripts in a rational monitoring process.



@c **********************************************************************
@node Avoid, Recommended, Never do, Policy Dos and Don'ts
@section Avoid

@menu
* Avoid writing custom scripts::  
* Avoid running CFEngine without lock protection::  
@end menu

@node Avoid writing custom scripts, Avoid running CFEngine without lock protection, Avoid, Avoid
@subsection Avoid writing custom scripts
 
Do not spend your time writing scripts to embed within CFEngine.  If
you are doing this, you are not using the potential of CFEngine and
you are not benefitting from the protections and efficiencies that
CFEngine offers. Custom scripts should be for your specific business
operations, not for system maintenance.

If you are tempted to use scripts to achieve your needs, consider
using @code{methods}, and if necessary consult with support personnel
for advice.


@node Avoid running CFEngine without lock protection,  , Avoid writing custom scripts, Avoid
@subsection avoid running CFEngine without lock protection

CFEngine's adaptive locking is an important system protection.  You
should not run CFEngine continuously without this protection, e.g.  by
running with the @samp{-K} flag set, of by setting @code{ifelapsed} to
zero for a promise.

@b{WHY?} System inconsistencies can result and unnecessary resources
will be consumed.



@c **********************************************************************
@node Recommended, Always do, Avoid, Policy Dos and Don'ts
@section Recommended (Try to)

@menu
* Try to combine tests and operations during file searches::  
* Try to make many small changes::  
@end menu

@node Try to combine tests and operations during file searches, Try to make many small changes, Recommended, Recommended
@subsection Try to combine tests and operations during file searches

Searching through files on a disk is one of the most time consuming
operations for a computer. If you have to do it, make sure that
you are getting the most for your CPU-cycles and combine operations
in a single promise. This allows CFEngine to optimize the resource use
of the system.

@smallexample

files:

   "$(site)/app/webroot/img/inside/extmans"
       comment => "Copy the images for the private html documents",
@b{     copy_from => cp("$(kbase)"),
         perms => p("root","644"),
   file_select => by_name(".*.png"),
  depth_search => recurse("1"),}
        action => ifelapsed("60");

@end smallexample



@node Try to make many small changes,  , Try to combine tests and operations during file searches, Recommended
@subsection Try to make many small changes

Changes to policy should always be part of a serious and considered
plan. They should not be @emph{ad hoc}. That said, consideration of
changes should not be so time-consuming that it cripples human
resources, or leads to change-avoidance because it seems daunting.

It is better to make many small changes than few large changes.  Large
changes involve many interdependencies, which make them fragile to
unexpected contingencies. The risk of large changes is high. The risk
of small changes is low.

CFEngine makes it easy to make small changes frequently, without
operational repercussions. As long as humans are on hand during the
change to observe possible side-effects this.


@c **********************************************************************
@node Always do,  , Recommended, Policy Dos and Don'ts
@section Always do


@menu
* Always document promises::    
* Always keep coding to a minimum::  
* Always use lists to make the same promise about multiple objects::  
* Always use existing templates::  
* Always use the system variables for system resources::  
* Always use variables as pointers to paths and servers::  
@end menu

@node Always document promises, Always keep coding to a minimum, Always do, Always do
@subsection Always document promises

Always add comment attributes to your promises to explain the intention.

@smallexample

files:

 # This is a throw-away comment, below is a full-bodied promise

   "/tmp/testfile"                      # promiser

     @b{comment => "This is for keeps...", # Live comment}
      create => "true",                 # Constraint 1
       perms => p("612");               # Constraint 2

@end smallexample

If a promise has a stakeholder that is worthy of special mention, then
use the promisee fields to add the name of this person.

@smallexample

files:

   "/tmp/testfile" -> @{ "stakeholder@@company.com" @},

     @b{comment => "This is for keeps...", # Live comment}
      create => "true",                 # Constraint 1
       perms => p("612");               # Constraint 2

@end smallexample

If a promise depends on another promise being run before it, use the
@code{depends_on} fields to document the handle of the other prior promise.
This allows tracing of the impact chain.


@smallexample

files:

 "/tmp"

      @b{handle => "make_temp",}
     comment => "This is for keeps...", # Live comment
      create => "true",                 # Constraint 1
       perms => p("612");               # Constraint 2


   "/tmp/testfile"

  @b{depends_on => @{ "make_temp" @},}
     comment => "This is for keeps...", # Live comment
      create => "true",                 # Constraint 1
       perms => p("612");               # Constraint 2

@end smallexample


@node  Always keep coding to a minimum, Always use lists to make the same promise about multiple objects, Always document promises, Always do
@subsection Always keep coding to a minimum

If you are coming to CFEngine from another scripting langauge, you
will probably be tempted to add a lot of `logic' to your CFEngine
program, testing whether things are true and trying to control the
order of things. This is not necessary. You should think of each
promise as being a self-contained `nugget' that requires little
additional coding. The more coding you add, the more fragile 
a configuration becomes.

The hardest part of using CFEngine for programmers is letting go
of the reins.


@node Always use lists to make the same promise about multiple objects, Always use existing templates, Always keep coding to a minimum, Always do
@subsection Always use lists to make the same promise about multiple objects

If you have a number of system resources that all make the same
promise, then use lists to iterate over the resources in a single
promise, rather than coding the same promise many times.

@smallexample
vars:

  "watch_files" slist =>  @{
                          "/etc/passwd", 
                          "/etc/shadow", 
                          "/etc/group", 
                          "/etc/services" 
                          @};
files:

   "$(watch_files)"
 
      comment      => "Change detection on the above",
      changes      => change_management_trip_wire;

@end smallexample


@node Always use existing templates, Always use the system variables for system resources, Always use lists to make the same promise about multiple objects, Always do
@subsection Always use existing templates

Familiarize yourself with the current @code{CFEngine_stdlib.cf} file in the
software distribution. This contains many body templates, e.g.

@smallexample
local_cp() remote_cp() secure_cp() if_elapsed() recurse()
@end smallexample

@noindent Use these pre-existing body templates whenever possible, rather
than inventing new ones. For example:

@smallexample

bundle agent update
@{
files:

 "/path/to/copy" 

    comment => "Update the policy files from the master",
    perms => u_p("600"),
    copy_from => @b{local_cp}("$(master_location)","localhost"),
    depth_search => @b{recurse}("inf");

@}
@end smallexample

@b{WHY?} The comprehensibility of your code to consultants and new
employees is enhanced by standardization of practice. If the global
CFEngine community uses the same set of idioms, then communicating
policy will be simpler.


@node Always use the system variables for system resources, Always use variables as pointers to paths and servers, Always use existing templates, Always do
@subsection Always use the system variables for system resources

CFEngine provides indirection (pointers) to particular resources,
through its @samp{sys} variable context. These variables adapt
to the operating system and user id under which CFEngine is run.
Your policy will be more readily portable and you will need to
code fewer exceptions if you use CFEngine's automatically adapting
primitives, e.g. instead of writing @file{/etc/resolv.conf} for the
name-service configuration file, use @code{$(sys.resolv)}.

@smallexample

files:

  "@b{$(sys.resolv)}"

     comment       => "Add lines to the resolver configuration",
     create        => "true",
     edit_line     => resolver,
     edit_defaults => std_edits;

@end smallexample


@node Always use variables as pointers to paths and servers,  , Always use the system variables for system resources, Always do
@subsection Always use variables as pointers to paths and servers

You should avoid coding paths and names of resources directly in
promises. Use instead a local or possible global variable to point to
the resource instead. This brings consistency to the coding, often
shortens the references, and provides a @i{single point of definition}
for change.


@smallexample

bundle agent update
@{
vars:

 # A standard location for the source point (single point of definition)

 "master_location" string => "@b{$(sys.workdir)}/masterfiles";

files:

 "$(sys.workdir)/inputs" 

    comment => "Update the policy files from the master",
    perms => u_p("600"),
    copy_from => u_cp("@b{$(master_location)}","localhost"),
    depth_search => recurse("inf");

@}

@end smallexample


@node Common Workflows , Quality Assurance around CFEngine, Policy Dos and Don'ts, Top
@chapter Common Workflows 

This chapter concerns `workflow processes' that should typically be
dealt with on systems. A workflow process is represented by a
@i{promise bundle} in CFEngine.  None of the proposals here should be
considered mandatory in any sense, but they do represent the norm.

We refer users to the CFEngine solutions guide for implementation details of
specific solutions.

@c **********************************************************************
@menu
* Anomaly Monitoring::          
* Batch Jobs::                  
* Garbage Collection::          
* Knowledge Updating::          
* Name Service::                
* Policy Distribution::         
* Services::                    
* Security::                    
* Software Management::         
@end menu

@node Anomaly Monitoring, Batch Jobs, Common Workflows , Common Workflows
@section Anomaly Monitoring

@noindent @b{Purpose:}

The purpose of anomaly monitoring is to understand the stability
of a system, both in terms of its run-time performance and its
architectural structure. Sudden changes on a system can be separated
from the normal slow variations.

@noindent @b{Remarks:}

Anomaly detection is enabled and performed by the @code{cf-monitord} daemon.
Reporting of anomalies is not automatic however. Alerts must be promised
explicitly. This is normally handled by a @code{reports} promise.

Change detection of the file system is handled by @code{files}
promises in @code{cf-agent}.

@noindent @b{Example:}

@smallexample

bundle agent anomalies
@{
vars:

  "sysdir" string => "/tmp";
  "files" slist => @{ "passwd", "shadow" @};

classes:

  "no_$(files)" not => fileexists("$(sysdir)/$(files)");

files:

  # backup

  "/var/cfengine/inputs/$(files)"

      copy_from => emergency_save("$(sysdir)/$(files)");

  # restore
  
  "/tmp/$(files)"

       copy_from => emergency_save("/var/cfengine/inputs/$(files)"),
      ifvarclass => "no_$(files)";

reports:

 rootprocs_high_dev2::

   "RootProc anomaly high 2 dev on $(mon.host) at $(mon.env_time) 
    measured value $(mon.value_rootprocs) av $(mon.average_rootprocs) 
    pm $(mon.stddev_rootprocs)"

      showstate => @{ "rootprocs" @};

 entropy_www_in_high&anomaly_hosts.www_in_high_anomaly::

   "HIGH ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host)
    - measured value $(mon.value_www_in) av $(mon.average_www_in) pm 
     $(mon.stddev_www_in)"
   
      showstate => @{ "incoming.www" @};

 entropy_www_in_low.anomaly_hosts.www_in_high_anomaly::

   "LOW ENTROPY Incoming www anomaly high anomaly dev!! on $(mon.host)
      at $(mon.env_time)
     - measured value $(svalue_www_in) av $(average_www_in) pm $(stddev_www_in)"

     showstate => @{ "incoming.www" @};

 # etc.

@}

@end smallexample


@c **********************************************************************
@node Batch Jobs, Garbage Collection, Anomaly Monitoring, Common Workflows
@section Batch Jobs


@noindent @b{Purpose:}

Batch jobs are run on systems in order to perform basic house keeping functions such
as updating databases or executing business related tasks. 

@noindent @b{Remarks:}

Batch jobs should not be run every time CFEngine runs, so you need to limit the
execution of each one carefully, using:

@itemize
@item Classes
Classes for time and location.
@item Locks
The @code{ifelapsed} parameter determined how much time has to have elapsed
before the job can be executed again.
@end itemize

@noindent @b{Example:}


@smallexample

bundle agent example
@{
commands:

   # Exec on the first quarter after noon on Mondays

    Hr12.Q1.Monday::

      "/path/myscript -arg1 -arg2";

   # Exec every second quarter past hour, every day

    Q2::

      "/path/otherscript";

@}

@end smallexample


@c **********************************************************************
@node Garbage Collection, Knowledge Updating, Batch Jobs, Common Workflows
@section Garbage Collection

@noindent @b{Purpose:}

Garbage collection is required on systems to prevent temporary or
antiquated files from consuming all available storage resources. It is
impossible for a system to survive in the long term without throwing
some data away.

@noindent @b{Remarks:}

Needless to say, care should be exercised when deleting anything from the system.
There are many strategies to select carefully what is to be deleted.
The @code{file_select} constraint is your friend.

@noindent @b{Example:}

@smallexample


bundle agent garbage_collection
@{
files:

  "$(sys.workdir)/outputs" 

    comment => "Garbage collection of any output files",
    delete => tidy,
    @b{file_select => days_old("3")},
    depth_search => recurse("inf");

  "/tmp" 

    comment => "Garbage collection of any temporary files",
    delete => tidy,
    @b{file_select => days_old("3")},
    depth_search => recurse("inf");

@}

@end smallexample

@c **********************************************************************
@node Knowledge Updating, Name Service, Garbage Collection, Common Workflows
@section Knowledge Updating

@noindent @b{Purpose:}
@noindent @b{Remarks:}
@noindent @b{Example:}

@c **********************************************************************
@node Name Service, Policy Distribution, Knowledge Updating, Common Workflows
@section Name Service

@noindent @b{Purpose:}
Every computer needs to know how to perform name directory lookups in the Domain
Name Service. On Unix systems this requires it to manage the @file{/etc/resolv.conf}
file.

@noindent @b{Remarks:}

Always use the @code{$(sys.resolv)} variable to refer to the file.

@noindent @b{Example:}

@smallexample
bundle agent name_resolution

@{
files:

  "$(sys.resolv)"  # test on "/tmp/resolv.conf" #

     comment       => "Add lines to the resolver configuration",
     create        => "true",
     edit_line     => resolver,
     edit_defaults => std_edits;

@}

bundle edit_line resolver

@{
delete_lines:

  "search.*";
  "nameserver 80.65.58.31";

insert_lines:

  "search CFEngine.com" location => start;
  "nameserver 212.112.166.18";
  "nameserver 212.112.166.22";
@}


@end smallexample

@c **********************************************************************
@node Policy Distribution, Services, Name Service, Common Workflows
@section Policy Distribution


@noindent @b{Purpose:}

In a centralized model of policy suggestion, policy updates are downloaded
from a single point of definition, from one or more policy servers.
Maintaining this flow of communication from `central command' is what maintains
that centralized command.

@noindent @b{Remarks:}
It is not mandatory to centralize management, but usually there needs to
be some automated process. 

@noindent @b{Example:}

@smallexample

vars:

 "master_location" string => "/var/cfengine/masterfiles";

 "policy_server"   slist => @{ "62.109.39.150" @},
                   comment => "IP address to locate your policy host.";

files:

  "/var/cfengine/inputs" 

    handle => "update_policy",
    perms => system("600"),
    copy_from => u_scp("$(master_location)",@@(policy_server)),
    depth_search => recurse("inf"),
    file_select => input_files,
    action => immediate;

@end smallexample

@c **********************************************************************
@node Services, Security, Policy Distribution, Common Workflows
@section Services


@noindent @b{Purpose:}
Keeping services up and running, or taking down services that should not be
running is both a matter of productivity and security.

@noindent @b{Remarks:}
@noindent @b{Example:}

@smallexample

bundle agent services
@{
vars:
 "serlist" slist => @{ "dhcp", "ntp", "sshd" @};

  "sindex" int => readstringarray
                    (
                    "service",
                    "$(g.workdir)/inputs/fixservices-array",
                    "#[^\n]*",
                    ":",
                    "10",
                    "4000"
                    );

methods:

         "any" usebundle => fixservice
             (
             "$(service[$(serlist)][0])",
             "$(service[$(serlist)][1])",
             "$(service[$(serlist)][2])",
             "$(service[$(serlist)][3])",
             "$(service[$(serlist)][4])"
             );
@}

bundle agent fixservice(service,tfiles,mfiles,procs,restart)
@{
files:

 "$(tfiles)"
      perms => system("0600","root","root"),
  copy_from => mycopy("$(g.masterfiles)/config/$(mfiles)","$(g.phost)"),
    classes => cdefine( "$(service)_restart", "failed");

processes:

  "$(procs)"

      restart_class => canonify("$(service)_restart");

commands:

  "$(restart)" 

      ifvarclass =>  canonify("$(service)_restart");
@}

@end smallexample

@c **********************************************************************
@node Security, Software Management, Services, Common Workflows
@section Security

@noindent @b{Purpose:}
Security is a vast topic. You need to start with a security policy
and then translate this into promises about the system. For instance
you might promise file permissions and access rules. You might promise
change monitoring or anomaly detection.

@noindent @b{Remarks:}
This is an open ended topic. Security should be discussed as a
human process, since most breaches come from within the system.
CFEngine can then be used to implement hardening measures, and
monitoring of important assets.

@noindent @b{Example:}


@smallexample
vars:

  "system_files" slist => @{
                          "/etc/passwd",
                          "/etc/group",  
                          "/etc/services" 
                          @};

  "secret_files" slist => @{
                          "/etc/shadow"
                          @};

files:


   "$(secret_files)"
 
      comment      => "Check permissions are secret on the above",
      perms        => mo("o-rwx","root");

   "$(system_files)"
 
      comment      => "Check permissions are correct on the above",
      perms        => mo("644","root");


@end smallexample

@c **********************************************************************
@node Software Management,  , Security, Common Workflows
@section Software Management

@noindent @b{Purpose:}
Installing software and updating

These days most systems have some kind of package based management
system.  These vary in their intelligence from self-updating robots to
simple dumb file repositories. CFEngine can manage the installation
and subsequent customization/configuration.

@noindent @b{Remarks:}
Installing software from some kind of source is only the first step.
Thereafter, special settings must be harmonized with security policies
and operational requirements.


@noindent @b{Example:}

@smallexample

vars:

  "match_package" slist => @{ 
                           "apache2", 
                           "apache2-mod_php5",
                           "apache2-prefork",
                           "php5" 
                           @};

packages:

  "$(match_package)"

     package_policy => "add",
     package_method => yum,
     classes => ok("software_ok");

@end smallexample


@c **********************************************************************
@c CHAPTER
@c **********************************************************************


@node  Quality Assurance around CFEngine,  , Common Workflows , Top
@chapter Quality Assurance around CFEngine

A powerful tool like CFEngine can do great good, or cause enormous
damage if used carelessly.  It is essential to have a strict
discipline when making changes. This is a human quality assurance
process.

Your general rule of thumb should be: make small changes, not big releases.


@menu
* Policy changes::              
* The policy decision flow::    
* Configuration version control and rollback::  
* Delegating responsibility::   
@end menu

@node Policy changes, The policy decision flow, Quality Assurance around CFEngine, Quality Assurance around CFEngine
@section Policy changes

Changes to policy should always be part of a serious and considered
plan. They should not be @emph{ad hoc}. That said, consideration of
changes should not be so time-consuming that it cripples human
resources, or leads to change-avoidance because it seems daunting.

It is better to make many small changes than few large changes.  Large
changes involve many interdependencies, which make them fragile to
unexpected contingencies. The risk of large changes is high. The risk
of small changes is low.

CFEngine makes it easy to make small changes frequently, without
operational repercussions. As long as humans are on hand during the
change to observe possible side-effects this.

Consider the following issues in quality assurance:
@itemize
@item Create a schedule and policy for major changes.
@item Plan to acquire the complete set of components for release.
@item Assign human roles as well as machine roles for changes.
@item Label new policy release items uniquely for tracking.
@item Always document the policy changes using the comment fields.
@item Test prior to releasing into the production environment.
@item Test in the production environment on a small number of machines whenever possible.
@end itemize


@image{cfengine-bdma,10cm,,The policy lifecycle,png}


There are four commonly cited phases in managing systems, summarized
as follows (see figure):

@itemize
@item Build
@item Deploy
@item Manage
@item Audit
@end itemize

These separate phases originate with a model of system management
based on transactional changes.  CFEngine's conception of management
is some different, as transaction processing is not a good model for
system management, but we can use this template to see how
CFEngine works differently.

@table @emph
@item Build
A system is based on a number of decisions and resources that need to
be `built' before they can be implemented. Building the trusted
foundations of a system are the key to guiding its development.  You
don't need to decide every detail, just enough to build trust and
predictability into your system.

In CFEngine, what you build is a template of proposed promises for the
machines in an organization such that, if the machines all make and
keep these promises, the system will function seamlessly as
planned. This is how it works in a human organization, and this is how
is works for computers too.

@item Deploy
Deploying really means implementing the policy that was already
decided.  In transaction systems, one tries to push out changes one by
one, hence `deploying' the decision. In CFEngine you simply publish
your policy (in CFEngine parlance these are `promise proposals') and
the machines see the new proposals and can adjust accordingly. Each
machine runs an agent that is capable of implementing policies and
maintaining them over time without further assistance.

@item Manage
Once a decision is made, unplanned events will occur. Such
incidents usually set off alarms and humans rush to make new transactions
to repair them. In CFEngine, the autonous agent manages the system,
and you only have to deal with rare events that cannot be dealt with
automatically.

@item Audit
In traditional configuration systems, the outcome is far from clear
after a one-shot transaction, so one audits the system
to determine to discover what actually happened. In CFEngine, changes
are not just initiated once, but locally audited and maintained.
Decision outcomes are assured by design in CFEngine and maintained
automatically, so the main worry is managing conflicting
intentions. Users can sit back and examine regular reports of
compliance generated by the agents, without having to arrange
for new `roll out' transactions.

@end table

@cartouche
@emph{ROLL-OUT and ROLL-BACK?  You should not think of CFEngine with a
roll-out system, i.e. one that attempts to force out absolute changes
and perhaps reverse them in case of error. Roll-out and roll-back are
theoretically flawed concepts that only sometimes work in practice.
With CFEngine, you publish a sequences of policy revisions, always
moving forward (because like it or not, time only goes in one
direction).  All of the desired-state changes are managed locally by
each individual computer, and continuously repaired to ensure on-going
compliance with policy. }
@end cartouche

@node The policy decision flow, Configuration version control and rollback, Policy changes, Quality Assurance around CFEngine
@section The policy decision flow

CFEngine does not make many absolute choices. Almost everything about
its behaviour is matter of policy and can be changed.  However, a
structure for use, like the following, is recommended (see figure).

In order to keep operations as simple as possible, CFEngine maintains
a private working directory on each machine referred to in
documentation as WORKDIR and in policy by the variable
@code{$(sys.workdir)}. By default, this is located at
@file{/var/cfengine} or @file{C:\var\CFEngine}. It contains everything
CFEngine needs to run.

The figure below shows how decisions flow through the parts of a system.

@image{arch,15cm,,The CFEngine architecture,png}


@itemize
@item
It makes sense to have a single point of coordination.  Decisions are
therefore usually made in a single location (the Policy Definition
Point).  The history of decisions and changes can be tracked by a
version control system of your choice (e.g. SubVersion).

@item
Decisions are made by editing CFEngine's policy file
@file{promises.cf} on one of its included children. This process is
carried out off-line.

@item
Once decisions have been formalized and coded, this new policy is
copied @emph{manually} (a human decision) to a @emph{decision
distribution point}, which by default is located in the directory
@file{/var/cfengine/masterfiles} on all policy distribution servers.

In this introduction, we shall assume that there is only one central
policy distribution server, a specially-appointed server which is
referred to simple as the @code{policy server}.


@item
Every client machine contacts the policy server and downloads these
updates. The policy server can be replicated if the number of clients
is very large, but we shall assume here that there is only one policy
server.
@end itemize

Once a client machine has a copy of the policy, it extracts only those
promise proposals that are relevant to it, and implements any changes
without human assistance.  This is how CFEngine manages change.

@cartouche

@emph{WHY DO THIS? CFEngine tries to minimize dependencies by decoupling
processes. By following this pull-based architecture, CFEngine will
tolerate network outages and will recover from deployment errors
easily. By placing the burden of responsibility for decision at the
top, and for implementation at the bottom, we avoid needless fragility
and keep two independent quality assurance processes apart.}

@end cartouche



@c ***********************************************************
@node Configuration version control and rollback, Delegating responsibility, The policy decision flow, Quality Assurance around CFEngine
@section Version control and rollback



CFEngine does not provide specific tools for versioning promise
specifications. It is recommended to use a tool such as subversion for
this.  CFEngine does allow you to track changes and keep versions of
non-trivial changes, such as file content changes.

Subversion maintains revision numbers on files. It is useful to be
able to refer to version names or numbers also in CFEngine. A version
string can be added to files as follows:
@smallexample
body common control
@{
version => 1.2.3
@}

@end smallexample
This defines the version number of a set of configuration files
which is referred to in reference messages from CFEngine.


When CFEngine saves a current version of a file that it is modifying
or replacing, by default such files are given a new extension and
remain within the same directory which they were
encountered. Alternatively, one can specify a repository directory to
which such files can be moved instead. The repository location is
specified in the @code{control} section:
@smallexample

body agent control
@{
default_respository => "/var/cfengine/repository";
@}

@end smallexample
Files moved to the repository are given names reflecting their full path, with slashes replaced
by underscore characters. For some, this creates a clearer overview of the 
changes that have occurred.



@c ***********************************************************
@node Delegating responsibility,  , Configuration version control and rollback, Quality Assurance around CFEngine
@section Delegating responsibility

In a large organization, you delegate responsibility for different
issues to different teams.  CFEngine has no meta-access control
mechanism which can decide who may write policy rules on what
issue. To create such a mechanism, there would have to be a monitor
which could identify users, and an authority mechanism that would
disallow certain users to write rules of certain types about certain
objects on certain hosts. Although it is @emph{possible} to create such
a system, it would be both technically difficult, very cumbersome
to use and would add a whole new level of complexity to policy and
potential error to the configuration process.

To keep matters as simple as possible, we avoid this and propose a
different approach. Promise theory (CFEngine's basis) reveals a
straightforward answer to model the security implications of this (see
the figure of the bow-tie structure). A simple method of delegating is
the following.

@enumerate
@item Delegate responsibility for different issues to admin teams 1,2,3, etc.
@item Make each of these teams responsible for version control of their own
configuration rules.
@item Make an intermediate agent responsible for collating and vetting the rules, checking for
irregularities and conflicts. This agent must promise to disallow rules by
one team that are the responsibility of another team. The agent could be a
layer of software, but a cheaper and more manageable solution is the make this
another group of one or more humans.

@item Make the resulting collated configuration version controlled. Publish
approved promises for all hosts to download from a trusted source.

@end enumerate

A review procedure for policy promises is a good
solution if you want to delegate responsibility for different parts of
a policy to different sources. Human judgement is irreplaceable, and tools
can be added to make conflicts easier to detect.

Promise theory underlines that, if a host of computing device accepts
policy from any source, then it is alone and entirely responsible for
this decision. The ultimate responsibility for the published version
policy is the vetting agent. This creates a shallow hierarchy, but
there is no reason why this formal body could not be comprised of
representatives from the multiple teams.

@center @image{delegate,13cm,,Delegation of responsibility requires vetting access,png}

@cartouche

Run several CFEngines? Another way to delegate CFEngine control for
users that only require limited privileges would be to run several
agents as non-root users. This only works however if the tasks
delegated are very self-contained and require no special privilege.

@end cartouche


@c =========================================================================
@c @node Index,  , CFEngine Methods, Top
@c @unnumbered Concept Index
@c @printindex cp
@c =========================================================================

@ifhtml
@html
<a name="Contents">
@contents
@end html
@end ifhtml

@ifhtml
@html
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2576171-2");
pageTracker._initData();
pageTracker._trackPageview();
</script>
@end html
@end ifhtml

@bye

