### This is an auto-generated file, see Makefile.am and `make pluck` ###

bundle agent run_ifdefined(namespace, mybundle)
# @brief bundle to maybe run another bundle dynamically
# @param namespace the namespace, usually `$(this.namespace)`
# @param mybundle the bundle to maybe run
#
# This bundle simply is a way to run another bundle only if it's defined.
#
# **Example:**
#
# ```cf3
# bundle agent run
# {
#   methods:
#       # does nothing if bundle "runthis" is not defined
#       "go" usebundle => run_ifdefined($(this.namespace), runthis);
# }
# ```
{
  vars:
      "bundlesfound" slist => bundlesmatching("^$(namespace):$(mybundle)$");
      "count" int => length(bundlesfound);

  methods:
      "any"
      usebundle  => $(bundlesfound),
      ifvarclass => strcmp(1, $(count));

  reports:
    verbose_mode::
      "$(this.bundle): found matching bundles $(bundlesfound) for namespace '$(namespace)' and bundle '$(mybundle)'";
}

body contain in_dir_shell(dir)
# @brief run command after switching to directory "dir" with full shell
# @param dir directory to change into
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_dir_shell("/tmp");
# ```
{
      chdir => "$(dir)";
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
}

body contain in_shell
# @brief run command in shell
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_shell;
# ```
{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
}

body contain in_shell_bg
# @brief deprecated
# This bundle previously had an invalid background attribute that was caught by
# parser strictness enhancements. Backgrounding is handeled by the body action
# background attribute.
{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
}

body contain in_shell_and_silent
# @brief run command in shell and suppress output
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_shell_and_silent,
#      comment => "Silently run command in shell";
# ```
{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
      no_output => "true";
}

body contain in_dir_shell_and_silent(dir)
# @brief run command in shell after switching to 'dir' and suppress output
# @param dir directory to change into
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_dir_shell_and_silent("/tmp"),
#      comment => "Silently run command in shell";
# ```

{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
      no_output => "true";
      chdir => "$(dir)";
}

body action if_elapsed(x)
# @brief Evaluate the promise every `x` minutes
# @param x The time in minutes between promise evaluations
{
      ifelapsed => "$(x)";
      expireafter => "$(x)";
}

body action if_elapsed_day
# @brief Evalute the promise once every 24 hours
{
      ifelapsed => "1440";    # 60 x 24
      expireafter => "1400";
}

body action warn_only
# @brief Warn once an hour if the promise needs to be repaired
#
# The promise does not get repaired.
{
      action_policy => "warn";
      ifelapsed => "60";
}

body action immediate
# @brief Evaluate the promise at every `cf-agent` execution.
{
      ifelapsed => "0";
}

body classes if_repaired(x)
# @brief Define class `x` if the promise has been repaired
# @param x The name of the class
{
      promise_repaired => { "$(x)" };
}

body classes if_else(yes,no)
# @brief Define the classes `yes` or `no` depending on promise outcome
# @param yes The name of the class that should be defined if the promise is kept or repaired
# @param no The name of the class that should be defined if the promise could not be repaired
{
      promise_kept     => { "$(yes)" };
      promise_repaired => { "$(yes)" };
      repair_failed    => { "$(no)" };
      repair_denied    => { "$(no)" };
      repair_timeout   => { "$(no)" };
}

body classes if_notkept(x)
# @brief Define the class `x` if the promise is not kept and cannot be repaired.
# @param x The name of the class that should be defined
{
      repair_failed   => { "$(x)" };
      repair_denied   => { "$(x)" };
      repair_timeout  => { "$(x)" };
}

body classes if_ok(x)
# @brief Define the class `x` if the promise is kept or could be repaired
# @param x The name of the class that should be defined
{
      promise_repaired => { "$(x)" };
      promise_kept => { "$(x)" };
}

body classes if_ok_cancel(x)
# @brief Cancel the class `x` if the promise ks kept or repaired
# @param x The name of the class that should be cancelled
{
      cancel_repaired => { "$(x)" };
      cancel_kept => { "$(x)" };
}

body classes classes_generic(x)
# @brief Define `x` prefixed/suffixed with promise outcome
# @param x The unique part of the classes to be defined
{
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_not_repaired", "$(x)_reached" };
}

body classes scoped_classes_generic(scope, x)
# @brief Define `x` prefixed/suffixed with promise outcome
# **See also:** `scope`
#
# @param scope The scope in which the class should be defined
# @param x The unique part of the classes to be defined
{
      scope => "$(scope)";
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_not_repaired", "$(x)_reached" };
}

body classes always(x)
# @brief Define class `x` no matter what the outcome of the promise is
# @param x The name of the class to be defined
{
      promise_repaired => { "$(x)" };
      promise_kept => { "$(x)" };
      repair_failed => { "$(x)" };
      repair_denied => { "$(x)" };
      repair_timeout => { "$(x)" };
}

body classes kept_successful_command
# @brief Set command to "kept" instead of "repaired" if it returns 0
{
      kept_returncodes => { "0" };
}

bundle edit_line insert_lines(lines)
# @brief Append `lines` if they don't exist in the file
# @param lines The lines to be appended
#
# **See also:** [`insert_lines`][insert_lines] in
# [`edit_line`][bundle edit_line]
{
  insert_lines:

      "$(lines)"
      comment => "Append lines if they don't exist";
}

bundle edit_line insert_file(templatefile)
# @brief Reads the lines from `templatefile` and inserts those into the
# file being edited.
# @param templatefile The name of the file from which to import lines.
{
  insert_lines:

      "$(templatefile)"
      comment => "Insert the template file into the file being edited",
      insert_type => "file";
}

bundle edit_line comment_lines_matching(regex,comment)
# @brief Comment lines in the file that matching an [anchored] regex
# @param regex Anchored regex that the entire line needs to match
# @param comment A string that is prepended to matching lines
{
  replace_patterns:

      "^($(regex))$"

      replace_with => comment("$(comment)"),
      comment => "Search and replace string";
}

bundle edit_line uncomment_lines_matching(regex,comment)
# @brief Uncomment lines of the file where the regex matches
# the entire text after the comment string
# @param regex The regex that lines need to match after `comment`
# @param comment The prefix of the line that is removed
{
  replace_patterns:

      "^$(comment)\s?($(regex))$"

      replace_with => uncomment,
      comment => "Uncomment lines matching a regular expression";
}

bundle edit_line comment_lines_containing(regex,comment)
# @brief Comment lines of the file matching a regex
# @param regex A regex that a part of the line needs to match
# @param comment A string that is prepended to matching lines
{
  replace_patterns:

      "^((?!$(comment)).*$(regex).*)$"

      replace_with => comment("$(comment)"),
      comment => "Comment out lines in a file";
}

bundle edit_line uncomment_lines_containing(regex,comment)
# @brief Uncomment lines of the file where the regex matches
# parts of the text after the comment string
# @param regex The regex that lines need to match after `comment`
# @param comment The prefix of the line that is removed
{
  replace_patterns:

      "^$(comment)\s?(.*$(regex).*)$"

      replace_with => uncomment,
      comment => "Uncomment a line containing a fragment";
}

bundle edit_line delete_lines_matching(regex)
# @brief Delete lines matching a regular expression
# @param regex The regular expression that the lines need to match
{
  delete_lines:

      "$(regex)"

      comment => "Delete lines matching regular expressions";
}

bundle edit_line warn_lines_matching(regex)
# @brief Warn about lines matching a regular expression
# @param regex The regular expression that the lines need to match
{
  delete_lines:

      "$(regex)"

      comment => "Warn about lines in a file",
      action => warn_only;
}

bundle edit_line prepend_if_no_line(string)
# @brief Prepend `string` if it doesn't exist in the file
# @param string The string to be prepended
#
# **See also:** [`insert_lines`][insert_lines] in
# [`edit_line`][bundle edit_line]
{
  insert_lines:
      "$(string)"
      location => start,
      comment => "Prepend a line to the file if it doesn't already exist";
}

bundle edit_line append_if_no_line(str)
# @ignore
# This duplicates the insert_lines bundle
{
  insert_lines:

      "$(str)"

      comment => "Append a line to the file if it doesn't already exist";
}

bundle edit_line append_if_no_lines(list)
# @ignore
# This duplicates the insert_lines bundle
{
  insert_lines:

      "$(list)"

      comment => "Append lines to the file if they don't already exist";
}

bundle edit_line replace_line_end(start,end)
# @brief Give lines starting with `start` the ending given in `end`
#
# Whitespaces will be left unmodified. For example,
# `replace_line_end("ftp", "2121/tcp")` would replace
#
# `"ftp             21/tcp"`
#
# with
#
# `"ftp             2121/tcp"`
#
# @param start The string lines have to start with
# @param end The string lines should end with
{
  field_edits:

      "\s*$(start)\s.*"
      comment => "Replace lines with $(this.start) and $(this.end)",
      edit_field => line("(^|\s)$(start)\s*", "2", "$(end)","set");
}

bundle edit_line append_to_line_end(start,end)
# @brief Append `end` to any lines beginning with `start`
#
# `end` will be appended to all lines starting with `start` and not
# already ending with `end`.  Whitespaces will be left unmodified.
#
# For example, `append_to_line_end("kernel", "vga=791")` would replace
# `kernel /boot/vmlinuz root=/dev/sda7`
#
# with
#
# `kernel /boot/vmlinuz root=/dev/sda7 vga=791`
#
# **WARNING**: Be careful not to have multiple promises matching the same line, which would result in the line growing indefinitely.
#
# @param start pattern to match lines of interest
# @param end string to append to matched lines
#
# **Example:**
#
# ```cf3
#  files:
#      "/tmp/boot-options" edit_line => append_to_line_end("kernel", "vga=791");
# ```
#
{
  field_edits:

      "\s*$(start)\s.*"
      comment => "Append lines with $(this.start) and $(this.end)",
      edit_field => line("(^|\s)$(start)\s*", "2", "$(end)","append");
}

bundle edit_line regex_replace(find,replace)
# @brief Find exactly a regular expression and replace exactly the match with a string.
# You can think of this like a PCRE powered sed.
# @param find The regular expression
# @param replace The replacement string
{
  replace_patterns:

      "$(find)"
      replace_with => value("$(replace)"),
      comment => "Search and replace string";
}

bundle edit_line resolvconf(search,list)
# @brief Adds search domains and name servers to the system
# resolver configuration.
#
# Use this bundle to modify `resolv.conf`. Existing entries for
# `search` and `nameserver` are replaced.
#
# @param search The search domains with space
# @param list An slist of nameserver addresses
{
  delete_lines:

      "search.*"     comment => "Reset search lines from resolver";
      "nameserver.*" comment => "Reset nameservers in resolver";

  insert_lines:

      "search $(search)"    comment => "Add search domains to resolver";
      "nameserver $(list)"  comment => "Add name servers to resolver";
}

bundle edit_line resolvconf_o(search,list,options)
# @brief Adds search domains, name servers and options to the system
# resolver configuration.
#
# Use this bundle to modify `resolv.conf`. Existing entries for
# `search`, `nameserver` and `options` are replaced.
#
# @param search The search domains with space
# @param list An slist of nameserver addresses
# @param options is an slist of variables to modify the resolver

{
  delete_lines:

      "search.*"     comment => "Reset search lines from resolver";
      "nameserver.*" comment => "Reset nameservers in resolver";
      "options.*"    comment => "Reset options in resolver";

  insert_lines:

      "search $(search)"    comment => "Add search domains to resolver";
      "nameserver $(list)"  comment => "Add name servers to resolver";
      "options $(options)"  comment => "Add options to resolver";
}

bundle edit_line manage_variable_values_ini(tab, sectionName)
# @brief Sets the RHS of configuration items in the file of the form
# `LHS=RHS`
#
# If the line is commented out with `#`, it gets uncommented first.
# Adds a new line if none exists.
# Removes any variable value pairs not defined for the ini section.
#
# @param tab An associative array containing `tab[sectionName][LHS]="RHS"`.
# The value is not changed when the `RHS` is "dontchange"
# @param sectionName The section in the file within which values should be
# modified
#
# **See also:** `set_variable_values_ini()`
{
  vars:
      "index" slist => getindices("$(tab)[$(sectionName)]");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

  classes:
      "edit_$(cindex[$(index)])"     not => strcmp("$($(tab)[$(sectionName)][$(index)])","dontchange"),
      comment => "Create conditions to make changes";

  field_edits:

      # If the line is there, but commented out, first uncomment it
      "#+\s*$(index)\s*=.*"
      select_region => INI_section("$(sectionName)"),
      edit_field => col("=","1","$(index)","set"),
      ifvarclass => "edit_$(cindex[$(index)])";

      # match a line starting like the key something
      "$(index)\s*=.*"
      edit_field => col("=","2","$($(tab)[$(sectionName)][$(index)])","set"),
      select_region => INI_section("$(sectionName)"),
      classes => if_ok("manage_variable_values_ini_not_$(cindex[$(index)])"),
      ifvarclass => "edit_$(cindex[$(index)])";

  delete_lines:
      ".*"
      select_region => INI_section("$(sectionName)"),
      comment       => "Remove all entries in the region so there are no extra entries";

  insert_lines:
      "[$(sectionName)]"
      location => start,
      comment => "Insert lines";

      "$(index)=$($(tab)[$(sectionName)][$(index)])"
      select_region => INI_section("$(sectionName)"),
      ifvarclass => "!manage_variable_values_ini_not_$(cindex[$(index)]).edit_$(cindex[$(index)])";

}

bundle edit_line set_variable_values_ini(tab, sectionName)
# @brief Sets the RHS of configuration items in the file of the form
# `LHS=RHS`
#
# If the line is commented out with `#`, it gets uncommented first.
# Adds a new line if none exists.
#
# @param tab An associative array containing `tab[sectionName][LHS]="RHS"`.
# The value is not changed when the `RHS` is "dontchange"
# @param sectionName The section in the file within which values should be
# modified
#
# **See also:** `set_variable_values_ini()`
{
  vars:
      "index" slist => getindices("$(tab)[$(sectionName)]");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

  classes:
      "edit_$(cindex[$(index)])"     not => strcmp("$($(tab)[$(sectionName)][$(index)])","dontchange"),
      comment => "Create conditions to make changes";

  field_edits:

      # If the line is there, but commented out, first uncomment it
      "#+\s*$(index)\s*=.*"
      select_region => INI_section("$(sectionName)"),
      edit_field => col("=","1","$(index)","set"),
      ifvarclass => "edit_$(cindex[$(index)])";

      # match a line starting like the key something
      "$(index)\s*=.*"
      edit_field => col("=","2","$($(tab)[$(sectionName)][$(index)])","set"),
      select_region => INI_section("$(sectionName)"),
      classes => if_ok("set_variable_values_ini_not_$(cindex[$(index)])"),
      ifvarclass => "edit_$(cindex[$(index)])";

  insert_lines:
      "[$(sectionName)]"
      location => start,
      comment => "Insert lines";

      "$(index)=$($(tab)[$(sectionName)][$(index)])"
      select_region => INI_section("$(sectionName)"),
      ifvarclass => "!set_variable_values_ini_not_$(cindex[$(index)]).edit_$(cindex[$(index)])";

}

bundle edit_line insert_ini_section(name, config)
# @brief Inserts a INI section with content
#
# ```
# # given an array "barray"
# files:
#     "myfile.ini" edit_line => insert_innit_section("foo", "barray");
# ```
#
# Inserts a section in an INI file with the given configuration
# key-values from the array `config`.
#
# @param name the name of the INI section
# @param config The fully-qualified name of an associative array containing `v[LHS]="rhs"`
{
  vars:
      "k" slist => getindices($(config));

  insert_lines:
      "[$(name)]"
      location => start,
      comment => "Prepend a line to the file if it doesn't already exist";

      "$(k)=$($(config)[$(k)])";
}

bundle edit_line set_quoted_values(v)
# @brief Sets the RHS of variables in shell-like files of the form:
#
# ```
#      LHS="RHS"
# ```
#
# Adds a new line if no LHS exists, and replaces RHS values if one does exist.
# If the line is commented out with #, it gets uncommented first.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
#
# **Example:**
#
# ```cf3
#     vars:
#        "stuff[lhs-1]" string => "rhs1";
#        "stuff[lhs-2]" string => "rhs2";
#
#     files:
#        "myfile"
#          edit_line => set_quoted_values(stuff)
# ```
#
# **See also:** `set_variable_values()`
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "index" slist => getindices("$(v)");
      # Be careful if the index string contains funny chars

      "cindex[$(index)]" string => canonify("$(index)");

  field_edits:
      # If the line is there, but commented out, first uncomment it
      "#+\s*$(index)\s*=.*"
      edit_field => col("=","1","$(index)","set");

      # match a line starting like the key = something
      "\s*$(index)\s*=.*"
      edit_field => col("=","2",'"$($(v)[$(index)])"',"set"),
      classes    => if_ok("$(cindex[$(index)])_in_file"),
      comment    => "Match a line starting like key = something";

  insert_lines:
      '$(index)="$($(v)[$(index)])"'
      comment    => "Insert a variable definition",
      ifvarclass => "!$(cindex[$(index)])_in_file";
}

bundle edit_line set_variable_values(v)
# @brief Sets the RHS of variables in files of the form:
#
# ```
#      LHS=RHS
# ```
#
# Adds a new line if no LHS exists, and replaces RHS values if one does exist.
# If the line is commented out with #, it gets uncommented first.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
#
# **Example:**
#
# ```cf3
#     vars:
#        "stuff[lhs-1]" string => "rhs1";
#        "stuff[lhs-2]" string => "rhs2";
#
#     files:
#        "myfile"
#          edit_line => set_quoted_values(stuff)
# ```
#
# **See also:** `set_quoted_values()`
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:

      "index" slist => getindices("$(v)");

      # Be careful if the index string contains funny chars

      "cindex[$(index)]" string => canonify("$(index)");
      "cv"               string => canonify("$(v)");

  field_edits:

      # match a line starting like the key = something

      "\s*$(index)\s*=.*"

      edit_field => col("\s*$(index)\s*=","2","$($(v)[$(index)])","set"),
      classes => if_ok("$(cv)_$(cindex[$(index)])_in_file"),
      comment => "Match a line starting like key = something";

  insert_lines:

      "$(index)=$($(v)[$(index)])"

      comment => "Insert a variable definition",
      ifvarclass => "!$(cv)_$(cindex[$(index)])_in_file";
}

bundle edit_line set_config_values(v)
# @brief Sets the RHS of configuration items in the file of the form:
#
# ```
#   LHS RHS
# ```
#
# If the line is commented out with `#`, it gets uncommented first.
#
# Adds a new line if none exists.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "index" slist => getindices("$(v)");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

      # Escape the value (had a problem with special characters and regex's)
      "ev[$(index)]" string => escape("$($(v)[$(index)])");

      # Do we have more than one line commented out?
      "index_comment_matches_$(cindex[$(index)])" int => countlinesmatching("^\s*#\s*($(index)\s+.*|$(index))$","$(edit.filename)");


  classes:
      # Check to see if this line exists
      "line_exists_$(cindex[$(index)])" expression => regline("^\s*($(index)\s.*|$(index))$","$(edit.filename)");

      # if there's more than one comment, just add new (don't know who to use)
      "multiple_comments_$(cindex[$(index)])" expression => isgreaterthan("$(index_comment_matches_$(cindex[$(index)]))","1");


  replace_patterns:
      # If the line is commented out, uncomment and replace with
      # the correct value
      "^\s*#\s*($(index)\s+.*|$(index))$"
             comment => "Uncommented the value $(index)",
        replace_with => value("$(index) $($(v)[$(index)])"),
          ifvarclass => "!line_exists_$(cindex[$(index)]).!replace_attempted_$(cindex[$(index)]).!multiple_comments_$(cindex[$(index)])",
             classes => always("uncommented_$(cindex[$(index)])");
      
      # If the line is there with the wrong value, replace with
      # the correct value
      "^\s*($(index)\s+(?!$(ev[$(index)])$).*|$(index))$"
           comment => "Correct the value $(index)",
      replace_with => value("$(index) $($(v)[$(index)])"),
           classes => always("replace_attempted_$(cindex[$(index)])");

  insert_lines:
      # If the line doesn't exist, or there is more than one occurrence
      # of the LHS commented out, insert a new line and try to place it
      # after the commented LHS (keep new line with old comments)
      "$(index) $($(v)[$(index)])"
         comment => "Insert the value, marker exists $(index)",
        location => after("^\s*#\s*($(index)\s+.*|$(index))$"),
      ifvarclass => "replace_attempted_$(cindex[$(index)]).multiple_comments_$(cindex[$(index)])";

      # If the line doesn't exist and there are no occurrences
      # of the LHS commented out, insert a new line at the eof
      "$(index) $($(v)[$(index)])"
         comment => "Insert the value, marker doesn't exist $(index)",
      ifvarclass => "replace_attempted_$(cindex[$(index)]).!multiple_comments_$(cindex[$(index)])";

}

bundle edit_line set_line_based(v, sep, bp, kp, cp)
# @brief Sets the RHS of configuration items in the file of the form:
#
# ```
#   LHS$(sep)RHS
# ```
#
# Example usage for `x=y` lines (e.g. rsyncd.conf):
#
# ```cf3
# "myfile"
# edit_line => set_line_based("test.config", "=", "\s*=\s*", ".*", "\s*#\s*");
# ```
#
# Example usage for `x y` lines (e.g. sshd_config):
#
# ```cf3
# "myfile"
# edit_line => set_line_based("test.config", " ", "\s+", ".*", "\s*#\s*");
# ```
#
# If the line is commented out with `$(cp)`, it gets uncommented first.
#
# Adds a new line if none exists or if more than one commented-out
# possible matches exist.
#
# Originally `set_config_values` by Ed King.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
# @param sep The separator to insert, e.g. ` ` for space-separated
# @param bp The key-value separation regex, e.g. `\s+` for space-separated
# @param kp The keys to select from v, use `.*` for all
# @param cp The comment pattern from line-start, e.g. `\s*#\s*`
{
  meta:
      "tags"
      slist =>
      {
        "replaces=set_config_values",
        "replaces=set_config_values_matching",
        "replaces=set_variable_values",
        "replaces=set_quoted_values",
        "replaces=maintain_key_values",
      };

  vars:
      "vkeys" slist => getindices("$(v)");
      "i" slist => grep($(kp), vkeys);

      # Be careful if the index string contains funny chars
      "ci[$(i)]" string => canonify("$(i)");

      # Escape the value (had a problem with special characters and regex's)
      "ev[$(i)]" string => escape("$($(v)[$(i)])");

      # Do we have more than one line commented out?
      "comment_matches_$(ci[$(i)])"
      int => countlinesmatching("^$(cp)($(i)$(bp).*|$(i))$",
                                $(edit.filename));


  classes:
      # Check to see if this line exists
      "exists_$(ci[$(i)])"
      expression => regline("^\s*($(i)$(bp).*|$(i))$",
                            $(edit.filename));

      # if there's more than one comment, just add new (don't know who to use)
      "multiple_comments_$(ci[$(i)])"
      expression => isgreaterthan("$(comment_matches_$(ci[$(i)]))",
                                  "1");


  replace_patterns:
      # If the line is commented out, uncomment and replace with
      # the correct value
      "^$(cp)($(i)$(bp).*|$(i))$"
             comment => "Uncommented the value '$(i)'",
        replace_with => value("$(i)$(sep)$($(v)[$(i)])"),
          ifvarclass => "!exists_$(ci[$(i)]).!replace_attempted_$(ci[$(i)]).!multiple_comments_$(ci[$(i)])",
             classes => always("uncommented_$(ci[$(i)])");

      # If the line is there with the wrong value, replace with
      # the correct value
      "^\s*($(i)$(bp)(?!$(ev[$(i)])$).*|$(i))$"
           comment => "Correct the value '$(i)'",
      replace_with => value("$(i)$(sep)$($(v)[$(i)])"),
           classes => always("replace_attempted_$(ci[$(i)])");

  insert_lines:
      # If the line doesn't exist, or there is more than one occurrence
      # of the LHS commented out, insert a new line and try to place it
      # after the commented LHS (keep new line with old comments)
      "$(i)$(sep)$($(v)[$(i)])"
         comment => "Insert the value, marker '$(i)' exists",
        location => after("^$(cp)($(i)$(bp).*|$(i))$"),
      ifvarclass => "replace_attempted_$(ci[$(i)]).multiple_comments_$(ci[$(i)])";

      # If the line doesn't exist and there are no occurrences
      # of the LHS commented out, insert a new line at the eof
      "$(i)$(sep)$($(v)[$(i)])"
         comment => "Insert the value, marker '$(i)' doesn't exist",
      ifvarclass => "replace_attempted_$(ci[$(i)]).!multiple_comments_$(ci[$(i)]).!exists_$(ci[$(i)])";

  reports:
    verbose_mode|EXTRA::
      "$(this.bundle): Line for '$(i)' exists" ifvarclass => "exists_$(ci[$(i)])";
      "$(this.bundle): Line for '$(i)' does not exist" ifvarclass => "!exists_$(ci[$(i)])";

}

bundle edit_line set_config_values_matching(v,pat)
# @brief Sets the RHS of configuration items in the file of the form
#
# ```
#   LHS RHS
# ```
#
# If the line is commented out with `#`, it gets uncommented first.
# Adds a new line if none exists.
#
# @param v the fully-qualified name of an associative array containing v[LHS]="rhs"
# @param pat Only elements of `v` that match the regex `pat` are use
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "allparams" slist => getindices("$(v)");
      "index"     slist => grep("$(pat)", "allparams");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

  replace_patterns:
      # If the line is there, maybe commented out, uncomment and replace with
      # the correct value
      "^\s*($(index)\s+(?!$($(v)[$(index)])).*|# ?$(index)\s+.*)$"
      comment => "Correct the value",
      replace_with => value("$(index) $($(v)[$(index)])"),
      classes => always("replace_attempted_$(cindex[$(index)])");

  insert_lines:
      "$(index) $($(v)[$(index)])"
      ifvarclass => "replace_attempted_$(cindex[$(index)])";

}

bundle edit_line maintain_key_values(v,sep)
# @ignore
# @brief Sets the RHS of configuration items with an giving separator
#
# Contributed by David Lee
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "index" slist => getindices("$(v)");
      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");
      # Matching pattern for line (basically key-and-separator)
      "keypat[$(index)]" string => "\s*$(index)\s*$(sep)\s*";

      # Values may contain regexps. Escape them for replace_pattern matching.
      "ve[$(index)]" string => escape("$($(v)[$(index)])");

  classes:
      "$(cindex[$(index)])_key_in_file"
      comment => "Dynamic Class created if patterns matching",
      expression => regline("^$(keypat[$(index)]).*", "$(edit.filename)");

  replace_patterns:
      # For convergence need to use negative lookahead on value:
      # "key sep (?!value).*"
      "^($(keypat[$(index)]))(?!$(ve[$(index)])$).*"
      comment => "Replace definition of $(index)",
      replace_with => value("$(match.1)$($(v)[$(index)])");

  insert_lines:
      "$(index)$(sep)$($(v)[$(index)])"
      comment => "Insert definition of $(index)",
      ifvarclass => "!$(cindex[$(index)])_key_in_file";
}

bundle edit_line append_users_starting(v)
# @brief For adding to `/etc/passwd` or `etc/shadow`
# @param v An array `v[username] string => "line..."`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  vars:

      "index"        slist => getindices("$(v)");

  classes:

      "add_$(index)"     not => userexists("$(index)"),
      comment => "Class created if user does not exist";

  insert_lines:

      "$($(v)[$(index)])"

      comment => "Append users into a password file format",
      ifvarclass => "add_$(index)";
}

bundle edit_line append_groups_starting(v)
# @brief For adding groups to `/etc/group`
# @param v An array `v[groupname] string => "line..."`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  vars:

      "index"        slist => getindices("$(v)");

  classes:

      "add_$(index)"     not => groupexists("$(index)"),
      comment => "Class created if group does not exist";

  insert_lines:

      "$($(v)[$(index)])"

      comment => "Append users into a group file format",
      ifvarclass => "add_$(index)";

}

bundle edit_line set_colon_field(key,field,val)
# @brief Set the value of field number `field` of the line whose
# first field is `key` to the value `val`, in a colon-separated file.
# @param key The value the first field has to match
# @param field The field to be modified
# @param val The new value of `field`
{
  field_edits:

      "$(key):.*"

      comment => "Edit a colon-separated file, using the first field as a key",
      edit_field => col(":","$(field)","$(val)","set");
}

bundle edit_line set_user_field(user,field,val)
# @brief Set the value of field number "field" in a `:-field`
# formatted file like `/etc/passwd`
# @param user The user to be modified
# @param field The field that should be modified
# @param val The value for `field`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  field_edits:

      "$(user):.*"

      comment => "Edit a user attribute in the password file",
      edit_field => col(":","$(field)","$(val)","set");
}

bundle edit_line append_user_field(group,field,allusers)
# @brief For adding users to to a file like `/etc/group`
# at field position `field`, comma separated subfields
# @param group The group to be modified
# @param field The field where users should be added
# @param allusers The list of users to add to `field`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  vars:

      "val" slist => { @(allusers) };

  field_edits:

      "$(group):.*"

      comment => "Append users into a password file format",
      edit_field => col(":","$(field)","$(val)","alphanum");
}

bundle edit_line expand_template(templatefile)
# @brief Read in the named text file and expand `$(var)` inside the file
# @param templatefile The name of the file
{
  insert_lines:

      "$(templatefile)"

      insert_type => "file",
      comment => "Expand variables in the template file",
      expand_scalars => "true";
}

bundle edit_line replace_or_add(pattern,line)
# @brief Replace a pattern in a file with a single line.
#
# If the pattern is not found, add the line to the file.
#
# @param pattern The pattern that should be replaced
# The pattern must match the whole line (it is automatically
# anchored to the start and end of the line) to avoid
# ambiguity.
# @param line The line with which to replace matches of `pattern`
{
  vars:
      "cline" string => canonify("$(line)");
      "eline" string => escape("$(line)");

  replace_patterns:
      "^(?!$(eline)$)$(pattern)$"
      comment => "Replace a pattern here",
      replace_with => value("$(line)"),
      classes => always("replace_done_$(cline)");

  insert_lines:
      "$(line)"
      ifvarclass => "replace_done_$(cline)";
}

bundle edit_line converge(marker, lines)
# @brief Converge `lines` marked with `marker`
#
# Any content marked with `marker` is removed, then `lines` are
# inserted.  Every `line` should contain `marker`.
#
# @param marker The marker (not a regular expression; will be escaped)
# @param lines The lines to insert; all must contain `marker`
{
  vars:
      "regex" string => escape($(marker));

  delete_lines:
      "$(regex)" comment => "Delete lines matching the marker";
  insert_lines:
      "$(lines)" comment => "Insert the given lines";
}

bundle edit_line fstab_option_editor(method, mount, option)
# @brief Add or remove `/etc/fstab` options for a mount
#
# This bundle edits the options field of a mount.  The `method` is a
# `field_operation` which can be `append`, `prepend`, `set`, `delete`,
# or `alphanum`.  The option is OS-specific.
#
# @param method `field_operation` to apply
# @param mount the mount point
# @param option the option to add or remove
#
# **Example:**
#
# ```cf3
#  files:
#      "/etc/fstab" edit_line => fstab_option_editor("delete", "/", "acl");
#      "/etc/fstab" edit_line => fstab_option_editor("append", "/", "acl");
# ```
{
   field_edits:
      "(?!#)\S+\s+$(mount)\s.+"
      edit_field => fstab_options($(option), $(method));
}

body edit_field fstab_options(newval, method)
# @brief Edit the options field in a fstab format
# @param newval the new option
# @param method `field_operation` to apply
#
# This body edits the options field in the fstab file format.  The
# `method` is a `field_operation` which can be `append`, `prepend`,
# `set`, `delete`, or `alphanum`.  The `newval` option is OS-specific.
#
# **Example:**
#
# ```cf3
#   # from the `fstab_options_editor`
#   field_edits:
#      "(?!#)\S+\s+$(mount)\s.+"
#      edit_field => fstab_options($(option), $(method));
# ```
{
      field_separator => "\s+";
      select_field    => "4";
      value_separator  => ",";
      field_value     => "$(newval)";
      field_operation => "$(method)";
}

body edit_field quoted_var(newval,method)
# @brief Edit the quoted value of the matching line
# @param newval The new value
# @param method The method by which to edit the field
{
      field_separator => "\"";
      select_field    => "2";
      value_separator  => " ";
      field_value     => "$(newval)";
      field_operation => "$(method)";
      extend_fields => "false";
      allow_blank_fields => "true";
}

body edit_field col(split,col,newval,method)
# @brief Edit tabluar data with comma-separated sub-values
# @param split The separator that defines columns
# @param col The (1-based) index of the value to change
# @param newval The new value
# @param method The method by which to edit the field
{
      field_separator    => "$(split)";
      select_field       => "$(col)";
      value_separator    => ",";
      field_value        => "$(newval)";
      field_operation    => "$(method)";
      extend_fields      => "true";
      allow_blank_fields => "true";
}

body edit_field line(split,col,newval,method)
# @brief Edit tabular data with space-separated sub-values
# @param split The separator that defines columns
# @param col The (1-based) index of the value to change
# @param newval The new value
# @param method The method by which to edit the field
{
      field_separator    => "$(split)";
      select_field       => "$(col)";
      value_separator    => " ";
      field_value        => "$(newval)";
      field_operation    => "$(method)";
      extend_fields      => "true";
      allow_blank_fields => "true";
}

body replace_with value(x)
# @brief Replace matching lines
# @param x The replacement string
{
      replace_value => "$(x)";
      occurrences => "all";
}

body select_region INI_section(x)
# @brief Restrict the `edit_line` promise to the lines in section `[x]`
# @param x The name of the section in an INI-like configuration file
{
      select_start => "\[$(x)\]\s*";
      select_end => "\[.*\]\s*";
}

body edit_defaults empty
# @brief Empty the file before editing
#
# No backup is made
{
      empty_file_before_editing => "true";
      edit_backup => "false";
      #max_file_size => "300000";
}

body location start
# @brief Editing occurs before the matched line
{
      before_after => "before";
}

body location after(str)
# @brief Editing occurs after the line matching `str`
# @param str Regular expression matching the file line location
{
      before_after => "after";
      select_line_matching => "$(str)";
}

body location before(str)
# @brief Editing occurs before the line matching `str`
# @param str Regular expression matching the file line location
{
      before_after => "before";
      select_line_matching => "$(str)";
}

body replace_with comment(c)
# @brief Comment all lines matching the pattern by preprending `c`
# @param c The prefix that comments out lines
{
      replace_value => "$(c) $(match.1)";
      occurrences => "all";
}

body replace_with uncomment
# @brief Uncomment all lines matching the pattern by removing
# anything outside the matching string
{
      replace_value => "$(match.1)";
      occurrences => "all";
}

body copy_from secure_cp(from,server)
# @brief Download a file from a remote server over an encrypted channel
#
# Only copy the file if it is different from the local copy, and verify
# that the copy is correct.
# 
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      source      => "$(from)";
      servers     => { "$(server)" };
      compare     => "digest";
      encrypt     => "true";
      verify      => "true";
}

body copy_from remote_cp(from,server)
# @brief Download a file from a remote server.
#
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      servers     => { "$(server)" };
      source      => "$(from)";
      compare     => "mtime";
}

body copy_from remote_dcp(from,server)
# @brief Download a file from a remote server if it is different from the local copy.
#
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      servers     => { "$(server)" };
      source      => "$(from)";
      compare     => "digest";
}

body copy_from local_cp(from)
# @brief Copy a local file.
#
# @param from The path to the source file.
{
      source      => "$(from)";
}

body copy_from local_dcp(from)
# @brief Copy a local file if it is different from the existing copy.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      compare     => "digest";
}

body copy_from perms_cp(from)
# @brief Copy a local file and preserve file permissions on the local copy.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      preserve    => "true";
}

body copy_from perms_dcp(from)
# @brief Copy a local file if it is different from the existing copy and
# preserve file permissions on the local copy.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      preserve    => "true";
      compare     => "digest";
}

body copy_from backup_local_cp(from)
# @brief Copy a local file and  keep a backup of old versions.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      copy_backup => "timestamp";
}

body copy_from seed_cp(from)
# @brief Copy a local file if the file does not already exist, i.e. seed the placement
#
# @param from The path to the source file.
{
      source      => "$(from)";
      compare     => "exists";
}

body copy_from sync_cp(from,server)
# @brief Download a file if the local copy does not already exist, i.e. seed the placement
#
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      servers     => { "$(server)" };
      source      => "$(from)";
      purge       => "true";
      preserve    => "true";
      type_check  => "false";
}

body copy_from no_backup_cp(from)
# @brief Copy a local file and don't make any backup of the previous version
#
# @param from The path to the source file.
{
      source      => "$(from)";
      copy_backup => "false";
}

body copy_from no_backup_dcp(from)
# @brief Copy a local file if contents have changed, and don't make any backup
# of the previous version
#
# @param from The path to the source file.
{
      source      => "$(from)";
      copy_backup => "false";
      compare     => "digest";
}

body link_from linkfrom(source, type)
# @brief Make any kind of link to a file
# @param source link to this
# @param type the link's type (`symlink` or `hardlink`)
{
      source => $(source);
      link_type => $(type);
}

body perms m(mode)
# @brief Set the file mode
# @param mode The new mode
{
      mode   => "$(mode)";
}

body perms mo(mode,user)
# @brief Set the file's mode and owners
# @param mode The new mode
# @param user The username of the new owner
{
      owners => { "$(user)" };
      mode   => "$(mode)";
}

body perms mog(mode,user,group)
# @brief Set the file's mode, owner and group
# @param mode The new mode
# @param user The username of the new owner
# @param group The group name
{
      owners => { "$(user)" };
      groups => { "$(group)" };
      mode   => "$(mode)";
}

body perms og(u,g)
# @brief Set the file's owner and group
# @param u The username of the new owner
# @param g The group name
{
      owners => { "$(u)" };
      groups => { "$(g)" };
}

body perms owner(user)
# @brief Set the file's owner
# @param user The username of the new owner
{
      owners => { "$(user)" };
}

body perms system_owned(mode)
# @brief Set the file owner and group to the system default
# @param mode the access permission in octal format
#
# **Example:**
#
# ```cf3
# files:
#     "/etc/passwd" perms => system_owned("0644");
# ```
{
      mode   => "$(mode)";
      owners => { "root" };

    freebsd|openbsd|netbsd|darwin::
      groups => { "wheel" };

    linux::
      groups => { "root" };

    solaris::
      groups => { "sys" };
}

body depth_search recurse(d)
# @brief Search files and direcories recursively, up to the specified depth
# Directories on different devices are included.
#
# @param d The maximum search depth
{
      depth => "$(d)";
      xdev  => "true";
}

body depth_search recurse_ignore(d,list)
# @brief Search files and directories recursively,
# but don't recurse into the specified directories
#
# @param d The maximum search depth
# @param list The list of directories to be excluded
{
      depth => "$(d)";
      exclude_dirs => { @(list) };
}

body depth_search recurse_with_base(d)
# @brief Search files and directories recursively up to the specified
# depth, starting from the base directory and including directories on
# other devices.
#
# @param d The maximum search depth
{
      depth => "$(d)";
      xdev  => "true";
      include_basedir => "true";
}

body delete tidy
# @brief Delete the file and remove empty directories
# and links to directories
{
      dirlinks => "delete";
      rmdirs   => "true";
}

body file_select all
# @brief Select all file system entries
{
      leaf_name => { ".*" };
      file_result => "leaf_name";
}

body changes all_changes
# @brief Detect all file changes using sha256
# and report the diff to CFEngine Enterprise
{
      hash           => "sha256";
      report_changes => "all";
      report_diffs   => "true";
      update_hashes  => "yes";
}

bundle agent file_mustache(mustache_file, json_file, target_file)
# @brief Make a file from a Mustache template and a JSON file
# @param mustache_file the file with the Mustache template
# @param json_file a file with JSON data
# @param target_file the target file to write
#
# **Example:**
#
# ```cf3
# methods:
#      "m" usebundle => file_mustache("x.mustache", "y.json", "z.txt");
# ```
{
  files:
      "$(target_file)"
      create => "true",
      edit_template => $(mustache_file),
      template_data => readjson($(json_file), "100k"),
      template_method => "mustache";
}

bundle agent file_mustache_jsonstring(mustache_file, json_string, target_file)
# @brief Make a file from a Mustache template and a JSON string
# @param mustache_file the file with the Mustache template
# @param json_string a string with JSON data
# @param target_file the target file to write
#
# **Example:**
#
# ```cf3
# methods:
#      "m" usebundle => file_mustache_jsonstring("x.mustache", '{ "x": "y" }', "z.txt");
# ```
{
  files:
      "$(target_file)"
      create => "true",
      edit_template => $(mustache_file),
      template_data => parsejson($(json_string)),
      template_method => "mustache";
}

bundle agent file_tidy(file)
# @brief Remove a file
# @param file to remove
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_tidy("/tmp/z.txt");
# ```
{
  files:
      "$(file)" delete => tidy;

  reports:
    inform_mode|EXTRA::
      "$(this.bundle): deleting $(file) with delete => tidy";
}

bundle agent dir_sync(from, to)
# @brief Synchronize a directory entire, deleting unknown files
# @param from source directory
# @param to destination directory
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => dir_sync("/tmp", "/var/tmp");
# ```
{
  files:
      "$(to)/."
      create => "true",
      depth_search => recurse("inf"),
      copy_from => copyfrom_sync($(from));

  reports:
    inform_mode|EXTRA::
      "$(this.bundle): copying directory $(from) to $(to)";
}

bundle agent file_copy(from, to)
# @brief Copy a file
# @param from source file
# @param to destination file
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_copy("/tmp/z.txt", "/var/tmp/y.txt");
# ```
{
  files:
      "$(to)"
      copy_from => copyfrom_sync($(from));

  reports:
    inform_mode|EXTRA::
      "$(this.bundle): copying file $(from) to $(to)";
}

body copy_from copyfrom_sync(f)
# @brief Copy a directory or file with digest checksums, preserving attributes and purging leftovers
# @param f the file or directory
{
      source => "$(f)";
      purge => "true";
      preserve => "true";
      type_check => "false";
      compare => "digest";
}

bundle agent file_make(file, str)
# @brief Make a file from a string
# @param file target
# @param str the string data
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_make("/tmp/z.txt", "Some text
# and some more text here");
# ```
{
  files:
      "$(file)"
      create => "true",
      edit_line => insert_lines($(str)),
      edit_defaults => empty;

  reports:
    inform_mode|EXTRA::
      "$(this.bundle): creating $(file) with contents '$(str)'";
}

bundle agent file_empty(file)
# @brief Make an empty file
# @param file target
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_empty("/tmp/z.txt");
# ```
{
  files:
      "$(file)"
      create => "true",
      edit_defaults => empty;

  reports:
    inform_mode|EXTRA::
      "$(this.bundle): creating empty $(file) with 0 size";
}

bundle agent file_hardlink(target, link)
# @brief Make a hard link to a file
# @param target of link
# @param link the hard link's location
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_hardlink("/tmp/z.txt", "/tmp/z.link");
# ```
{
  files:
      "$(link)"
      move_obstructions => "true",
      link_from => linkfrom($(target), "hardlink");

  reports:
    inform_mode|EXTRA::
      "$(this.bundle): $(link) will be a hard link to $(target)";
}

bundle agent file_link(target, link)
# @brief Make a symlink to a file
# @param target of symlink
# @param link the symlink's location
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_link("/tmp/z.txt", "/tmp/z.link");
# ```
{
  files:
      "$(link)"
      move_obstructions => "true",
      link_from => linkfrom($(target), "symlink");

  reports:
    inform_mode|EXTRA::
      "$(this.bundle): $(link) will be a symlink to $(target)";
}

bundle edit_line create_solaris_admin_file
# @brief The following bundle is part of a package setup for solaris
#
# See unit examples.
{
  insert_lines:

      "$(solaris_knowledge.admin_nocheck)"
      comment => "Insert contents of Solaris admin file (automatically install packages)";
}
