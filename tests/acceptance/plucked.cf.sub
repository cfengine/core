### This is an auto-generated file, see Makefile.am and `make pluck` ###

bundle agent run_ifdefined(namespace, mybundle)
# @brief bundle to maybe run another bundle dynamically
# @param namespace the namespace, usually `$(this.namespace)`
# @param mybundle the bundle to maybe run
#
# This bundle simply is a way to run another bundle only if it's defined.
#
# **Example:**
#
# ```cf3
# bundle agent run
# {
#   methods:
#       # does nothing if bundle "runthis" is not defined
#       "go" usebundle => run_ifdefined($(this.namespace), runthis);
# }
# ```
{
  vars:
      "bundlesfound" slist => bundlesmatching("^$(namespace):$(mybundle)$");
      "count" int => length(bundlesfound);

  methods:
      "any"
      usebundle  => $(bundlesfound),
      ifvarclass => strcmp(1, $(count));

  reports:
    verbose_mode::
      "$(this.bundle): found matching bundles $(bundlesfound) for namespace '$(namespace)' and bundle '$(mybundle)'";
}

body contain in_dir_shell(dir)
# @brief run command after switching to directory "dir" with full shell
# @param dir directory to change into
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_dir_shell("/tmp");
# ```
{
      chdir => "$(dir)";
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
}

body contain in_shell
# @brief run command in shell
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_shell;
# ```
{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
}

body contain in_shell_bg
# @brief deprecated
# This bundle previously had an invalid background attribute that was caught by
# parser strictness enhancements. Backgrounding is handeled by the body action
# background attribute.
{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
}

body contain in_shell_and_silent
# @brief run command in shell and suppress output
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_shell_and_silent,
#      comment => "Silently run command in shell";
# ```
{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
      no_output => "true";
}

body contain in_dir_shell_and_silent(dir)
# @brief run command in shell after switching to 'dir' and suppress output
# @param dir directory to change into
#
# **Example:**
#
# ```cf3
#  commands:
#    "/bin/pwd | /bin/cat"
#      contain => in_dir_shell_and_silent("/tmp"),
#      comment => "Silently run command in shell";
# ```

{
      useshell => "true"; # canonical "useshell" but this is backwards-compatible
      no_output => "true";
      chdir => "$(dir)";
}

body action if_elapsed(x)
# @brief Evaluate the promise every `x` minutes
# @param x The time in minutes between promise evaluations
{
      ifelapsed => "$(x)";
      expireafter => "$(x)";
}

body action if_elapsed_day
# @brief Evalute the promise once every 24 hours
{
      ifelapsed => "1440";    # 60 x 24
      expireafter => "1400";
}

body action warn_only
# @brief Warn once an hour if the promise needs to be repaired
#
# The promise does not get repaired.
{
      action_policy => "warn";
      ifelapsed => "60";
}

body action immediate
# @brief Evaluate the promise at every `cf-agent` execution.
{
      ifelapsed => "0";
}

body classes if_repaired(x)
# @brief Define class `x` if the promise has been repaired
# @param x The name of the class
{
      promise_repaired => { "$(x)" };
}

body classes if_else(yes,no)
# @brief Define the classes `yes` or `no` depending on promise outcome
# @param yes The name of the class that should be defined if the promise is kept or repaired
# @param no The name of the class that should be defined if the promise could not be repaired
{
      promise_kept     => { "$(yes)" };
      promise_repaired => { "$(yes)" };
      repair_failed    => { "$(no)" };
      repair_denied    => { "$(no)" };
      repair_timeout   => { "$(no)" };
}

body classes if_notkept(x)
# @brief Define the class `x` if the promise is not kept and cannot be repaired.
# @param x The name of the class that should be defined
{
      repair_failed   => { "$(x)" };
      repair_denied   => { "$(x)" };
      repair_timeout  => { "$(x)" };
}

body classes if_ok(x)
# @brief Define the class `x` if the promise is kept or could be repaired
# @param x The name of the class that should be defined
{
      promise_repaired => { "$(x)" };
      promise_kept => { "$(x)" };
}

body classes if_ok_cancel(x)
# @brief Cancel the class `x` if the promise ks kept or repaired
# @param x The name of the class that should be cancelled
{
      cancel_repaired => { "$(x)" };
      cancel_kept => { "$(x)" };
}

body classes classes_generic(x)
# @brief Define `x` prefixed/suffixed with promise outcome
# @param x The unique part of the classes to be defined
{
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_reached" };
}

body classes results(scope, class_prefix)
# @brief Define classes prefixed with `class_prefix` and suffixed with
# appropriate outcomes: _kept, _repaired, _not_kept, _error, _failed,
# _denied, _timeout, _reached
#
# @param scope The scope in which the class should be defined (`bundle` or `namespace`)
# @param class_prefix The prefix for the classes defined
#
# This body can be applied to any promise and sets global
# (`namespace`) or local (`bundle`) classes based on its outcome. For
# instance, with `class_prefix` set to `abc`:
#
# * if the promise is to change a file's owner to `nick` and the file
# was already owned by `nick`, the classes `abc_reached` and
# `abc_kept` will be set.
#
# * if the promise is to change a file's owner to `nick` and the file
# was owned by `adam` and the change succeeded, the classes
# `abc_reached` and `abc_repaired` will be set.
#
# This body is a simpler, more consistent version of the body
# `scoped_classes_generic`, which see. The key difference is that
# fewer classes are defined, and only for outcomes that we can know.
# For example this body does not define "OK/not OK" outcome classes,
# since a promise can be both kept and failed at the same time.
#
# It's important to understand that promises may do multiple things,
# so a promise is not simply "OK" or "not OK." The best way to
# understand what will happen when your specific promises get this
# body is to test it in all the possible combinations.
#
# **Suffix Notes:**
#
# * `_reached` indicates the promise was tried. Any outcome will result
#   in a class with this suffix being defined.
#
# * `_kept` indicates some aspect of the promise was kept
#
# * `_repaired` indicates some aspect of the promise was repaired
#
# * `_not_kept` indicates some aspect of the promise was not kept.
#   error, failed, denied and timeout outcomes will result in a class
#   with this suffix being defined
#
# * `_error` indicates the promise repair encountered an error
#
# * `_failed` indicates the promise failed
#
# * `_denied` indicates the promise repair was denied
#
# * `_timeout` indicates the promise timed out
#
# **Example:**
#
# ```cf3
# bundle agent example
# {
#   commands:
#     "/bin/true"
#       classes => results("bundle", "my_class_prefix");
#
#   reports:
#     my_class_prefix_kept::
#       "My promise was kept";
#
#     my_class_prefix_repaired::
#       "My promise was repaired";
# }
# ```
#
# **See also:** `scope`, `scoped_classes_generic`, `classes_generic`
{
  scope => "$(scope)";

  promise_kept => { "$(class_prefix)_reached",
                    "$(class_prefix)_kept" };

  promise_repaired => { "$(class_prefix)_reached",
                        "$(class_prefix)_repaired" };

  repair_failed => { "$(class_prefix)_reached",
                     "$(class_prefix)_error",
                     "$(class_prefix)_not_kept",
                     "$(class_prefix)_failed" };

  repair_denied => { "$(class_prefix)_reached",
                     "$(class_prefix)_error",
                     "$(class_prefix)_not_kept",
                     "$(class_prefix)_denied" };

  repair_timeout => { "$(class_prefix)_reached",
                      "$(class_prefix)_error",
                      "$(class_prefix)_not_kept",
                      "$(class_prefix)_timeout" };
}

body classes scoped_classes_generic(scope, x)
# @brief Define `x` prefixed/suffixed with promise outcome
# **See also:** `scope`
#
# @param scope The scope in which the class should be defined
# @param x The unique part of the classes to be defined
{
      scope => "$(scope)";
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_reached" };
}

body classes always(x)
# @brief Define class `x` no matter what the outcome of the promise is
# @param x The name of the class to be defined
{
      promise_repaired => { "$(x)" };
      promise_kept => { "$(x)" };
      repair_failed => { "$(x)" };
      repair_denied => { "$(x)" };
      repair_timeout => { "$(x)" };
}

body classes kept_successful_command
# @brief Set command to "kept" instead of "repaired" if it returns 0
{
      kept_returncodes => { "0" };
}

bundle edit_line insert_before_if_no_line(before, string)
# @brief Insert `string` before `before` if `string` is not found in the file
# @param before The regular expression matching the line which `string` will be
# inserted before
# @param string The string to be prepended
#
{
  insert_lines:
      "$(string)"
        location => before($(before)),
        comment => "Prepend a line to the file if it doesn't already exist";
}

bundle edit_line insert_lines(lines)
# @brief Append `lines` if they don't exist in the file
# @param lines The lines to be appended
#
# **See also:** [`insert_lines`][insert_lines] in
# [`edit_line`][bundle edit_line]
{
  insert_lines:

      "$(lines)"
      comment => "Append lines if they don't exist";
}

bundle edit_line insert_file(templatefile)
# @brief Reads the lines from `templatefile` and inserts those into the
# file being edited.
# @param templatefile The name of the file from which to import lines.
{
  insert_lines:

      "$(templatefile)"
      comment => "Insert the template file into the file being edited",
      insert_type => "file";
}

bundle edit_line comment_lines_matching(regex,comment)
# @brief Comment lines in the file that matching an [anchored] regex
# @param regex Anchored regex that the entire line needs to match
# @param comment A string that is prepended to matching lines
{
  replace_patterns:

      "^($(regex))$"

      replace_with => comment("$(comment)"),
      comment => "Search and replace string";
}

bundle edit_line uncomment_lines_matching(regex,comment)
# @brief Uncomment lines of the file where the regex matches
# the entire text after the comment string
# @param regex The regex that lines need to match after `comment`
# @param comment The prefix of the line that is removed
{
  replace_patterns:

      "^$(comment)\s?($(regex))$"

      replace_with => uncomment,
      comment => "Uncomment lines matching a regular expression";
}

bundle edit_line comment_lines_containing(regex,comment)
# @brief Comment lines of the file matching a regex
# @param regex A regex that a part of the line needs to match
# @param comment A string that is prepended to matching lines
{
  replace_patterns:

      "^((?!$(comment)).*$(regex).*)$"

      replace_with => comment("$(comment)"),
      comment => "Comment out lines in a file";
}

bundle edit_line uncomment_lines_containing(regex,comment)
# @brief Uncomment lines of the file where the regex matches
# parts of the text after the comment string
# @param regex The regex that lines need to match after `comment`
# @param comment The prefix of the line that is removed
{
  replace_patterns:

      "^$(comment)\s?(.*$(regex).*)$"

      replace_with => uncomment,
      comment => "Uncomment a line containing a fragment";
}

bundle edit_line delete_lines_matching(regex)
# @brief Delete lines matching a regular expression
# @param regex The regular expression that the lines need to match
{
  delete_lines:

      "$(regex)"

      comment => "Delete lines matching regular expressions";
}

bundle edit_line warn_lines_matching(regex)
# @brief Warn about lines matching a regular expression
# @param regex The regular expression that the lines need to match
{
  delete_lines:

      "$(regex)"

      comment => "Warn about lines in a file",
      action => warn_only;
}

bundle edit_line prepend_if_no_line(string)
# @brief Prepend `string` if it doesn't exist in the file
# @param string The string to be prepended
#
# **See also:** [`insert_lines`][insert_lines] in
# [`edit_line`][bundle edit_line]
{
  insert_lines:
      "$(string)"
      location => start,
      comment => "Prepend a line to the file if it doesn't already exist";
}

bundle edit_line append_if_no_line(str)
# @ignore
# This duplicates the insert_lines bundle
{
  insert_lines:

      "$(str)"

      comment => "Append a line to the file if it doesn't already exist";
}

bundle edit_line append_if_no_lines(list)
# @ignore
# This duplicates the insert_lines bundle
{
  insert_lines:

      "$(list)"

      comment => "Append lines to the file if they don't already exist";
}

bundle edit_line replace_line_end(start,end)
# @brief Give lines starting with `start` the ending given in `end`
#
# Whitespaces will be left unmodified. For example,
# `replace_line_end("ftp", "2121/tcp")` would replace
#
# `"ftp             21/tcp"`
#
# with
#
# `"ftp             2121/tcp"`
#
# @param start The string lines have to start with
# @param end The string lines should end with
{
  field_edits:

      "\s*$(start)\s.*"
      comment => "Replace lines with $(this.start) and $(this.end)",
      edit_field => line("(^|\s)$(start)\s*", "2", "$(end)","set");
}

bundle edit_line append_to_line_end(start,end)
# @brief Append `end` to any lines beginning with `start`
#
# `end` will be appended to all lines starting with `start` and not
# already ending with `end`.  Whitespaces will be left unmodified.
#
# For example, `append_to_line_end("kernel", "vga=791")` would replace
# `kernel /boot/vmlinuz root=/dev/sda7`
#
# with
#
# `kernel /boot/vmlinuz root=/dev/sda7 vga=791`
#
# **WARNING**: Be careful not to have multiple promises matching the same line, which would result in the line growing indefinitely.
#
# @param start pattern to match lines of interest
# @param end string to append to matched lines
#
# **Example:**
#
# ```cf3
#  files:
#      "/tmp/boot-options" edit_line => append_to_line_end("kernel", "vga=791");
# ```
#
{
  field_edits:

      "\s*$(start)\s.*"
      comment => "Append lines with $(this.start) and $(this.end)",
      edit_field => line("(^|\s)$(start)\s*", "2", "$(end)","append");
}

bundle edit_line regex_replace(find,replace)
# @brief Find exactly a regular expression and replace exactly the match with a string.
# You can think of this like a PCRE powered sed.
# @param find The regular expression
# @param replace The replacement string
{
  replace_patterns:

      "$(find)"
      replace_with => value("$(replace)"),
      comment => "Search and replace string";
}

bundle edit_line resolvconf(search,list)
# @brief Adds search domains and name servers to the system
# resolver configuration.
#
# Use this bundle to modify `resolv.conf`. Existing entries for
# `search` and `nameserver` are replaced.
#
# @param search The search domains with space
# @param list An slist of nameserver addresses
{
  delete_lines:

      "search.*"     comment => "Reset search lines from resolver";
      "nameserver.*" comment => "Reset nameservers in resolver";

  insert_lines:

      "search $(search)"    comment => "Add search domains to resolver";
      "nameserver $(list)"  comment => "Add name servers to resolver";
}

bundle edit_line resolvconf_o(search,list,options)
# @brief Adds search domains, name servers and options to the system
# resolver configuration.
#
# Use this bundle to modify `resolv.conf`. Existing entries for
# `search`, `nameserver` and `options` are replaced.
#
# @param search The search domains with space
# @param list An slist of nameserver addresses
# @param options is an slist of variables to modify the resolver

{
  delete_lines:

      "search.*"     comment => "Reset search lines from resolver";
      "nameserver.*" comment => "Reset nameservers in resolver";
      "options.*"    comment => "Reset options in resolver";

  insert_lines:

      "search $(search)"    comment => "Add search domains to resolver";
      "nameserver $(list)"  comment => "Add name servers to resolver";
      "options $(options)"  comment => "Add options to resolver";
}

bundle edit_line manage_variable_values_ini(tab, sectionName)
# @brief Sets the RHS of configuration items in the file of the form
# `LHS=RHS`
#
# If the line is commented out with `#`, it gets uncommented first.
# Adds a new line if none exists.
# Removes any variable value pairs not defined for the ini section.
#
# @param tab An associative array containing `tab[sectionName][LHS]="RHS"`.
# The value is not changed when the `RHS` is "dontchange"
# @param sectionName The section in the file within which values should be
# modified
#
# **See also:** `set_variable_values_ini()`
{
  vars:
      "index" slist => getindices("$(tab)[$(sectionName)]");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

  classes:
      "edit_$(cindex[$(index)])"     not => strcmp("$($(tab)[$(sectionName)][$(index)])","dontchange"),
      comment => "Create conditions to make changes";

  field_edits:

      # If the line is there, but commented out, first uncomment it
      "#+\s*$(index)\s*=.*"
      select_region => INI_section(escape("$(sectionName)")),
      edit_field => col("=","1","$(index)","set"),
      ifvarclass => "edit_$(cindex[$(index)])";

      # match a line starting like the key something
      "$(index)\s*=.*"
      edit_field => col("=","2","$($(tab)[$(sectionName)][$(index)])","set"),
      select_region => INI_section(escape("$(sectionName)")),
      classes => results("bundle", "manage_variable_values_ini_not_$(cindex[$(index)])"),
      ifvarclass => "edit_$(cindex[$(index)])";

  delete_lines:
      ".*"
      select_region => INI_section(escape("$(sectionName)")),
      comment       => "Remove all entries in the region so there are no extra entries";

  insert_lines:
      "[$(sectionName)]"
      location => start,
      comment => "Insert lines";

      "$(index)=$($(tab)[$(sectionName)][$(index)])"
      select_region => INI_section(escape("$(sectionName)")),
        ifvarclass => "!(manage_variable_values_ini_not_$(cindex[$(index)])_kept|manage_variable_values_ini_not_$(cindex[$(index)])_repaired).edit_$(cindex[$(index)])";

}

bundle edit_line set_variable_values_ini(tab, sectionName)
# @brief Sets the RHS of configuration items in the file of the form
# `LHS=RHS`
#
# If the line is commented out with `#`, it gets uncommented first.
# Adds a new line if none exists.
#
# @param tab An associative array containing `tab[sectionName][LHS]="RHS"`.
# The value is not changed when the `RHS` is "dontchange"
# @param sectionName The section in the file within which values should be
# modified
#
# **See also:** `manage_variable_values_ini()`
{
  vars:
      "index" slist => getindices("$(tab)[$(sectionName)]");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

  classes:
      "edit_$(cindex[$(index)])"     not => strcmp("$($(tab)[$(sectionName)][$(index)])","dontchange"),
      comment => "Create conditions to make changes";

  field_edits:

      # If the line is there, but commented out, first uncomment it
      "#+\s*$(index)\s*=.*"
      select_region => INI_section("$(sectionName)"),
      edit_field => col("=","1","$(index)","set"),
      ifvarclass => "edit_$(cindex[$(index)])";

      # match a line starting like the key something
      "$(index)\s*=.*"
      edit_field => col("=","2","$($(tab)[$(sectionName)][$(index)])","set"),
      select_region => INI_section("$(sectionName)"),
      classes => results("bundle", "set_variable_values_ini_not_$(cindex[$(index)])"),
      ifvarclass => "edit_$(cindex[$(index)])";

  insert_lines:
      "[$(sectionName)]"
      location => start,
      comment => "Insert lines";

      "$(index)=$($(tab)[$(sectionName)][$(index)])"
      select_region => INI_section("$(sectionName)"),
        ifvarclass => "!(set_variable_values_ini_not_$(cindex[$(index)])_kept|set_variable_values_ini_not_$(cindex[$(index)])_repaired).edit_$(cindex[$(index)])";

}

bundle edit_line insert_ini_section(name, config)
# @brief Inserts a INI section with content
#
# ```
# # given an array "barray"
# files:
#     "myfile.ini" edit_line => insert_innit_section("foo", "barray");
# ```
#
# Inserts a section in an INI file with the given configuration
# key-values from the array `config`.
#
# @param name the name of the INI section
# @param config The fully-qualified name of an associative array containing `v[LHS]="rhs"`
{
  vars:
      "k" slist => getindices($(config));

  insert_lines:
      "[$(name)]"
      location => start,
      comment => "Prepend a line to the file if it doesn't already exist";

      "$(k)=$($(config)[$(k)])";
}

bundle edit_line set_quoted_values(v)
# @brief Sets the RHS of variables in shell-like files of the form:
#
# ```
#      LHS="RHS"
# ```
#
# Adds a new line if no LHS exists, and replaces RHS values if one does exist.
# If the line is commented out with #, it gets uncommented first.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
#
# **Example:**
#
# ```cf3
#     vars:
#        "stuff[lhs-1]" string => "rhs1";
#        "stuff[lhs-2]" string => "rhs2";
#
#     files:
#        "myfile"
#          edit_line => set_quoted_values(stuff)
# ```
#
# **See also:** `set_variable_values()`
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "index" slist => getindices("$(v)");
      # Be careful if the index string contains funny chars

      "cindex[$(index)]" string => canonify("$(index)");

  field_edits:
      # If the line is there, but commented out, first uncomment it
      "#+\s*$(index)\s*=.*"
      edit_field => col("=","1","$(index)","set");

      # match a line starting like the key = something
      "\s*$(index)\s*=.*"
      edit_field => col("=","2",'"$($(v)[$(index)])"',"set"),
      classes    => results("bundle", "$(cindex[$(index)])_in_file"),
      comment    => "Match a line starting like key = something";

  insert_lines:
      '$(index)="$($(v)[$(index)])"'
      comment    => "Insert a variable definition",
        ifvarclass => "!($(cindex[$(index)])_in_file_kept|$(cindex[$(index)])_in_file_repaired)";
}

bundle edit_line set_variable_values(v)
# @brief Sets the RHS of variables in files of the form:
#
# ```
#      LHS=RHS
# ```
#
# Adds a new line if no LHS exists, and replaces RHS values if one does exist.
# If the line is commented out with #, it gets uncommented first.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
#
# **Example:**
#
# ```cf3
#     vars:
#        "stuff[lhs-1]" string => "rhs1";
#        "stuff[lhs-2]" string => "rhs2";
#
#     files:
#        "myfile"
#          edit_line => set_variable_values(stuff)
# ```
#
# **See also:** `set_quoted_values()`
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:

      "index" slist => getindices("$(v)");

      # Be careful if the index string contains funny chars

      "cindex[$(index)]" string => canonify("$(index)");
      "cv"               string => canonify("$(v)");

  field_edits:

      # match a line starting like the key = something

      "\s*$(index)\s*=.*"

      edit_field => col("\s*$(index)\s*=","2","$($(v)[$(index)])","set"),
      classes => results("bundle", "$(cv)_$(cindex[$(index)])_in_file"),
      comment => "Match a line starting like key = something";

  insert_lines:

      "$(index)=$($(v)[$(index)])"

      comment => "Insert a variable definition",
        ifvarclass => "!($(cv)_$(cindex[$(index)])_in_file_kept|$(cv)_$(cindex[$(index)])_in_file_repaired)";
}

bundle edit_line set_config_values(v)
# @brief Sets the RHS of configuration items in the file of the form:
#
# ```
#   LHS RHS
# ```
#
# If the line is commented out with `#`, it gets uncommented first.
#
# Adds a new line if none exists.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "index" slist => getindices("$(v)");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

      # Escape the value (had a problem with special characters and regex's)
      "ev[$(index)]" string => escape("$($(v)[$(index)])");

      # Do we have more than one line commented out?
      "index_comment_matches_$(cindex[$(index)])"
        int => countlinesmatching("^\s*#\s*($(index)\s+.*|$(index))$","$(edit.filename)");


  classes:
      # Check to see if this line exists
      "line_exists_$(cindex[$(index)])"
        expression => regline("^\s*($(index)\s.*|$(index))$","$(edit.filename)"),
        scope => "bundle";

      # if there's more than one comment, just add new (don't know who to use)
      "multiple_comments_$(cindex[$(index)])"
        expression => isgreaterthan("$(index_comment_matches_$(cindex[$(index)]))","1"),
        scope => "bundle";

  replace_patterns:
      # If the line is commented out, uncomment and replace with
      # the correct value
      "^\s*#\s*($(index)\s+.*|$(index))$"
        comment => "If we find a single commented entry we can uncomment it to
                    keep the settings near any inline documentation. If there
                    are multiple comments, then we don't try to replace them and
                    instead will later append the new value after the first
                    commented occurrence of $(index).",
        handle => "set_config_values_replace_commented_line",
        replace_with => value("$(index) $($(v)[$(index)])"),
          ifvarclass => "!line_exists_$(cindex[$(index)]).!replace_attempted_$(cindex[$(index)])_reached.!multiple_comments_$(cindex[$(index)])",
             classes => results("bundle", "uncommented_$(cindex[$(index)])");

      # If the line is there with the wrong value, replace with
      # the correct value
      "^\s*($(index)\s+(?!$(ev[$(index)])$).*|$(index))$"
           comment => "Correct the value $(index)",
      replace_with => value("$(index) $($(v)[$(index)])"),
           classes => results("bundle", "replace_attempted_$(cindex[$(index)])");

  insert_lines:
      # If the line doesn't exist, or there is more than one occurrence
      # of the LHS commented out, insert a new line and try to place it
      # after the commented LHS (keep new line with old comments)
      "$(index) $($(v)[$(index)])"
         comment => "Insert the value, marker exists $(index)",
        location => after("^\s*#\s*($(index)\s+.*|$(index))$"),
      ifvarclass => "replace_attempted_$(cindex[$(index)])_reached.multiple_comments_$(cindex[$(index)])";

      # If the line doesn't exist and there are no occurrences
      # of the LHS commented out, insert a new line at the eof
      "$(index) $($(v)[$(index)])"
         comment => "Insert the value, marker doesn't exist $(index)",
      ifvarclass => "replace_attempted_$(cindex[$(index)])_reached.!multiple_comments_$(cindex[$(index)])";

}

bundle edit_line set_line_based(v, sep, bp, kp, cp)
# @brief Sets the RHS of configuration items in the file of the form:
#
# ```
#   LHS$(sep)RHS
# ```
#
# Example usage for `x=y` lines (e.g. rsyncd.conf):
#
# ```cf3
# "myfile"
# edit_line => set_line_based("test.config", "=", "\s*=\s*", ".*", "\s*#\s*");
# ```
#
# Example usage for `x y` lines (e.g. sshd_config):
#
# ```cf3
# "myfile"
# edit_line => set_line_based("test.config", " ", "\s+", ".*", "\s*#\s*");
# ```
#
# If the line is commented out with `$(cp)`, it gets uncommented first.
#
# Adds a new line if none exists or if more than one commented-out
# possible matches exist.
#
# Originally `set_config_values` by Ed King.
#
# @param v The fully-qualified name of an associative array containing `v[LHS]="rhs"`
# @param sep The separator to insert, e.g. ` ` for space-separated
# @param bp The key-value separation regex, e.g. `\s+` for space-separated
# @param kp The keys to select from v, use `.*` for all
# @param cp The comment pattern from line-start, e.g. `\s*#\s*`
{
  meta:
      "tags"
      slist =>
      {
        "replaces=set_config_values",
        "replaces=set_config_values_matching",
        "replaces=set_variable_values",
        "replaces=set_quoted_values",
        "replaces=maintain_key_values",
      };

  vars:
      "vkeys" slist => getindices("$(v)");
      "i" slist => grep($(kp), vkeys);

      # Be careful if the index string contains funny chars
      "ci[$(i)]" string => canonify("$(i)");

      # Escape the value (had a problem with special characters and regex's)
      "ev[$(i)]" string => escape("$($(v)[$(i)])");

      # Do we have more than one line commented out?
      "comment_matches_$(ci[$(i)])"
      int => countlinesmatching("^$(cp)($(i)$(bp).*|$(i))$",
                                $(edit.filename));


  classes:
      # Check to see if this line exists
      "exists_$(ci[$(i)])"
      expression => regline("^\s*($(i)$(bp).*|$(i))$",
                            $(edit.filename));

      # if there's more than one comment, just add new (don't know who to use)
      "multiple_comments_$(ci[$(i)])"
      expression => isgreaterthan("$(comment_matches_$(ci[$(i)]))",
                                  "1");


  replace_patterns:
      # If the line is commented out, uncomment and replace with
      # the correct value
      "^$(cp)($(i)$(bp).*|$(i))$"
             comment => "Uncommented the value '$(i)'",
        replace_with => value("$(i)$(sep)$($(v)[$(i)])"),
          ifvarclass => "!exists_$(ci[$(i)]).!replace_attempted_$(ci[$(i)])_reached.!multiple_comments_$(ci[$(i)])",
             classes => results("bundle", "uncommented_$(ci[$(i)])");

      # If the line is there with the wrong value, replace with
      # the correct value
      "^\s*($(i)$(bp)(?!$(ev[$(i)])$).*|$(i))$"
           comment => "Correct the value '$(i)'",
      replace_with => value("$(i)$(sep)$($(v)[$(i)])"),
           classes => results("bundle", "replace_attempted_$(ci[$(i)])");

  insert_lines:
      # If the line doesn't exist, or there is more than one occurrence
      # of the LHS commented out, insert a new line and try to place it
      # after the commented LHS (keep new line with old comments)
      "$(i)$(sep)$($(v)[$(i)])"
         comment => "Insert the value, marker '$(i)' exists",
        location => after("^$(cp)($(i)$(bp).*|$(i))$"),
      ifvarclass => "replace_attempted_$(ci[$(i)])_reached.multiple_comments_$(ci[$(i)])";

      # If the line doesn't exist and there are no occurrences
      # of the LHS commented out, insert a new line at the eof
      "$(i)$(sep)$($(v)[$(i)])"
         comment => "Insert the value, marker '$(i)' doesn't exist",
      ifvarclass => "replace_attempted_$(ci[$(i)])_reached.!multiple_comments_$(ci[$(i)]).!exists_$(ci[$(i)])";

  reports:
    verbose_mode|EXTRA::
      "$(this.bundle): Line for '$(i)' exists" ifvarclass => "exists_$(ci[$(i)])";
      "$(this.bundle): Line for '$(i)' does not exist" ifvarclass => "!exists_$(ci[$(i)])";
}

bundle edit_line set_config_values_matching(v,pat)
# @brief Sets the RHS of configuration items in the file of the form
#
# ```
#   LHS RHS
# ```
#
# If the line is commented out with `#`, it gets uncommented first.
# Adds a new line if none exists.
#
# @param v the fully-qualified name of an associative array containing v[LHS]="rhs"
# @param pat Only elements of `v` that match the regex `pat` are use
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "allparams" slist => getindices("$(v)");
      "index"     slist => grep("$(pat)", "allparams");

      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");

  replace_patterns:
      # If the line is there, maybe commented out, uncomment and replace with
      # the correct value
      "^\s*($(index)\s+(?!$($(v)[$(index)])).*|# ?$(index)\s+.*)$"
      comment => "Correct the value",
      replace_with => value("$(index) $($(v)[$(index)])"),
      classes => results("bundle", "replace_attempted_$(cindex[$(index)])");

  insert_lines:
      "$(index) $($(v)[$(index)])"
      ifvarclass => "replace_attempted_$(cindex[$(index)])_reached";

}

bundle edit_line maintain_key_values(v,sep)
# @ignore
# @brief Sets the RHS of configuration items with an giving separator
#
# Contributed by David Lee
{
  meta:
      "tags"
      slist =>
      {
        "deprecated=3.6.0",
        "deprecation-reason=Generic reimplementation",
        "replaced-by=set_line_based"
      };

  vars:
      "index" slist => getindices("$(v)");
      # Be careful if the index string contains funny chars
      "cindex[$(index)]" string => canonify("$(index)");
      # Matching pattern for line (basically key-and-separator)
      "keypat[$(index)]" string => "\s*$(index)\s*$(sep)\s*";

      # Values may contain regexps. Escape them for replace_pattern matching.
      "ve[$(index)]" string => escape("$($(v)[$(index)])");

  classes:
      "$(cindex[$(index)])_key_in_file"
      comment => "Dynamic Class created if patterns matching",
      expression => regline("^$(keypat[$(index)]).*", "$(edit.filename)");

  replace_patterns:
      # For convergence need to use negative lookahead on value:
      # "key sep (?!value).*"
      "^($(keypat[$(index)]))(?!$(ve[$(index)])$).*"
      comment => "Replace definition of $(index)",
      replace_with => value("$(match.1)$($(v)[$(index)])");

  insert_lines:
      "$(index)$(sep)$($(v)[$(index)])"
      comment => "Insert definition of $(index)",
      ifvarclass => "!$(cindex[$(index)])_key_in_file";
}

bundle edit_line append_users_starting(v)
# @brief For adding to `/etc/passwd` or `etc/shadow`
# @param v An array `v[username] string => "line..."`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  vars:

      "index"        slist => getindices("$(v)");

  classes:

      "add_$(index)"     not => userexists("$(index)"),
      comment => "Class created if user does not exist";

  insert_lines:

      "$($(v)[$(index)])"

      comment => "Append users into a password file format",
      ifvarclass => "add_$(index)";
}

bundle edit_line append_groups_starting(v)
# @brief For adding groups to `/etc/group`
# @param v An array `v[groupname] string => "line..."`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  vars:

      "index"        slist => getindices("$(v)");

  classes:

      "add_$(index)"     not => groupexists("$(index)"),
      comment => "Class created if group does not exist";

  insert_lines:

      "$($(v)[$(index)])"

      comment => "Append users into a group file format",
      ifvarclass => "add_$(index)";

}

bundle edit_line set_colon_field(key,field,val)
# @brief Set the value of field number `field` of the line whose
# first field is `key` to the value `val`, in a colon-separated file.
# @param key The value the first field has to match
# @param field The field to be modified
# @param val The new value of `field`
{
  field_edits:

      "$(key):.*"

      comment => "Edit a colon-separated file, using the first field as a key",
      edit_field => col(":","$(field)","$(val)","set");
}

bundle edit_line set_user_field(user,field,val)
# @brief Set the value of field number "field" in a `:-field`
# formatted file like `/etc/passwd`
# @param user The user to be modified
# @param field The field that should be modified
# @param val The value for `field`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  field_edits:

      "$(user):.*"

      comment => "Edit a user attribute in the password file",
      edit_field => col(":","$(field)","$(val)","set");
}

bundle edit_line append_user_field(group,field,allusers)
# @brief For adding users to to a file like `/etc/group`
# at field position `field`, comma separated subfields
# @param group The group to be modified
# @param field The field where users should be added
# @param allusers The list of users to add to `field`
#
# **Note:** To manage local users with CFEngine 3.6 and later,
# consider making `users` promises instead of modifying system files.
{
  vars:

      "val" slist => { @(allusers) };

  field_edits:

      "$(group):.*"

      comment => "Append users into a password file format",
      edit_field => col(":","$(field)","$(val)","alphanum");
}

bundle edit_line expand_template(templatefile)
# @brief Read in the named text file and expand `$(var)` inside the file
# @param templatefile The name of the file
{
  insert_lines:

      "$(templatefile)"

      insert_type => "file",
      comment => "Expand variables in the template file",
      expand_scalars => "true";
}

bundle edit_line replace_or_add(pattern,line)
# @brief Replace a pattern in a file with a single line.
#
# If the pattern is not found, add the line to the file.
#
# @param pattern The pattern that should be replaced
# The pattern must match the whole line (it is automatically
# anchored to the start and end of the line) to avoid
# ambiguity.
# @param line The line with which to replace matches of `pattern`
{
  vars:
      "cline" string => canonify("$(line)");
      "eline" string => escape("$(line)");

  replace_patterns:
      "^(?!$(eline)$)$(pattern)$"
      comment => "Replace a pattern here",
      replace_with => value("$(line)"),
      classes => results("bundle", "replace_$(cline)");

  insert_lines:
      "$(line)"
      ifvarclass => "replace_$(cline)_reached";
}

bundle edit_line converge(marker, lines)
# @brief Converge `lines` marked with `marker`
#
# Any content marked with `marker` is removed, then `lines` are
# inserted.  Every `line` should contain `marker`.
#
# @param marker The marker (not a regular expression; will be escaped)
# @param lines The lines to insert; all must contain `marker`
{
  vars:
      "regex" string => escape($(marker));

  delete_lines:
      "$(regex)" comment => "Delete lines matching the marker";
  insert_lines:
      "$(lines)" comment => "Insert the given lines";
}

bundle edit_line fstab_option_editor(method, mount, option)
# @brief Add or remove `/etc/fstab` options for a mount
#
# This bundle edits the options field of a mount.  The `method` is a
# `field_operation` which can be `append`, `prepend`, `set`, `delete`,
# or `alphanum`.  The option is OS-specific.
#
# @param method `field_operation` to apply
# @param mount the mount point
# @param option the option to add or remove
#
# **Example:**
#
# ```cf3
#  files:
#      "/etc/fstab" edit_line => fstab_option_editor("delete", "/", "acl");
#      "/etc/fstab" edit_line => fstab_option_editor("append", "/", "acl");
# ```
{
   field_edits:
      "(?!#)\S+\s+$(mount)\s.+"
      edit_field => fstab_options($(option), $(method));
}

body edit_field fstab_options(newval, method)
# @brief Edit the options field in a fstab format
# @param newval the new option
# @param method `field_operation` to apply
#
# This body edits the options field in the fstab file format.  The
# `method` is a `field_operation` which can be `append`, `prepend`,
# `set`, `delete`, or `alphanum`.  The `newval` option is OS-specific.
#
# **Example:**
#
# ```cf3
#   # from the `fstab_options_editor`
#   field_edits:
#      "(?!#)\S+\s+$(mount)\s.+"
#      edit_field => fstab_options($(option), $(method));
# ```
{
      field_separator => "\s+";
      select_field    => "4";
      value_separator  => ",";
      field_value     => "$(newval)";
      field_operation => "$(method)";
}

body edit_field quoted_var(newval,method)
# @brief Edit the quoted value of the matching line
# @param newval The new value
# @param method The method by which to edit the field
{
      field_separator => "\"";
      select_field    => "2";
      value_separator  => " ";
      field_value     => "$(newval)";
      field_operation => "$(method)";
      extend_fields => "false";
      allow_blank_fields => "true";
}

body edit_field col(split,col,newval,method)
# @brief Edit tabluar data with comma-separated sub-values
# @param split The separator that defines columns
# @param col The (1-based) index of the value to change
# @param newval The new value
# @param method The method by which to edit the field
{
      field_separator    => "$(split)";
      select_field       => "$(col)";
      value_separator    => ",";
      field_value        => "$(newval)";
      field_operation    => "$(method)";
      extend_fields      => "true";
      allow_blank_fields => "true";
}

body edit_field line(split,col,newval,method)
# @brief Edit tabular data with space-separated sub-values
# @param split The separator that defines columns
# @param col The (1-based) index of the value to change
# @param newval The new value
# @param method The method by which to edit the field
{
      field_separator    => "$(split)";
      select_field       => "$(col)";
      value_separator    => " ";
      field_value        => "$(newval)";
      field_operation    => "$(method)";
      extend_fields      => "true";
      allow_blank_fields => "true";
}

body replace_with value(x)
# @brief Replace matching lines
# @param x The replacement string
{
      replace_value => "$(x)";
      occurrences => "all";
}

body select_region INI_section(x)
# @brief Restrict the `edit_line` promise to the lines in section `[x]`
# @param x The name of the section in an INI-like configuration file
{
      select_start => "\[$(x)\]\s*";
      select_end => "\[.*\]\s*";

@if minimum_version(3.10)
      select_end_match_eof => "true";
@endif
}

body edit_defaults empty
# @brief Empty the file before editing
#
# No backup is made
{
      empty_file_before_editing => "true";
      edit_backup => "false";
      #max_file_size => "300000";
}

body location start
# @brief Editing occurs before the matched line
{
      before_after => "before";
}

body location after(str)
# @brief Editing occurs after the line matching `str`
# @param str Regular expression matching the file line location
{
      before_after => "after";
      select_line_matching => "$(str)";
}

body location before(str)
# @brief Editing occurs before the line matching `str`
# @param str Regular expression matching the file line location
{
      before_after => "before";
      select_line_matching => "$(str)";
}

body replace_with comment(c)
# @brief Comment all lines matching the pattern by preprending `c`
# @param c The prefix that comments out lines
{
      replace_value => "$(c) $(match.1)";
      occurrences => "all";
}

body replace_with uncomment
# @brief Uncomment all lines matching the pattern by removing
# anything outside the matching string
{
      replace_value => "$(match.1)";
      occurrences => "all";
}

body copy_from secure_cp(from,server)
# @brief Download a file from a remote server over an encrypted channel
#
# Only copy the file if it is different from the local copy, and verify
# that the copy is correct.
#
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      source      => "$(from)";
      servers     => { "$(server)" };
      compare     => "digest";
      encrypt     => "true";
      verify      => "true";
}

body copy_from remote_cp(from,server)
# @brief Download a file from a remote server.
#
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      servers     => { "$(server)" };
      source      => "$(from)";
      compare     => "mtime";
}

body copy_from remote_dcp(from,server)
# @brief Download a file from a remote server if it is different from the local copy.
#
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      servers     => { "$(server)" };
      source      => "$(from)";
      compare     => "digest";
}

body copy_from local_cp(from)
# @brief Copy a local file.
#
# @param from The path to the source file.
{
      source      => "$(from)";
}

body copy_from local_dcp(from)
# @brief Copy a local file if it is different from the existing copy.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      compare     => "digest";
}

body copy_from perms_cp(from)
# @brief Copy a local file and preserve file permissions on the local copy.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      preserve    => "true";
}

body copy_from perms_dcp(from)
# @brief Copy a local file if it is different from the existing copy and
# preserve file permissions on the local copy.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      preserve    => "true";
      compare     => "digest";
}

body copy_from backup_local_cp(from)
# @brief Copy a local file and  keep a backup of old versions.
#
# @param from The path to the source file.
{
      source      => "$(from)";
      copy_backup => "timestamp";
}

body copy_from seed_cp(from)
# @brief Copy a local file if the file does not already exist, i.e. seed the placement
#
# @param from The path to the source file.
{
      source      => "$(from)";
      compare     => "exists";
}

body copy_from sync_cp(from,server)
# @brief Download a file if the local copy does not already exist, i.e. seed the placement
#
# @param from The location of the file on the remote server
# @param server The hostname or IP of the server from which to download
{
      servers     => { "$(server)" };
      source      => "$(from)";
      purge       => "true";
      preserve    => "true";
      type_check  => "false";
}

body copy_from no_backup_cp(from)
# @brief Copy a local file and don't make any backup of the previous version
#
# @param from The path to the source file.
{
      source      => "$(from)";
      copy_backup => "false";
}

body copy_from no_backup_dcp(from)
# @brief Copy a local file if contents have changed, and don't make any backup
# of the previous version
#
# @param from The path to the source file.
{
      source      => "$(from)";
      copy_backup => "false";
      compare     => "digest";
}

body link_from linkfrom(source, type)
# @brief Make any kind of link to a file
# @param source link to this
# @param type the link's type (`symlink` or `hardlink`)
{
      source => $(source);
      link_type => $(type);
}

body perms m(mode)
# @brief Set the file mode
# @param mode The new mode
{
      mode   => "$(mode)";
}

body perms mo(mode,user)
# @brief Set the file's mode and owners
# @param mode The new mode
# @param user The username of the new owner
{
      owners => { "$(user)" };
      mode   => "$(mode)";
}

body perms mog(mode,user,group)
# @brief Set the file's mode, owner and group
# @param mode The new mode
# @param user The username of the new owner
# @param group The group name
{
      owners => { "$(user)" };
      groups => { "$(group)" };
      mode   => "$(mode)";
}

body perms og(u,g)
# @brief Set the file's owner and group
# @param u The username of the new owner
# @param g The group name
{
      owners => { "$(u)" };
      groups => { "$(g)" };
}

body perms owner(user)
# @brief Set the file's owner
# @param user The username of the new owner
{
      owners => { "$(user)" };
}

body perms system_owned(mode)
# @brief Set the file owner and group to the system default
# @param mode the access permission in octal format
#
# **Example:**
#
# ```cf3
# files:
#     "/etc/passwd" perms => system_owned("0644");
# ```
{
      mode   => "$(mode)";
      owners => { "root" };

    freebsd|openbsd|netbsd|darwin::
      groups => { "wheel" };

    linux::
      groups => { "root" };

    solaris::
      groups => { "sys" };
}

body depth_search recurse(d)
# @brief Search files and direcories recursively, up to the specified depth
# Directories on different devices are included.
#
# @param d The maximum search depth
{
      depth => "$(d)";
      xdev  => "true";
}

body depth_search recurse_ignore(d,list)
# @brief Search files and directories recursively,
# but don't recurse into the specified directories
#
# @param d The maximum search depth
# @param list The list of directories to be excluded
{
      depth => "$(d)";
      exclude_dirs => { @(list) };
}

body depth_search recurse_with_base(d)
# @brief Search files and directories recursively up to the specified
# depth, starting from the base directory and including directories on
# other devices.
#
# @param d The maximum search depth
{
      depth => "$(d)";
      xdev  => "true";
      include_basedir => "true";
}

body delete tidy
# @brief Delete the file and remove empty directories
# and links to directories
{
      dirlinks => "delete";
      rmdirs   => "true";
}

body file_select all
# @brief Select all file system entries
{
      leaf_name => { ".*" };
      file_result => "leaf_name";
}

body changes all_changes
# @brief Detect all file changes using sha256
# and report the diff to CFEngine Enterprise
{
      hash           => "sha256";
      report_changes => "all";
      report_diffs   => "true";
      update_hashes  => "yes";
}

bundle agent file_mustache(mustache_file, json_file, target_file)
# @brief Make a file from a Mustache template and a JSON file
# @param mustache_file the file with the Mustache template
# @param json_file a file with JSON data
# @param target_file the target file to write
#
# **Example:**
#
# ```cf3
# methods:
#      "m" usebundle => file_mustache("x.mustache", "y.json", "z.txt");
# ```
{
  files:
      "$(target_file)"
      create => "true",
      edit_template => $(mustache_file),
      template_data => readjson($(json_file), "100k"),
      template_method => "mustache";
}

bundle agent file_mustache_jsonstring(mustache_file, json_string, target_file)
# @brief Make a file from a Mustache template and a JSON string
# @param mustache_file the file with the Mustache template
# @param json_string a string with JSON data
# @param target_file the target file to write
#
# **Example:**
#
# ```cf3
# methods:
#      "m" usebundle => file_mustache_jsonstring("x.mustache", '{ "x": "y" }', "z.txt");
# ```
{
  files:
      "$(target_file)"
      create => "true",
      edit_template => $(mustache_file),
      template_data => parsejson($(json_string)),
      template_method => "mustache";
}

bundle agent file_tidy(file)
# @brief Remove a file
# @param file to remove
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_tidy("/tmp/z.txt");
# ```
{
  files:
      "$(file)" delete => tidy;

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): deleting $(file) with delete => tidy";
}

bundle agent dir_sync(from, to)
# @brief Synchronize a directory entire, deleting unknown files
# @param from source directory
# @param to destination directory
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => dir_sync("/tmp", "/var/tmp");
# ```
{
  files:
      "$(to)/."
      create => "true",
      depth_search => recurse("inf"),
      copy_from => copyfrom_sync($(from));

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): copying directory $(from) to $(to)";
}

bundle agent file_copy(from, to)
# @brief Copy a file
# @param from source file
# @param to destination file
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_copy("/tmp/z.txt", "/var/tmp/y.txt");
# ```
{
  files:
      "$(to)"
      copy_from => copyfrom_sync($(from));

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): copying file $(from) to $(to)";
}

body copy_from copyfrom_sync(f)
# @brief Copy a directory or file with digest checksums, preserving attributes and purging leftovers
# @param f the file or directory
{
      source => "$(f)";
      purge => "true";
      preserve => "true";
      type_check => "false";
      compare => "digest";
}

bundle agent file_make(file, str)
# @brief Make a file from a string
# @param file target
# @param str the string data
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_make("/tmp/z.txt", "Some text
# and some more text here");
# ```
{
  vars:
      "len" int => string_length($(str));
    summarize::
      "summary" string => format("%s...%s",
                                string_head($(str), 18),
                                string_tail($(str), 18));
  classes:
      "summarize" expression => isgreaterthan($(len), 40);

  files:
      "$(file)"
      create => "true",
      edit_line => insert_lines($(str)),
      edit_defaults => empty;

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): creating $(file) with contents '$(str)'"
      ifvarclass => "!summarize";

      "DEBUG $(this.bundle): creating $(file) with contents '$(summary)'"
      ifvarclass => "summarize";
}

bundle agent file_make_mog(file, str, mode, owner, group)
# @brief Make a file from a string with mode, owner, group
# @param file target
# @param str the string data
# @param mode the file permissions in octal
# @param owner the file owner as a name or UID
# @param group the file group as a name or GID
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_make_mog("/tmp/z.txt", "Some text
# and some more text here", "0644", "root", "root");
# ```
{
  vars:
      "len" int => string_length($(str));
    summarize::
      "summary" string => format("%s...%s",
                                string_head($(str), 18),
                                string_tail($(str), 18));
  classes:
      "summarize" expression => isgreaterthan($(len), 40);

  files:
      "$(file)"
      create => "true",
      edit_line => insert_lines($(str)),
      perms => mog($(mode), $(owner), $(group)),
      edit_defaults => empty;

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): creating $(file) with contents '$(str)', mode '$(mode)', owner '$(owner)' and group '$(group)'"
      ifvarclass => "!summarize";

      "DEBUG $(this.bundle): creating $(file) with contents '$(summary)', mode '$(mode)', owner '$(owner)' and group '$(group)'"
      ifvarclass => "summarize";
}

bundle agent file_empty(file)
# @brief Make an empty file
# @param file target
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_empty("/tmp/z.txt");
# ```
{
  files:
      "$(file)"
      create => "true",
      edit_defaults => empty;

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): creating empty $(file) with 0 size";
}

bundle agent file_hardlink(target, link)
# @brief Make a hard link to a file
# @param target of link
# @param link the hard link's location
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_hardlink("/tmp/z.txt", "/tmp/z.link");
# ```
{
  files:
      "$(link)"
      move_obstructions => "true",
      link_from => linkfrom($(target), "hardlink");

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): $(link) will be a hard link to $(target)";
}

bundle agent file_link(target, link)
# @brief Make a symlink to a file
# @param target of symlink
# @param link the symlink's location
#
# **Example:**
#
# ```cf3
# methods:
#      "" usebundle => file_link("/tmp/z.txt", "/tmp/z.link");
# ```
{
  files:
      "$(link)"
      move_obstructions => "true",
      link_from => linkfrom($(target), "symlink");

  reports:
    "DEBUG|DEBUG_$(this.bundle)"::
      "DEBUG $(this.bundle): $(link) will be a symlink to $(target)";
}

bundle edit_line create_solaris_admin_file
# @brief The following bundle is part of a package setup for solaris
#
# See unit examples.
{
  insert_lines:

      "$(solaris_knowledge.admin_nocheck)"
      comment => "Insert contents of Solaris admin file (automatically install packages)";
}
